_DEBUG = true

local clipboard = require("neverlose/clipboard")
local base64 = require("neverlose/base64")
local json = require("json")
local pui = require("neverlose/pui")
local gradient = require("neverlose/gradient")
local mtools = require("neverlose/mtools")
local smoothy = require( 'neverlose/smoothy' )

local getUsername = common.get_username
local player = entity.get_local_player

local alphv_states = {}

local refs = {
    double_tap = pui.find("Aimbot", "Ragebot", "Main", "Double Tap");
    hide_shots = pui.find("Aimbot", "Ragebot", "Main", "Hide Shots");
    double_tap_fl = pui.find("Aimbot", "Ragebot", "Main", "Double Tap", "Fake Lag Limit");

    hitchance = pui.find("Aimbot", "Ragebot", "Selection", "Hit Chance");

    pitch = pui.find("Aimbot", "Anti Aim", "Angles", "Pitch");

    yaw = pui.find("Aimbot", "Anti Aim", "Angles", "Yaw");
    yaw_base = pui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Base");
    yaw_offset = pui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Offset");
    antiback_stab = pui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Avoid Backstab");
    hidden_yaw = pui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Hidden");

    yaw_modifier = pui.find("Aimbot", "Anti Aim", "Angles", "Yaw Modifier");
    modifier_offset = pui.find("Aimbot", "Anti Aim", "Angles", "Yaw Modifier", "Offset");

    body_yaw = pui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw");
    inverter = pui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Inverter");
    left_limit = pui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Left Limit");
    right_limit = pui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Right Limit");
    options = pui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Options");
    body_fs = pui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Freestanding");
    
    fl_limit = pui.find("Aimbot", "Anti Aim", "Fake Lag", "Limit");
    fl_variability = pui.find("Aimbot", "Anti Aim", "Fake Lag", "Variability");

    freestanding = pui.find("Aimbot", "Anti Aim", "Angles", "Freestanding");
    disableModifiers = pui.find("Aimbot", "Anti Aim", "Angles", "Freestanding", "Disable Yaw Modifiers"),
    bodyFreestanding = pui.find("Aimbot", "Anti Aim", "Angles", "Freestanding", "Body Freestanding"),
    
    airStrafe = ui.find("Miscellaneous", "Main", "Movement", "Air Strafe"),
    assist = ui.find("Miscellaneous", "Main", "Movement", "Strafe Assist"),

    slow_walk = pui.find("Aimbot", "Anti Aim", "Misc", "Slow Walk"),

    fd = pui.find("Aimbot", "Anti Aim", "Misc", "Fake Duck")
}

local Functions = { }
local Utility = { }

local SHADOWYAW_COLOR_HEX = "A78D9FFF" 

Utility.color_text = function(...)
    local args = {...}
    local result = ""
    
    for index, value in ipairs(args) do
        local text = value[1]
        local color_val = value[2] or "255, 255, 255"
    
        if type(color_val) == "userdata" then
            color_val = color_val:to_hex()
        elseif type(color_val) == "string" then
            local r, g, b = color_val:match("(%d+),%s*(%d+),%s*(%d+)")
            if r and g and b then
                color_val = ("FF%02X%02X%02X"):format(tonumber(r), tonumber(g), tonumber(b), 255)
            end
        end
    
        result = result .. ("\a%s%s"):format(color_val, text)
    end
    
    return result
end

if not math.lerp then
    math.lerp = function(a, b, t)
        return a + (b - a) * t
    end
end

Utility.disableRefs = function()
    for _, ref in pairs(refs) do
        if ref and type(ref.override) == "function" then
            ref:override(ref:get())
        end
    end
    cvar.r_aspectratio:float(0)
    cvar.viewmodel_fov:float(60)
    cvar.viewmodel_offset_x:float(2.5)
    cvar.viewmodel_offset_y:float(0)
    cvar.viewmodel_offset_z:float(-5)
end

local folderPath = "csgo/shadowyaw"
local filePath = folderPath .. "/configsData.json"

files.create_folder(folderPath)

local configsData = files.read(filePath)
if configsData == nil then
    local default_config_base64_string = "eyJhbnRpIGFpbSI6eyJhbnRpX2JhY2tzdGFiIjp0cnVlLCJmcmVlc3RhbmRpbmciOmZhbHNlLCJwaXRjaCI6IkRvd24iLCJzYWZlX2hlYWRfb25fa25pZmUiOnRydWUsInlhd0Jhc2UiOiJBdCBUYXJnZXQiLCJ+ZnJlZXN0YW5kaW5nIjp7ImJvZHlGcmVlc3RhbmQiOnRydWUsImRpc2FibGVNb2RpZmllcnMiOnRydWV9fSwiYW50aSBhaW0gc3RhdGVzIjp7ImNhY2hlIjp7ImN0Ijp7ImFpciI6eyJhbnRpQnJ1dGVmb3JjZSI6dHJ1ZSwiYm9keUZTIjoiT2ZmIiwiYm9keVlhdyI6dHJ1ZSwiZGVsYXlfdGlja3MiOjQwLjAsImxlZnRMaW1pdCI6NjAuMCwibGVmdFlhd09mZnNldCI6LTE0LjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJyaWdodExpbWl0Ijo2MC4wLCJyaWdodFlhd09mZnNldCI6MTcuMCwieWF3T2Zmc2V0IjowLjAsInlhd1R5cGUiOiJsL3IiLCJ+YW50aUJydXRlZm9yY2UiOnsiYWJDdXN0b21QaGFzZUNvdW50Ijo3LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwxIjotMTguMCwiYWJDdXN0b21QaGFzZVZhbHVlTDIiOi0xMy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMyI6LTIyLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw0IjotMjMuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDUiOi0xMi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNiI6LTE4LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw3IjotMTUuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjEiOjE1LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIyIjoxNy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMyI6MjUuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjQiOjE4LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI1IjoxNi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNiI6MjMuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjciOjE4LjAsImFiQ3VzdG9tUmFuZG9taXplT3JkZXIiOnRydWUsImFudGlCcnV0ZWZvcmNlSW5kaWNhdGlvbiI6dHJ1ZSwiYW50aUJydXRlZm9yY2VNb2RlIjoiY3VzdG9tIiwiYW50aUJydXRlZm9yY2VSZXNldCI6dHJ1ZSwiYW50aUJydXRlZm9yY2VUeXBlIjoibC9yIGFkZHMifSwifmJvZHlZYXciOnsiZGVzeW5jT3B0aW9uIjoiRGVmYXVsdCIsInJvdGF0aW9uU3BlZWQiOjUwLjAsInNwZWVkT3B0aW9uIjoiQ29uc3RhbnQifSwifm1vZGlmaWVyIjp7ImFscGh2QmFzZURlbGF5IjowLjAsImFscGh2QmFzZUhvbGQiOjAuMCwiYWxwaHZGbGlja0NoYW5jZSI6NTAuMCwiYWxwaHZGbGlja0NoYW5jZVBlclBoYXNlIjozMC4wLCJhbHBodkZsaWNrTWF4IjowLjAsImFscGh2RmxpY2tNaW4iOjAuMCwiYWxwaHZGbGlja1JhbmdlUGVyUGhhc2UiOjkwLjAsImFscGh2UGhhc2VDb3VudCI6NC4wLCJhbHBodlBoYXNlU3BlZWQiOjgwLjAsImFscGh2UGhhc2VWYWx1ZTEiOi03LjAsImFscGh2UGhhc2VWYWx1ZTEwIjowLjAsImFscGh2UGhhc2VWYWx1ZTExIjowLjAsImFscGh2UGhhc2VWYWx1ZTEyIjowLjAsImFscGh2UGhhc2VWYWx1ZTIiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMyI6MC4wLCJhbHBodlBoYXNlVmFsdWU0IjowLjAsImFscGh2UGhhc2VWYWx1ZTUiOjAuMCwiYWxwaHZQaGFzZVZhbHVlNiI6MC4wLCJhbHBodlBoYXNlVmFsdWU3IjowLjAsImFscGh2UGhhc2VWYWx1ZTgiOjAuMCwiYWxwaHZQaGFzZVZhbHVlOSI6MC4wLCJhbHBodlJhbmRvbURlbGF5IjowLjAsImFscGh2UmFuZG9tSG9sZCI6MC4wLCJhbHBodlJhbmRvbWl6ZVBoYXNlT3JkZXIiOmZhbHNlLCJhbHBodlNwZWVkIjoxMDAuMCwiYnVyc3RDaGFuY2UiOjUwLjAsImJ1cnN0RHVyYXRpb24iOjEwLjAsImJ1cnN0TXVsdGlwbGllciI6MS4wLCJidXJzdFJhbmRvbUZhY3RvciI6MjAuMCwiY29uc3RhbnRKaXR0ZXIiOmZhbHNlLCJqaXR0ZXJNYWduaXR1ZGUiOjQ1LjAsImppdHRlclR5cGUiOiJSYW5kb20iLCJtYXhKaXR0ZXJEZWxheSI6MTUuMCwibWluSml0dGVyRGVsYXkiOjUuMCwibW9kSG9sZEN5Y2xlcyI6MC4wLCJtb2RIb2xkVGlja3MiOjAuMCwibW9kT2Zmc2V0IjowLjAsIm1vZFBoYXNlQ291bnQiOjEuMCwibW9kUGhhc2VTcGVlZCI6MS4wLCJtb2RQaGFzZVZhbHVlMSI6LTcuMCwibW9kUGhhc2VWYWx1ZTEwIjowLjAsIm1vZFBoYXNlVmFsdWUxMSI6MC4wLCJtb2RQaGFzZVZhbHVlMTIiOjAuMCwibW9kUGhhc2VWYWx1ZTIiOjAuMCwibW9kUGhhc2VWYWx1ZTMiOjAuMCwibW9kUGhhc2VWYWx1ZTQiOjAuMCwibW9kUGhhc2VWYWx1ZTUiOjAuMCwibW9kUGhhc2VWYWx1ZTYiOjAuMCwibW9kUGhhc2VWYWx1ZTciOjAuMCwibW9kUGhhc2VWYWx1ZTgiOjAuMCwibW9kUGhhc2VWYWx1ZTkiOjAuMCwibW9kUmFuZG9tIjowLjAsIm1vZFJhbmRvbURlbGF5IjowLjAsIm1vZFN3aXRjaERlbGF5IjowLjAsInJhbmRUeXBlIjoiZGVmYXVsdCIsInJhbmRvbWl6ZUppdHRlckRpcmVjdGlvbiI6ZmFsc2UsInJhbmRvbWl6ZUppdHRlck1hZ25pdHVkZSI6MC4wLCJyYW5kb21pemVSb3RhdGlvbk9yZGVyIjpmYWxzZSwic21vb3RoVHJhbnNpdGlvbiI6dHJ1ZSwic21vb3RoaW5nRmFjdG9yIjo1MC4wLCJ3YXZlQW1wbGl0dWRlIjo0NS4wLCJ3YXZlRm9ybSI6IlNpbmUiLCJ3YXZlRnJlcXVlbmN5IjoxLjAsIndhdmVPZmZzZXQiOjAuMH0sIn55YXdUeXBlIjp7ImJvbWJhQnVyc3RDaGFuY2UiOjM3LjAsImJvbWJhQnVyc3REdXJhdGlvbiI6MTM5LjAsImJvbWJhQnVyc3RFbmFibGUiOnRydWUsImJvbWJhQnVyc3RNdWx0aXBsaWVyIjoxMTAuMCwiYm9tYmFDaGFvc0ZhY3RvciI6MzQuMCwiYm9tYmFNYXhEZWxheSI6MTYuMCwiYm9tYmFNaW5EZWxheSI6NC4wLCJib21iYVJhbmRvbUZhY3RvciI6NTAuMCwiYm9tYmFTbW9vdGhuZXNzIjo3MC4wLCJkZWxheUhvbGRDeWNsZXMiOjAuMCwiZGVsYXlIb2xkVGlja3MiOjAuMCwiZGVsYXlQaGFzZUNvdW50IjoxMi4wLCJkZWxheVBoYXNlU3BlZWQiOjUwLjAsImRlbGF5UGhhc2VWYWx1ZTEiOjEyLjAsImRlbGF5UGhhc2VWYWx1ZTEwIjo4LjAsImRlbGF5UGhhc2VWYWx1ZTExIjoxOC4wLCJkZWxheVBoYXNlVmFsdWUxMiI6NS4wLCJkZWxheVBoYXNlVmFsdWUyIjo0LjAsImRlbGF5UGhhc2VWYWx1ZTMiOjUuMCwiZGVsYXlQaGFzZVZhbHVlNCI6MTEuMCwiZGVsYXlQaGFzZVZhbHVlNSI6MTQuMCwiZGVsYXlQaGFzZVZhbHVlNiI6Mi4wLCJkZWxheVBoYXNlVmFsdWU3IjoxMS4wLCJkZWxheVBoYXNlVmFsdWU4IjoxOC4wLCJkZWxheVBoYXNlVmFsdWU5Ijo0LjAsImRlbGF5UmFuZG9tRGVsYXlGb3JTd2l0Y2giOjAuMCwiZGVsYXlSYW5kb21Gcm9tIjozLjAsImRlbGF5UmFuZG9tU3BlZWQiOjUwLjAsImRlbGF5UmFuZG9tVG8iOjE4LjAsImRlbGF5UmFuZG9taXplUm90YXRpb25PcmRlciI6dHJ1ZSwiZGVsYXlTd2l0Y2hEZWxheSI6MC4wLCJkZWxheVR5cGUiOiJQaGFzZSIsImhhcm1vbmljQW1wbGl0dWRlIjoyMC4wLCJoYXJtb25pY0Jhc2VEZWxheSI6NTAuMCwiaGFybW9uaWNGcmVxdWVuY3kiOjUwLjAsImhhcm1vbmljUGhhc2VPZmZzZXQiOjAuMCwiaGFybW9uaWNXYXZlZm9ybSI6IlNpbmUifX0sImFpckNyb3VjaCI6eyJhbnRpQnJ1dGVmb3JjZSI6dHJ1ZSwiYm9keUZTIjoiT2ZmIiwiYm9keVlhdyI6dHJ1ZSwiZGVsYXlfdGlja3MiOjQwLjAsImxlZnRMaW1pdCI6NjAuMCwibGVmdFlhd09mZnNldCI6LTIyLjAsIm1vZGlmaWVyIjoiUmFuZG9tIiwicmlnaHRMaW1pdCI6NjAuMCwicmlnaHRZYXdPZmZzZXQiOjQ5LjAsInlhd09mZnNldCI6MC4wLCJ5YXdUeXBlIjoibC9yIiwifmFudGlCcnV0ZWZvcmNlIjp7ImFiQ3VzdG9tUGhhc2VDb3VudCI6Ny4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMSI6LTIzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwyIjotMjIuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDMiOi0yMS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNCI6LTI2LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw1IjotMjMuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDYiOi0xOS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNyI6LTI2LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIxIjo0NS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMiI6NDcuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjMiOjQ4LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI0Ijo1MS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNSI6MzUuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjYiOjM3LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI3IjozOS4wLCJhYkN1c3RvbVJhbmRvbWl6ZU9yZGVyIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZUluZGljYXRpb24iOnRydWUsImFudGlCcnV0ZWZvcmNlTW9kZSI6ImN1c3RvbSIsImFudGlCcnV0ZWZvcmNlUmVzZXQiOnRydWUsImFudGlCcnV0ZWZvcmNlVHlwZSI6ImwvciBhZGRzIn0sIn5ib2R5WWF3Ijp7ImRlc3luY09wdGlvbiI6IkRlZmF1bHQiLCJyb3RhdGlvblNwZWVkIjo1MC4wLCJzcGVlZE9wdGlvbiI6IkNvbnN0YW50In0sIn5tb2RpZmllciI6eyJhbHBodkJhc2VEZWxheSI6MTYuMCwiYWxwaHZCYXNlSG9sZCI6MS4wLCJhbHBodkZsaWNrQ2hhbmNlIjozMi4wLCJhbHBodkZsaWNrQ2hhbmNlUGVyUGhhc2UiOjg3LjAsImFscGh2RmxpY2tNYXgiOjExLjAsImFscGh2RmxpY2tNaW4iOi04LjAsImFscGh2RmxpY2tSYW5nZVBlclBoYXNlIjo1OS4wLCJhbHBodlBoYXNlQ291bnQiOjQuMCwiYWxwaHZQaGFzZVNwZWVkIjo4MC4wLCJhbHBodlBoYXNlVmFsdWUxIjotNDUuMCwiYWxwaHZQaGFzZVZhbHVlMTAiOi0zLjAsImFscGh2UGhhc2VWYWx1ZTExIjotMzAuMCwiYWxwaHZQaGFzZVZhbHVlMTIiOi0zNy4wLCJhbHBodlBoYXNlVmFsdWUyIjozOC4wLCJhbHBodlBoYXNlVmFsdWUzIjotMjUuMCwiYWxwaHZQaGFzZVZhbHVlNCI6LTM2LjAsImFscGh2UGhhc2VWYWx1ZTUiOi0zNi4wLCJhbHBodlBoYXNlVmFsdWU2Ijo0MC4wLCJhbHBodlBoYXNlVmFsdWU3IjotMjcuMCwiYWxwaHZQaGFzZVZhbHVlOCI6MTAuMCwiYWxwaHZQaGFzZVZhbHVlOSI6OC4wLCJhbHBodlJhbmRvbURlbGF5IjozLjAsImFscGh2UmFuZG9tSG9sZCI6MS4wLCJhbHBodlJhbmRvbWl6ZVBoYXNlT3JkZXIiOmZhbHNlLCJhbHBodlNwZWVkIjoxMDAuMCwiYnVyc3RDaGFuY2UiOjUwLjAsImJ1cnN0RHVyYXRpb24iOjE5LjAsImJ1cnN0TXVsdGlwbGllciI6Mi4wLCJidXJzdFJhbmRvbUZhY3RvciI6MTguMCwiY29uc3RhbnRKaXR0ZXIiOmZhbHNlLCJqaXR0ZXJNYWduaXR1ZGUiOi00MS4wLCJqaXR0ZXJUeXBlIjoiUmFuZG9tIiwibWF4Sml0dGVyRGVsYXkiOjE3LjAsIm1pbkppdHRlckRlbGF5IjoyLjAsIm1vZEhvbGRDeWNsZXMiOjEuMCwibW9kSG9sZFRpY2tzIjoxLjAsIm1vZE9mZnNldCI6LTIuMCwibW9kUGhhc2VDb3VudCI6MTIuMCwibW9kUGhhc2VTcGVlZCI6NTAuMCwibW9kUGhhc2VWYWx1ZTEiOi00NS4wLCJtb2RQaGFzZVZhbHVlMTAiOi0zLjAsIm1vZFBoYXNlVmFsdWUxMSI6LTMwLjAsIm1vZFBoYXNlVmFsdWUxMiI6LTM3LjAsIm1vZFBoYXNlVmFsdWUyIjozOC4wLCJtb2RQaGFzZVZhbHVlMyI6LTI1LjAsIm1vZFBoYXNlVmFsdWU0IjotMzYuMCwibW9kUGhhc2VWYWx1ZTUiOi0zNi4wLCJtb2RQaGFzZVZhbHVlNiI6NDAuMCwibW9kUGhhc2VWYWx1ZTciOi0yNy4wLCJtb2RQaGFzZVZhbHVlOCI6MTAuMCwibW9kUGhhc2VWYWx1ZTkiOjguMCwibW9kUmFuZG9tIjo2MS4wLCJtb2RSYW5kb21EZWxheSI6My4wLCJtb2RTd2l0Y2hEZWxheSI6MS4wLCJyYW5kVHlwZSI6ImRlbGF5IiwicmFuZG9taXplSml0dGVyRGlyZWN0aW9uIjp0cnVlLCJyYW5kb21pemVKaXR0ZXJNYWduaXR1ZGUiOjM1LjAsInJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOmZhbHNlLCJzbW9vdGhUcmFuc2l0aW9uIjp0cnVlLCJzbW9vdGhpbmdGYWN0b3IiOjUwLjAsIndhdmVBbXBsaXR1ZGUiOjExLjAsIndhdmVGb3JtIjoiU2luZSIsIndhdmVGcmVxdWVuY3kiOjEuMCwid2F2ZU9mZnNldCI6MjEuMH0sIn55YXdUeXBlIjp7ImJvbWJhQnVyc3RDaGFuY2UiOjQ0LjAsImJvbWJhQnVyc3REdXJhdGlvbiI6MjMyLjAsImJvbWJhQnVyc3RFbmFibGUiOnRydWUsImJvbWJhQnVyc3RNdWx0aXBsaWVyIjo3OS4wLCJib21iYUNoYW9zRmFjdG9yIjoyMy4wLCJib21iYU1heERlbGF5IjoxNC4wLCJib21iYU1pbkRlbGF5Ijo1LjAsImJvbWJhUmFuZG9tRmFjdG9yIjoyNy4wLCJib21iYVNtb290aG5lc3MiOjcwLjAsImRlbGF5SG9sZEN5Y2xlcyI6MS4wLCJkZWxheUhvbGRUaWNrcyI6MS4wLCJkZWxheVBoYXNlQ291bnQiOjEyLjAsImRlbGF5UGhhc2VTcGVlZCI6NTIuMCwiZGVsYXlQaGFzZVZhbHVlMSI6MTAuMCwiZGVsYXlQaGFzZVZhbHVlMTAiOjcuMCwiZGVsYXlQaGFzZVZhbHVlMTEiOjIuMCwiZGVsYXlQaGFzZVZhbHVlMTIiOjEyLjAsImRlbGF5UGhhc2VWYWx1ZTIiOjcuMCwiZGVsYXlQaGFzZVZhbHVlMyI6Ni4wLCJkZWxheVBoYXNlVmFsdWU0IjoxMi4wLCJkZWxheVBoYXNlVmFsdWU1IjoxMy4wLCJkZWxheVBoYXNlVmFsdWU2IjoxNi4wLCJkZWxheVBoYXNlVmFsdWU3IjoxMC4wLCJkZWxheVBoYXNlVmFsdWU4IjoxNS4wLCJkZWxheVBoYXNlVmFsdWU5IjoxMC4wLCJkZWxheVJhbmRvbURlbGF5Rm9yU3dpdGNoIjozLjAsImRlbGF5UmFuZG9tRnJvbSI6NS4wLCJkZWxheVJhbmRvbVNwZWVkIjo1Mi4wLCJkZWxheVJhbmRvbVRvIjoyNC4wLCJkZWxheVJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOnRydWUsImRlbGF5U3dpdGNoRGVsYXkiOjIuMCwiZGVsYXlUeXBlIjoiUmFuZG9tIiwiaGFybW9uaWNBbXBsaXR1ZGUiOjEzLjAsImhhcm1vbmljQmFzZURlbGF5IjoxMi4wLCJoYXJtb25pY0ZyZXF1ZW5jeSI6NTcuMCwiaGFybW9uaWNQaGFzZU9mZnNldCI6NTkuMCwiaGFybW9uaWNXYXZlZm9ybSI6IlNpbmUifX0sImNyb3VjaCI6eyJhbnRpQnJ1dGVmb3JjZSI6dHJ1ZSwiYm9keUZTIjoiT2ZmIiwiYm9keVlhdyI6dHJ1ZSwiZGVsYXlfdGlja3MiOjQwLjAsImxlZnRMaW1pdCI6NTYuMCwibGVmdFlhd09mZnNldCI6LTE3LjAsIm1vZGlmaWVyIjoiUmFuZG9tIiwicmlnaHRMaW1pdCI6NTYuMCwicmlnaHRZYXdPZmZzZXQiOjI1LjAsInlhd09mZnNldCI6MC4wLCJ5YXdUeXBlIjoibC9yIiwifmFudGlCcnV0ZWZvcmNlIjp7ImFiQ3VzdG9tUGhhc2VDb3VudCI6Ny4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMSI6LTIwLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwyIjotMjMuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDMiOi0xOS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNCI6LTI3LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw1IjotMjMuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDYiOi0xOC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNyI6LTI2LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIxIjoyNC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMiI6MTUuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjMiOjIxLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI0IjoyMy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNSI6MTkuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjYiOjE4LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI3IjoyNS4wLCJhYkN1c3RvbVJhbmRvbWl6ZU9yZGVyIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZUluZGljYXRpb24iOnRydWUsImFudGlCcnV0ZWZvcmNlTW9kZSI6ImN1c3RvbSIsImFudGlCcnV0ZWZvcmNlUmVzZXQiOnRydWUsImFudGlCcnV0ZWZvcmNlVHlwZSI6ImwvciBhZGRzIn0sIn5ib2R5WWF3Ijp7ImRlc3luY09wdGlvbiI6IkRlZmF1bHQiLCJyb3RhdGlvblNwZWVkIjo1MC4wLCJzcGVlZE9wdGlvbiI6IkNvbnN0YW50In0sIn5tb2RpZmllciI6eyJhbHBodkJhc2VEZWxheSI6MC4wLCJhbHBodkJhc2VIb2xkIjoxLjAsImFscGh2RmxpY2tDaGFuY2UiOjMyLjAsImFscGh2RmxpY2tDaGFuY2VQZXJQaGFzZSI6ODcuMCwiYWxwaHZGbGlja01heCI6MTEuMCwiYWxwaHZGbGlja01pbiI6LTguMCwiYWxwaHZGbGlja1JhbmdlUGVyUGhhc2UiOjU5LjAsImFscGh2UGhhc2VDb3VudCI6NC4wLCJhbHBodlBoYXNlU3BlZWQiOjgwLjAsImFscGh2UGhhc2VWYWx1ZTEiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMTAiOi0zLjAsImFscGh2UGhhc2VWYWx1ZTExIjotMzAuMCwiYWxwaHZQaGFzZVZhbHVlMTIiOi0zNy4wLCJhbHBodlBoYXNlVmFsdWUyIjowLjAsImFscGh2UGhhc2VWYWx1ZTMiOjE1LjAsImFscGh2UGhhc2VWYWx1ZTQiOi0xMy4wLCJhbHBodlBoYXNlVmFsdWU1Ijo3LjAsImFscGh2UGhhc2VWYWx1ZTYiOjEuMCwiYWxwaHZQaGFzZVZhbHVlNyI6LTI3LjAsImFscGh2UGhhc2VWYWx1ZTgiOjEwLjAsImFscGh2UGhhc2VWYWx1ZTkiOjguMCwiYWxwaHZSYW5kb21EZWxheSI6Mi4wLCJhbHBodlJhbmRvbUhvbGQiOjEuMCwiYWxwaHZSYW5kb21pemVQaGFzZU9yZGVyIjp0cnVlLCJhbHBodlNwZWVkIjoxMDAuMCwiYnVyc3RDaGFuY2UiOjUwLjAsImJ1cnN0RHVyYXRpb24iOjE5LjAsImJ1cnN0TXVsdGlwbGllciI6Mi4wLCJidXJzdFJhbmRvbUZhY3RvciI6MTguMCwiY29uc3RhbnRKaXR0ZXIiOmZhbHNlLCJqaXR0ZXJNYWduaXR1ZGUiOi00MS4wLCJqaXR0ZXJUeXBlIjoiUmFuZG9tIiwibWF4Sml0dGVyRGVsYXkiOjE3LjAsIm1pbkppdHRlckRlbGF5IjoyLjAsIm1vZEhvbGRDeWNsZXMiOjAuMCwibW9kSG9sZFRpY2tzIjoyLjAsIm1vZE9mZnNldCI6MjEuMCwibW9kUGhhc2VDb3VudCI6My4wLCJtb2RQaGFzZVNwZWVkIjo1MC4wLCJtb2RQaGFzZVZhbHVlMSI6MC4wLCJtb2RQaGFzZVZhbHVlMTAiOi0zLjAsIm1vZFBoYXNlVmFsdWUxMSI6LTMwLjAsIm1vZFBoYXNlVmFsdWUxMiI6LTM3LjAsIm1vZFBoYXNlVmFsdWUyIjowLjAsIm1vZFBoYXNlVmFsdWUzIjoxNS4wLCJtb2RQaGFzZVZhbHVlNCI6LTEzLjAsIm1vZFBoYXNlVmFsdWU1Ijo3LjAsIm1vZFBoYXNlVmFsdWU2IjoxLjAsIm1vZFBoYXNlVmFsdWU3IjotMjcuMCwibW9kUGhhc2VWYWx1ZTgiOjEwLjAsIm1vZFBoYXNlVmFsdWU5Ijo4LjAsIm1vZFJhbmRvbSI6NjEuMCwibW9kUmFuZG9tRGVsYXkiOjIuMCwibW9kU3dpdGNoRGVsYXkiOjEuMCwicmFuZFR5cGUiOiJkZWxheSIsInJhbmRvbWl6ZUppdHRlckRpcmVjdGlvbiI6dHJ1ZSwicmFuZG9taXplSml0dGVyTWFnbml0dWRlIjozNS4wLCJyYW5kb21pemVSb3RhdGlvbk9yZGVyIjpmYWxzZSwic21vb3RoVHJhbnNpdGlvbiI6dHJ1ZSwic21vb3RoaW5nRmFjdG9yIjo1MC4wLCJ3YXZlQW1wbGl0dWRlIjoxMS4wLCJ3YXZlRm9ybSI6IlNpbmUiLCJ3YXZlRnJlcXVlbmN5IjoxLjAsIndhdmVPZmZzZXQiOjIxLjB9LCJ+eWF3VHlwZSI6eyJib21iYUJ1cnN0Q2hhbmNlIjo0NC4wLCJib21iYUJ1cnN0RHVyYXRpb24iOjE4Ny4wLCJib21iYUJ1cnN0RW5hYmxlIjp0cnVlLCJib21iYUJ1cnN0TXVsdGlwbGllciI6ODMuMCwiYm9tYmFDaGFvc0ZhY3RvciI6NDUuMCwiYm9tYmFNYXhEZWxheSI6MTQuMCwiYm9tYmFNaW5EZWxheSI6NS4wLCJib21iYVJhbmRvbUZhY3RvciI6NjguMCwiYm9tYmFTbW9vdGhuZXNzIjo3MC4wLCJkZWxheUhvbGRDeWNsZXMiOjAuMCwiZGVsYXlIb2xkVGlja3MiOjAuMCwiZGVsYXlQaGFzZUNvdW50IjoxMi4wLCJkZWxheVBoYXNlU3BlZWQiOjI4LjAsImRlbGF5UGhhc2VWYWx1ZTEiOjE4LjAsImRlbGF5UGhhc2VWYWx1ZTEwIjoxMS4wLCJkZWxheVBoYXNlVmFsdWUxMSI6MTcuMCwiZGVsYXlQaGFzZVZhbHVlMTIiOjE0LjAsImRlbGF5UGhhc2VWYWx1ZTIiOjEzLjAsImRlbGF5UGhhc2VWYWx1ZTMiOjEzLjAsImRlbGF5UGhhc2VWYWx1ZTQiOjguMCwiZGVsYXlQaGFzZVZhbHVlNSI6Ny4wLCJkZWxheVBoYXNlVmFsdWU2IjoxMS4wLCJkZWxheVBoYXNlVmFsdWU3Ijo1LjAsImRlbGF5UGhhc2VWYWx1ZTgiOjExLjAsImRlbGF5UGhhc2VWYWx1ZTkiOjExLjAsImRlbGF5UmFuZG9tRGVsYXlGb3JTd2l0Y2giOjAuMCwiZGVsYXlSYW5kb21Gcm9tIjo0LjAsImRlbGF5UmFuZG9tU3BlZWQiOjI4LjAsImRlbGF5UmFuZG9tVG8iOjI1LjAsImRlbGF5UmFuZG9taXplUm90YXRpb25PcmRlciI6dHJ1ZSwiZGVsYXlTd2l0Y2hEZWxheSI6MC4wLCJkZWxheVR5cGUiOiJQaGFzZSIsImhhcm1vbmljQW1wbGl0dWRlIjoyNy4wLCJoYXJtb25pY0Jhc2VEZWxheSI6MTMuMCwiaGFybW9uaWNGcmVxdWVuY3kiOjExLjAsImhhcm1vbmljUGhhc2VPZmZzZXQiOjM4LjAsImhhcm1vbmljV2F2ZWZvcm0iOiJTaW5lIn19LCJydW4iOnsiYW50aUJydXRlZm9yY2UiOnRydWUsImJvZHlGUyI6Ik9mZiIsImJvZHlZYXciOnRydWUsImRlbGF5X3RpY2tzIjo0MC4wLCJsZWZ0TGltaXQiOjYwLjAsImxlZnRZYXdPZmZzZXQiOi0yNi4wLCJtb2RpZmllciI6IlJhbmRvbSIsInJpZ2h0TGltaXQiOjYwLjAsInJpZ2h0WWF3T2Zmc2V0Ijo0MS4wLCJ5YXdPZmZzZXQiOjAuMCwieWF3VHlwZSI6ImwvciIsIn5hbnRpQnJ1dGVmb3JjZSI6eyJhYkN1c3RvbVBoYXNlQ291bnQiOjcuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDEiOi0yNC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMiI6LTI1LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwzIjotMTcuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDQiOi0yNy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNSI6LTI4LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw2IjotMjMuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDciOi0yNi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMSI6MzkuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjIiOjQyLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIzIjozOC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNCI6NDMuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjUiOjQ0LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI2Ijo0MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNyI6MzcuMCwiYWJDdXN0b21SYW5kb21pemVPcmRlciI6dHJ1ZSwiYW50aUJydXRlZm9yY2VJbmRpY2F0aW9uIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZU1vZGUiOiJjdXN0b20iLCJhbnRpQnJ1dGVmb3JjZVJlc2V0Ijp0cnVlLCJhbnRpQnJ1dGVmb3JjZVR5cGUiOiJsL3IgYWRkcyJ9LCJ+Ym9keVlhdyI6eyJkZXN5bmNPcHRpb24iOiJEZWZhdWx0Iiwicm90YXRpb25TcGVlZCI6NTAuMCwic3BlZWRPcHRpb24iOiJDb25zdGFudCJ9LCJ+bW9kaWZpZXIiOnsiYWxwaHZCYXNlRGVsYXkiOjE2LjAsImFscGh2QmFzZUhvbGQiOjEuMCwiYWxwaHZGbGlja0NoYW5jZSI6MzIuMCwiYWxwaHZGbGlja0NoYW5jZVBlclBoYXNlIjo4Ny4wLCJhbHBodkZsaWNrTWF4IjoxMS4wLCJhbHBodkZsaWNrTWluIjotOC4wLCJhbHBodkZsaWNrUmFuZ2VQZXJQaGFzZSI6NTkuMCwiYWxwaHZQaGFzZUNvdW50Ijo0LjAsImFscGh2UGhhc2VTcGVlZCI6ODAuMCwiYWxwaHZQaGFzZVZhbHVlMSI6LTQ1LjAsImFscGh2UGhhc2VWYWx1ZTEwIjotMy4wLCJhbHBodlBoYXNlVmFsdWUxMSI6LTMwLjAsImFscGh2UGhhc2VWYWx1ZTEyIjotMzcuMCwiYWxwaHZQaGFzZVZhbHVlMiI6MzguMCwiYWxwaHZQaGFzZVZhbHVlMyI6LTI1LjAsImFscGh2UGhhc2VWYWx1ZTQiOi0zNi4wLCJhbHBodlBoYXNlVmFsdWU1IjotMzYuMCwiYWxwaHZQaGFzZVZhbHVlNiI6NDAuMCwiYWxwaHZQaGFzZVZhbHVlNyI6LTI3LjAsImFscGh2UGhhc2VWYWx1ZTgiOjEwLjAsImFscGh2UGhhc2VWYWx1ZTkiOjguMCwiYWxwaHZSYW5kb21EZWxheSI6My4wLCJhbHBodlJhbmRvbUhvbGQiOjEuMCwiYWxwaHZSYW5kb21pemVQaGFzZU9yZGVyIjpmYWxzZSwiYWxwaHZTcGVlZCI6MTAwLjAsImJ1cnN0Q2hhbmNlIjo1MC4wLCJidXJzdER1cmF0aW9uIjoxOS4wLCJidXJzdE11bHRpcGxpZXIiOjIuMCwiYnVyc3RSYW5kb21GYWN0b3IiOjE4LjAsImNvbnN0YW50Sml0dGVyIjpmYWxzZSwiaml0dGVyTWFnbml0dWRlIjotNDEuMCwiaml0dGVyVHlwZSI6IlJhbmRvbSIsIm1heEppdHRlckRlbGF5IjoxNy4wLCJtaW5KaXR0ZXJEZWxheSI6Mi4wLCJtb2RIb2xkQ3ljbGVzIjoxLjAsIm1vZEhvbGRUaWNrcyI6MS4wLCJtb2RPZmZzZXQiOi0yLjAsIm1vZFBoYXNlQ291bnQiOjEyLjAsIm1vZFBoYXNlU3BlZWQiOjUwLjAsIm1vZFBoYXNlVmFsdWUxIjotNDUuMCwibW9kUGhhc2VWYWx1ZTEwIjotMy4wLCJtb2RQaGFzZVZhbHVlMTEiOi0zMC4wLCJtb2RQaGFzZVZhbHVlMTIiOi0zNy4wLCJtb2RQaGFzZVZhbHVlMiI6MzguMCwibW9kUGhhc2VWYWx1ZTMiOi0yNS4wLCJtb2RQaGFzZVZhbHVlNCI6LTM2LjAsIm1vZFBoYXNlVmFsdWU1IjotMzYuMCwibW9kUGhhc2VWYWx1ZTYiOjQwLjAsIm1vZFBoYXNlVmFsdWU3IjotMjcuMCwibW9kUGhhc2VWYWx1ZTgiOjEwLjAsIm1vZFBoYXNlVmFsdWU5Ijo4LjAsIm1vZFJhbmRvbSI6NjEuMCwibW9kUmFuZG9tRGVsYXkiOjMuMCwibW9kU3dpdGNoRGVsYXkiOjEuMCwicmFuZFR5cGUiOiJkZWxheSIsInJhbmRvbWl6ZUppdHRlckRpcmVjdGlvbiI6dHJ1ZSwicmFuZG9taXplSml0dGVyTWFnbml0dWRlIjozNS4wLCJyYW5kb21pemVSb3RhdGlvbk9yZGVyIjpmYWxzZSwic21vb3RoVHJhbnNpdGlvbiI6dHJ1ZSwic21vb3RoaW5nRmFjdG9yIjo1MC4wLCJ3YXZlQW1wbGl0dWRlIjoxMS4wLCJ3YXZlRm9ybSI6IlNpbmUiLCJ3YXZlRnJlcXVlbmN5IjoxLjAsIndhdmVPZmZzZXQiOjIxLjB9LCJ+eWF3VHlwZSI6eyJib21iYUJ1cnN0Q2hhbmNlIjo0NC4wLCJib21iYUJ1cnN0RHVyYXRpb24iOjIzMi4wLCJib21iYUJ1cnN0RW5hYmxlIjp0cnVlLCJib21iYUJ1cnN0TXVsdGlwbGllciI6NzkuMCwiYm9tYmFDaGFvc0ZhY3RvciI6MjMuMCwiYm9tYmFNYXhEZWxheSI6MTQuMCwiYm9tYmFNaW5EZWxheSI6NS4wLCJib21iYVJhbmRvbUZhY3RvciI6MjcuMCwiYm9tYmFTbW9vdGhuZXNzIjo3MC4wLCJkZWxheUhvbGRDeWNsZXMiOjAuMCwiZGVsYXlIb2xkVGlja3MiOjAuMCwiZGVsYXlQaGFzZUNvdW50IjoxMi4wLCJkZWxheVBoYXNlU3BlZWQiOjI4LjAsImRlbGF5UGhhc2VWYWx1ZTEiOjEwLjAsImRlbGF5UGhhc2VWYWx1ZTEwIjo3LjAsImRlbGF5UGhhc2VWYWx1ZTExIjoyLjAsImRlbGF5UGhhc2VWYWx1ZTEyIjoxMi4wLCJkZWxheVBoYXNlVmFsdWUyIjo3LjAsImRlbGF5UGhhc2VWYWx1ZTMiOjYuMCwiZGVsYXlQaGFzZVZhbHVlNCI6MTIuMCwiZGVsYXlQaGFzZVZhbHVlNSI6MTMuMCwiZGVsYXlQaGFzZVZhbHVlNiI6MTYuMCwiZGVsYXlQaGFzZVZhbHVlNyI6MTAuMCwiZGVsYXlQaGFzZVZhbHVlOCI6MTUuMCwiZGVsYXlQaGFzZVZhbHVlOSI6MTAuMCwiZGVsYXlSYW5kb21EZWxheUZvclN3aXRjaCI6MC4wLCJkZWxheVJhbmRvbUZyb20iOjQuMCwiZGVsYXlSYW5kb21TcGVlZCI6MjguMCwiZGVsYXlSYW5kb21UbyI6MjUuMCwiZGVsYXlSYW5kb21pemVSb3RhdGlvbk9yZGVyIjp0cnVlLCJkZWxheVN3aXRjaERlbGF5IjowLjAsImRlbGF5VHlwZSI6Ikhhcm1vbmljIFBhdHRlcm4iLCJoYXJtb25pY0FtcGxpdHVkZSI6MTMuMCwiaGFybW9uaWNCYXNlRGVsYXkiOjEzLjAsImhhcm1vbmljRnJlcXVlbmN5Ijo1Ny4wLCJoYXJtb25pY1BoYXNlT2Zmc2V0IjozOC4wLCJoYXJtb25pY1dhdmVmb3JtIjoiU2luZSJ9fSwic2xvdyI6eyJhbnRpQnJ1dGVmb3JjZSI6dHJ1ZSwiYm9keUZTIjoiT2ZmIiwiYm9keVlhdyI6dHJ1ZSwiZGVsYXlfdGlja3MiOjQwLjAsImxlZnRMaW1pdCI6NjAuMCwibGVmdFlhd09mZnNldCI6LTE3LjAsIm1vZGlmaWVyIjoiUmFuZG9tIiwicmlnaHRMaW1pdCI6NjAuMCwicmlnaHRZYXdPZmZzZXQiOjI3LjAsInlhd09mZnNldCI6MC4wLCJ5YXdUeXBlIjoibC9yIiwifmFudGlCcnV0ZWZvcmNlIjp7ImFiQ3VzdG9tUGhhc2VDb3VudCI6MS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMSI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMiI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMyI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNCI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNSI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNiI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNyI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMSI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMiI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMyI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNCI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNSI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNiI6MC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNyI6MC4wLCJhYkN1c3RvbVJhbmRvbWl6ZU9yZGVyIjpmYWxzZSwiYW50aUJydXRlZm9yY2VJbmRpY2F0aW9uIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZU1vZGUiOiJwcmUtbWFkZSBbc2hkd10iLCJhbnRpQnJ1dGVmb3JjZVJlc2V0Ijp0cnVlLCJhbnRpQnJ1dGVmb3JjZVR5cGUiOiJsL3IgYWRkcyJ9LCJ+Ym9keVlhdyI6eyJkZXN5bmNPcHRpb24iOiJEZWZhdWx0Iiwicm90YXRpb25TcGVlZCI6NTAuMCwic3BlZWRPcHRpb24iOiJDb25zdGFudCJ9LCJ+bW9kaWZpZXIiOnsiYWxwaHZCYXNlRGVsYXkiOjAuMCwiYWxwaHZCYXNlSG9sZCI6MC4wLCJhbHBodkZsaWNrQ2hhbmNlIjo1MC4wLCJhbHBodkZsaWNrQ2hhbmNlUGVyUGhhc2UiOjMwLjAsImFscGh2RmxpY2tNYXgiOjAuMCwiYWxwaHZGbGlja01pbiI6MC4wLCJhbHBodkZsaWNrUmFuZ2VQZXJQaGFzZSI6OTAuMCwiYWxwaHZQaGFzZUNvdW50Ijo0LjAsImFscGh2UGhhc2VTcGVlZCI6ODAuMCwiYWxwaHZQaGFzZVZhbHVlMSI6MC4wLCJhbHBodlBoYXNlVmFsdWUxMCI6MC4wLCJhbHBodlBoYXNlVmFsdWUxMSI6MC4wLCJhbHBodlBoYXNlVmFsdWUxMiI6MC4wLCJhbHBodlBoYXNlVmFsdWUyIjowLjAsImFscGh2UGhhc2VWYWx1ZTMiOjAuMCwiYWxwaHZQaGFzZVZhbHVlNCI6MC4wLCJhbHBodlBoYXNlVmFsdWU1IjowLjAsImFscGh2UGhhc2VWYWx1ZTYiOjAuMCwiYWxwaHZQaGFzZVZhbHVlNyI6MC4wLCJhbHBodlBoYXNlVmFsdWU4IjowLjAsImFscGh2UGhhc2VWYWx1ZTkiOjAuMCwiYWxwaHZSYW5kb21EZWxheSI6My4wLCJhbHBodlJhbmRvbUhvbGQiOjAuMCwiYWxwaHZSYW5kb21pemVQaGFzZU9yZGVyIjpmYWxzZSwiYWxwaHZTcGVlZCI6MTAwLjAsImJ1cnN0Q2hhbmNlIjo1MC4wLCJidXJzdER1cmF0aW9uIjoxMC4wLCJidXJzdE11bHRpcGxpZXIiOjEuMCwiYnVyc3RSYW5kb21GYWN0b3IiOjIwLjAsImNvbnN0YW50Sml0dGVyIjpmYWxzZSwiaml0dGVyTWFnbml0dWRlIjoxMC4wLCJqaXR0ZXJUeXBlIjoiV2F2ZSIsIm1heEppdHRlckRlbGF5IjoxNS4wLCJtaW5KaXR0ZXJEZWxheSI6NS4wLCJtb2RIb2xkQ3ljbGVzIjoxLjAsIm1vZEhvbGRUaWNrcyI6MS4wLCJtb2RPZmZzZXQiOi0zNy4wLCJtb2RQaGFzZUNvdW50IjoxLjAsIm1vZFBoYXNlU3BlZWQiOjUwLjAsIm1vZFBoYXNlVmFsdWUxIjowLjAsIm1vZFBoYXNlVmFsdWUxMCI6MC4wLCJtb2RQaGFzZVZhbHVlMTEiOjAuMCwibW9kUGhhc2VWYWx1ZTEyIjowLjAsIm1vZFBoYXNlVmFsdWUyIjowLjAsIm1vZFBoYXNlVmFsdWUzIjowLjAsIm1vZFBoYXNlVmFsdWU0IjowLjAsIm1vZFBoYXNlVmFsdWU1IjowLjAsIm1vZFBoYXNlVmFsdWU2IjowLjAsIm1vZFBoYXNlVmFsdWU3IjowLjAsIm1vZFBoYXNlVmFsdWU4IjowLjAsIm1vZFBoYXNlVmFsdWU5IjowLjAsIm1vZFJhbmRvbSI6NzEuMCwibW9kUmFuZG9tRGVsYXkiOjMuMCwibW9kU3dpdGNoRGVsYXkiOjIuMCwicmFuZFR5cGUiOiJkZWxheSIsInJhbmRvbWl6ZUppdHRlckRpcmVjdGlvbiI6ZmFsc2UsInJhbmRvbWl6ZUppdHRlck1hZ25pdHVkZSI6MC4wLCJyYW5kb21pemVSb3RhdGlvbk9yZGVyIjpmYWxzZSwic21vb3RoVHJhbnNpdGlvbiI6dHJ1ZSwic21vb3RoaW5nRmFjdG9yIjo1MC4wLCJ3YXZlQW1wbGl0dWRlIjo0NS4wLCJ3YXZlRm9ybSI6IlNpbmUiLCJ3YXZlRnJlcXVlbmN5IjoxLjAsIndhdmVPZmZzZXQiOjAuMH0sIn55YXdUeXBlIjp7ImJvbWJhQnVyc3RDaGFuY2UiOjc3LjAsImJvbWJhQnVyc3REdXJhdGlvbiI6MTAwLjAsImJvbWJhQnVyc3RFbmFibGUiOnRydWUsImJvbWJhQnVyc3RNdWx0aXBsaWVyIjozMjguMCwiYm9tYmFDaGFvc0ZhY3RvciI6NjYuMCwiYm9tYmFNYXhEZWxheSI6MTcuMCwiYm9tYmFNaW5EZWxheSI6NS4wLCJib21iYVJhbmRvbUZhY3RvciI6NTAuMCwiYm9tYmFTbW9vdGhuZXNzIjo3MC4wLCJkZWxheUhvbGRDeWNsZXMiOjEuMCwiZGVsYXlIb2xkVGlja3MiOjEuMCwiZGVsYXlQaGFzZUNvdW50IjoxLjAsImRlbGF5UGhhc2VTcGVlZCI6NTAuMCwiZGVsYXlQaGFzZVZhbHVlMSI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlMTAiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTExIjo0MC4wLCJkZWxheVBoYXNlVmFsdWUxMiI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlMiI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlMyI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlNCI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlNSI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlNiI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlNyI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlOCI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlOSI6NDAuMCwiZGVsYXlSYW5kb21EZWxheUZvclN3aXRjaCI6MjEuMCwiZGVsYXlSYW5kb21Gcm9tIjo2LjAsImRlbGF5UmFuZG9tU3BlZWQiOjUwLjAsImRlbGF5UmFuZG9tVG8iOjI1LjAsImRlbGF5UmFuZG9taXplUm90YXRpb25PcmRlciI6ZmFsc2UsImRlbGF5U3dpdGNoRGVsYXkiOjMuMCwiZGVsYXlUeXBlIjoiU3dpdGNoIiwiaGFybW9uaWNBbXBsaXR1ZGUiOjIwLjAsImhhcm1vbmljQmFzZURlbGF5Ijo1MC4wLCJoYXJtb25pY0ZyZXF1ZW5jeSI6NTAuMCwiaGFybW9uaWNQaGFzZU9mZnNldCI6MC4wLCJoYXJtb25pY1dhdmVmb3JtIjoiU2luZSJ9fSwic25lYWsiOnsiYW50aUJydXRlZm9yY2UiOnRydWUsImJvZHlGUyI6Ik9mZiIsImJvZHlZYXciOnRydWUsImRlbGF5X3RpY2tzIjo0MC4wLCJsZWZ0TGltaXQiOjYwLjAsImxlZnRZYXdPZmZzZXQiOi0yMy4wLCJtb2RpZmllciI6IlJhbmRvbSIsInJpZ2h0TGltaXQiOjYwLjAsInJpZ2h0WWF3T2Zmc2V0IjoyNy4wLCJ5YXdPZmZzZXQiOjAuMCwieWF3VHlwZSI6ImwvciIsIn5hbnRpQnJ1dGVmb3JjZSI6eyJhYkN1c3RvbVBoYXNlQ291bnQiOjcuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDEiOi0yNS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMiI6LTI0LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwzIjotMTkuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDQiOi0yNy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNSI6LTIzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw2IjotMTguMCwiYWJDdXN0b21QaGFzZVZhbHVlTDciOi0yNi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMSI6MjguMCwiYWJDdXN0b21QaGFzZVZhbHVlUjIiOjI2LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIzIjoyNS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNCI6MjQuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjUiOjI5LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI2IjoyNy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNyI6MjUuMCwiYWJDdXN0b21SYW5kb21pemVPcmRlciI6dHJ1ZSwiYW50aUJydXRlZm9yY2VJbmRpY2F0aW9uIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZU1vZGUiOiJjdXN0b20iLCJhbnRpQnJ1dGVmb3JjZVJlc2V0Ijp0cnVlLCJhbnRpQnJ1dGVmb3JjZVR5cGUiOiJsL3IgYWRkcyJ9LCJ+Ym9keVlhdyI6eyJkZXN5bmNPcHRpb24iOiJEZWZhdWx0Iiwicm90YXRpb25TcGVlZCI6NTAuMCwic3BlZWRPcHRpb24iOiJDb25zdGFudCJ9LCJ+bW9kaWZpZXIiOnsiYWxwaHZCYXNlRGVsYXkiOjE2LjAsImFscGh2QmFzZUhvbGQiOjEuMCwiYWxwaHZGbGlja0NoYW5jZSI6MzIuMCwiYWxwaHZGbGlja0NoYW5jZVBlclBoYXNlIjo4Ny4wLCJhbHBodkZsaWNrTWF4IjoxMS4wLCJhbHBodkZsaWNrTWluIjotOC4wLCJhbHBodkZsaWNrUmFuZ2VQZXJQaGFzZSI6NTkuMCwiYWxwaHZQaGFzZUNvdW50Ijo0LjAsImFscGh2UGhhc2VTcGVlZCI6ODAuMCwiYWxwaHZQaGFzZVZhbHVlMSI6LTIwLjAsImFscGh2UGhhc2VWYWx1ZTEwIjotMy4wLCJhbHBodlBoYXNlVmFsdWUxMSI6LTMwLjAsImFscGh2UGhhc2VWYWx1ZTEyIjotMzcuMCwiYWxwaHZQaGFzZVZhbHVlMiI6LTEzLjAsImFscGh2UGhhc2VWYWx1ZTMiOi03LjAsImFscGh2UGhhc2VWYWx1ZTQiOi0xMy4wLCJhbHBodlBoYXNlVmFsdWU1Ijo3LjAsImFscGh2UGhhc2VWYWx1ZTYiOjEuMCwiYWxwaHZQaGFzZVZhbHVlNyI6LTI3LjAsImFscGh2UGhhc2VWYWx1ZTgiOjEwLjAsImFscGh2UGhhc2VWYWx1ZTkiOjguMCwiYWxwaHZSYW5kb21EZWxheSI6MC4wLCJhbHBodlJhbmRvbUhvbGQiOjEuMCwiYWxwaHZSYW5kb21pemVQaGFzZU9yZGVyIjpmYWxzZSwiYWxwaHZTcGVlZCI6MTAwLjAsImJ1cnN0Q2hhbmNlIjo1MC4wLCJidXJzdER1cmF0aW9uIjoxOS4wLCJidXJzdE11bHRpcGxpZXIiOjIuMCwiYnVyc3RSYW5kb21GYWN0b3IiOjE4LjAsImNvbnN0YW50Sml0dGVyIjpmYWxzZSwiaml0dGVyTWFnbml0dWRlIjotNDEuMCwiaml0dGVyVHlwZSI6IlJhbmRvbSIsIm1heEppdHRlckRlbGF5IjoxNy4wLCJtaW5KaXR0ZXJEZWxheSI6Mi4wLCJtb2RIb2xkQ3ljbGVzIjowLjAsIm1vZEhvbGRUaWNrcyI6MS4wLCJtb2RPZmZzZXQiOjExLjAsIm1vZFBoYXNlQ291bnQiOjcuMCwibW9kUGhhc2VTcGVlZCI6MjUuMCwibW9kUGhhc2VWYWx1ZTEiOi0yMC4wLCJtb2RQaGFzZVZhbHVlMTAiOi0zLjAsIm1vZFBoYXNlVmFsdWUxMSI6LTMwLjAsIm1vZFBoYXNlVmFsdWUxMiI6LTM3LjAsIm1vZFBoYXNlVmFsdWUyIjotMTMuMCwibW9kUGhhc2VWYWx1ZTMiOi03LjAsIm1vZFBoYXNlVmFsdWU0IjotMTMuMCwibW9kUGhhc2VWYWx1ZTUiOjcuMCwibW9kUGhhc2VWYWx1ZTYiOjEuMCwibW9kUGhhc2VWYWx1ZTciOi0yNy4wLCJtb2RQaGFzZVZhbHVlOCI6MTAuMCwibW9kUGhhc2VWYWx1ZTkiOjguMCwibW9kUmFuZG9tIjo2MS4wLCJtb2RSYW5kb21EZWxheSI6MC4wLCJtb2RTd2l0Y2hEZWxheSI6MS4wLCJyYW5kVHlwZSI6ImRlbGF5IiwicmFuZG9taXplSml0dGVyRGlyZWN0aW9uIjp0cnVlLCJyYW5kb21pemVKaXR0ZXJNYWduaXR1ZGUiOjM1LjAsInJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOmZhbHNlLCJzbW9vdGhUcmFuc2l0aW9uIjp0cnVlLCJzbW9vdGhpbmdGYWN0b3IiOjUwLjAsIndhdmVBbXBsaXR1ZGUiOjExLjAsIndhdmVGb3JtIjoiU2luZSIsIndhdmVGcmVxdWVuY3kiOjEuMCwid2F2ZU9mZnNldCI6MjEuMH0sIn55YXdUeXBlIjp7ImJvbWJhQnVyc3RDaGFuY2UiOjQ0LjAsImJvbWJhQnVyc3REdXJhdGlvbiI6MTI5LjAsImJvbWJhQnVyc3RFbmFibGUiOnRydWUsImJvbWJhQnVyc3RNdWx0aXBsaWVyIjo5MS4wLCJib21iYUNoYW9zRmFjdG9yIjo0MC4wLCJib21iYU1heERlbGF5Ijo3LjAsImJvbWJhTWluRGVsYXkiOjIuMCwiYm9tYmFSYW5kb21GYWN0b3IiOjY1LjAsImJvbWJhU21vb3RobmVzcyI6NzAuMCwiZGVsYXlIb2xkQ3ljbGVzIjowLjAsImRlbGF5SG9sZFRpY2tzIjowLjAsImRlbGF5UGhhc2VDb3VudCI6MTIuMCwiZGVsYXlQaGFzZVNwZWVkIjoyOC4wLCJkZWxheVBoYXNlVmFsdWUxIjoxMC4wLCJkZWxheVBoYXNlVmFsdWUxMCI6Ny4wLCJkZWxheVBoYXNlVmFsdWUxMSI6Mi4wLCJkZWxheVBoYXNlVmFsdWUxMiI6MTIuMCwiZGVsYXlQaGFzZVZhbHVlMiI6Ny4wLCJkZWxheVBoYXNlVmFsdWUzIjo2LjAsImRlbGF5UGhhc2VWYWx1ZTQiOjEyLjAsImRlbGF5UGhhc2VWYWx1ZTUiOjEzLjAsImRlbGF5UGhhc2VWYWx1ZTYiOjE2LjAsImRlbGF5UGhhc2VWYWx1ZTciOjEwLjAsImRlbGF5UGhhc2VWYWx1ZTgiOjE1LjAsImRlbGF5UGhhc2VWYWx1ZTkiOjEwLjAsImRlbGF5UmFuZG9tRGVsYXlGb3JTd2l0Y2giOjAuMCwiZGVsYXlSYW5kb21Gcm9tIjo0LjAsImRlbGF5UmFuZG9tU3BlZWQiOjI4LjAsImRlbGF5UmFuZG9tVG8iOjI1LjAsImRlbGF5UmFuZG9taXplUm90YXRpb25PcmRlciI6dHJ1ZSwiZGVsYXlTd2l0Y2hEZWxheSI6MC4wLCJkZWxheVR5cGUiOiJQaGFzZSIsImhhcm1vbmljQW1wbGl0dWRlIjoyNy4wLCJoYXJtb25pY0Jhc2VEZWxheSI6MTMuMCwiaGFybW9uaWNGcmVxdWVuY3kiOjExLjAsImhhcm1vbmljUGhhc2VPZmZzZXQiOjM4LjAsImhhcm1vbmljV2F2ZWZvcm0iOiJTaW5lIn19LCJzdGFuZCI6eyJhbnRpQnJ1dGVmb3JjZSI6dHJ1ZSwiYm9keUZTIjoiT2ZmIiwiYm9keVlhdyI6dHJ1ZSwiZGVsYXlfdGlja3MiOjQwLjAsImxlZnRMaW1pdCI6NTguMCwibGVmdFlhd09mZnNldCI6LTE2LjAsIm1vZGlmaWVyIjoiUmFuZG9tIiwicmlnaHRMaW1pdCI6NTguMCwicmlnaHRZYXdPZmZzZXQiOjI1LjAsInlhd09mZnNldCI6MC4wLCJ5YXdUeXBlIjoibC9yIiwifmFudGlCcnV0ZWZvcmNlIjp7ImFiQ3VzdG9tUGhhc2VDb3VudCI6Ny4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMSI6LTkuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDIiOi0xNS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMyI6LTEzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw0IjoxNC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNSI6LTEyLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw2IjotMTAuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDciOi03LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIxIjoxMi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMiI6MTYuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjMiOjExLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI0IjoxNS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNSI6MTcuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjYiOjEyLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI3Ijo5LjAsImFiQ3VzdG9tUmFuZG9taXplT3JkZXIiOnRydWUsImFudGlCcnV0ZWZvcmNlSW5kaWNhdGlvbiI6dHJ1ZSwiYW50aUJydXRlZm9yY2VNb2RlIjoiY3VzdG9tIiwiYW50aUJydXRlZm9yY2VSZXNldCI6dHJ1ZSwiYW50aUJydXRlZm9yY2VUeXBlIjoibC9yIGFkZHMifSwifmJvZHlZYXciOnsiZGVzeW5jT3B0aW9uIjoiRGVmYXVsdCIsInJvdGF0aW9uU3BlZWQiOjUwLjAsInNwZWVkT3B0aW9uIjoiQ29uc3RhbnQifSwifm1vZGlmaWVyIjp7ImFscGh2QmFzZURlbGF5IjozLjAsImFscGh2QmFzZUhvbGQiOjEuMCwiYWxwaHZGbGlja0NoYW5jZSI6My4wLCJhbHBodkZsaWNrQ2hhbmNlUGVyUGhhc2UiOjEwMC4wLCJhbHBodkZsaWNrTWF4Ijo0Mi4wLCJhbHBodkZsaWNrTWluIjotNDguMCwiYWxwaHZGbGlja1JhbmdlUGVyUGhhc2UiOjE0LjAsImFscGh2UGhhc2VDb3VudCI6MTIuMCwiYWxwaHZQaGFzZVNwZWVkIjoxMDAuMCwiYWxwaHZQaGFzZVZhbHVlMSI6NDEuMCwiYWxwaHZQaGFzZVZhbHVlMTAiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMTEiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMTIiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMiI6MTAuMCwiYWxwaHZQaGFzZVZhbHVlMyI6MjUuMCwiYWxwaHZQaGFzZVZhbHVlNCI6MzguMCwiYWxwaHZQaGFzZVZhbHVlNSI6LTQxLjAsImFscGh2UGhhc2VWYWx1ZTYiOjQ0LjAsImFscGh2UGhhc2VWYWx1ZTciOjQ5LjAsImFscGh2UGhhc2VWYWx1ZTgiOi02LjAsImFscGh2UGhhc2VWYWx1ZTkiOjEyLjAsImFscGh2UmFuZG9tRGVsYXkiOjMuMCwiYWxwaHZSYW5kb21Ib2xkIjoyLjAsImFscGh2UmFuZG9taXplUGhhc2VPcmRlciI6ZmFsc2UsImFscGh2U3BlZWQiOjEwMC4wLCJidXJzdENoYW5jZSI6NTAuMCwiYnVyc3REdXJhdGlvbiI6MTAuMCwiYnVyc3RNdWx0aXBsaWVyIjoxLjAsImJ1cnN0UmFuZG9tRmFjdG9yIjoyMC4wLCJjb25zdGFudEppdHRlciI6ZmFsc2UsImppdHRlck1hZ25pdHVkZSI6NDUuMCwiaml0dGVyVHlwZSI6IlJhbmRvbSIsIm1heEppdHRlckRlbGF5IjoxNS4wLCJtaW5KaXR0ZXJEZWxheSI6NS4wLCJtb2RIb2xkQ3ljbGVzIjowLjAsIm1vZEhvbGRUaWNrcyI6MS4wLCJtb2RPZmZzZXQiOi0xOS4wLCJtb2RQaGFzZUNvdW50Ijo5LjAsIm1vZFBoYXNlU3BlZWQiOjEwMC4wLCJtb2RQaGFzZVZhbHVlMSI6NDEuMCwibW9kUGhhc2VWYWx1ZTEwIjowLjAsIm1vZFBoYXNlVmFsdWUxMSI6MC4wLCJtb2RQaGFzZVZhbHVlMTIiOjAuMCwibW9kUGhhc2VWYWx1ZTIiOjEwLjAsIm1vZFBoYXNlVmFsdWUzIjoyNS4wLCJtb2RQaGFzZVZhbHVlNCI6MzguMCwibW9kUGhhc2VWYWx1ZTUiOi00MS4wLCJtb2RQaGFzZVZhbHVlNiI6NDQuMCwibW9kUGhhc2VWYWx1ZTciOjQ5LjAsIm1vZFBoYXNlVmFsdWU4IjotNi4wLCJtb2RQaGFzZVZhbHVlOSI6MTIuMCwibW9kUmFuZG9tIjowLjAsIm1vZFJhbmRvbURlbGF5IjozLjAsIm1vZFN3aXRjaERlbGF5IjoxLjAsInJhbmRUeXBlIjoiZGVsYXkiLCJyYW5kb21pemVKaXR0ZXJEaXJlY3Rpb24iOmZhbHNlLCJyYW5kb21pemVKaXR0ZXJNYWduaXR1ZGUiOjAuMCwicmFuZG9taXplUm90YXRpb25PcmRlciI6dHJ1ZSwic21vb3RoVHJhbnNpdGlvbiI6dHJ1ZSwic21vb3RoaW5nRmFjdG9yIjo1MC4wLCJ3YXZlQW1wbGl0dWRlIjo0NS4wLCJ3YXZlRm9ybSI6IlNpbmUiLCJ3YXZlRnJlcXVlbmN5IjoxLjAsIndhdmVPZmZzZXQiOjAuMH0sIn55YXdUeXBlIjp7ImJvbWJhQnVyc3RDaGFuY2UiOjE2LjAsImJvbWJhQnVyc3REdXJhdGlvbiI6MTgwLjAsImJvbWJhQnVyc3RFbmFibGUiOnRydWUsImJvbWJhQnVyc3RNdWx0aXBsaWVyIjo5Mi4wLCJib21iYUNoYW9zRmFjdG9yIjo5NS4wLCJib21iYU1heERlbGF5IjoxMi4wLCJib21iYU1pbkRlbGF5IjoxLjAsImJvbWJhUmFuZG9tRmFjdG9yIjo3My4wLCJib21iYVNtb290aG5lc3MiOjU0LjAsImRlbGF5SG9sZEN5Y2xlcyI6MC4wLCJkZWxheUhvbGRUaWNrcyI6MC4wLCJkZWxheVBoYXNlQ291bnQiOjExLjAsImRlbGF5UGhhc2VTcGVlZCI6NTQuMCwiZGVsYXlQaGFzZVZhbHVlMSI6OC4wLCJkZWxheVBoYXNlVmFsdWUxMCI6MTMuMCwiZGVsYXlQaGFzZVZhbHVlMTEiOjEzLjAsImRlbGF5UGhhc2VWYWx1ZTEyIjo0MC4wLCJkZWxheVBoYXNlVmFsdWUyIjo1LjAsImRlbGF5UGhhc2VWYWx1ZTMiOjIuMCwiZGVsYXlQaGFzZVZhbHVlNCI6MTUuMCwiZGVsYXlQaGFzZVZhbHVlNSI6MTYuMCwiZGVsYXlQaGFzZVZhbHVlNiI6MTAuMCwiZGVsYXlQaGFzZVZhbHVlNyI6MTIuMCwiZGVsYXlQaGFzZVZhbHVlOCI6NC4wLCJkZWxheVBoYXNlVmFsdWU5IjoxNy4wLCJkZWxheVJhbmRvbURlbGF5Rm9yU3dpdGNoIjowLjAsImRlbGF5UmFuZG9tRnJvbSI6MC4wLCJkZWxheVJhbmRvbVNwZWVkIjo1NC4wLCJkZWxheVJhbmRvbVRvIjoxNS4wLCJkZWxheVJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOnRydWUsImRlbGF5U3dpdGNoRGVsYXkiOjAuMCwiZGVsYXlUeXBlIjoiSGFybW9uaWMgUGF0dGVybiIsImhhcm1vbmljQW1wbGl0dWRlIjoyOC4wLCJoYXJtb25pY0Jhc2VEZWxheSI6MTQuMCwiaGFybW9uaWNGcmVxdWVuY3kiOjQ1LjAsImhhcm1vbmljUGhhc2VPZmZzZXQiOjQzLjAsImhhcm1vbmljV2F2ZWZvcm0iOiJTaW5lIn19fSwidCI6eyJhaXIiOnsiYW50aUJydXRlZm9yY2UiOnRydWUsImJvZHlGUyI6Ik9mZiIsImJvZHlZYXciOnRydWUsImRlbGF5X3RpY2tzIjo0MC4wLCJsZWZ0TGltaXQiOjYwLjAsImxlZnRZYXdPZmZzZXQiOi0xNC4wLCJtb2RpZmllciI6IkRpc2FibGVkIiwicmlnaHRMaW1pdCI6NjAuMCwicmlnaHRZYXdPZmZzZXQiOjE3LjAsInlhd09mZnNldCI6MC4wLCJ5YXdUeXBlIjoibC9yIiwifmFudGlCcnV0ZWZvcmNlIjp7ImFiQ3VzdG9tUGhhc2VDb3VudCI6Ny4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMSI6LTE4LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwyIjotMTMuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDMiOi0yMi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNCI6LTIzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw1IjotMTIuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDYiOi0xOC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNyI6LTE1LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIxIjoxNS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMiI6MTcuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjMiOjI1LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI0IjoxOC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNSI6MTYuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjYiOjIzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI3IjoxOC4wLCJhYkN1c3RvbVJhbmRvbWl6ZU9yZGVyIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZUluZGljYXRpb24iOnRydWUsImFudGlCcnV0ZWZvcmNlTW9kZSI6ImN1c3RvbSIsImFudGlCcnV0ZWZvcmNlUmVzZXQiOnRydWUsImFudGlCcnV0ZWZvcmNlVHlwZSI6ImwvciBhZGRzIn0sIn5ib2R5WWF3Ijp7ImRlc3luY09wdGlvbiI6IkRlZmF1bHQiLCJyb3RhdGlvblNwZWVkIjo1MC4wLCJzcGVlZE9wdGlvbiI6IkNvbnN0YW50In0sIn5tb2RpZmllciI6eyJhbHBodkJhc2VEZWxheSI6MC4wLCJhbHBodkJhc2VIb2xkIjowLjAsImFscGh2RmxpY2tDaGFuY2UiOjUwLjAsImFscGh2RmxpY2tDaGFuY2VQZXJQaGFzZSI6MzAuMCwiYWxwaHZGbGlja01heCI6MC4wLCJhbHBodkZsaWNrTWluIjowLjAsImFscGh2RmxpY2tSYW5nZVBlclBoYXNlIjo5MC4wLCJhbHBodlBoYXNlQ291bnQiOjQuMCwiYWxwaHZQaGFzZVNwZWVkIjo4MC4wLCJhbHBodlBoYXNlVmFsdWUxIjotNy4wLCJhbHBodlBoYXNlVmFsdWUxMCI6MC4wLCJhbHBodlBoYXNlVmFsdWUxMSI6MC4wLCJhbHBodlBoYXNlVmFsdWUxMiI6MC4wLCJhbHBodlBoYXNlVmFsdWUyIjowLjAsImFscGh2UGhhc2VWYWx1ZTMiOjAuMCwiYWxwaHZQaGFzZVZhbHVlNCI6MC4wLCJhbHBodlBoYXNlVmFsdWU1IjowLjAsImFscGh2UGhhc2VWYWx1ZTYiOjAuMCwiYWxwaHZQaGFzZVZhbHVlNyI6MC4wLCJhbHBodlBoYXNlVmFsdWU4IjowLjAsImFscGh2UGhhc2VWYWx1ZTkiOjAuMCwiYWxwaHZSYW5kb21EZWxheSI6MC4wLCJhbHBodlJhbmRvbUhvbGQiOjAuMCwiYWxwaHZSYW5kb21pemVQaGFzZU9yZGVyIjpmYWxzZSwiYWxwaHZTcGVlZCI6MTAwLjAsImJ1cnN0Q2hhbmNlIjo1MC4wLCJidXJzdER1cmF0aW9uIjoxMC4wLCJidXJzdE11bHRpcGxpZXIiOjEuMCwiYnVyc3RSYW5kb21GYWN0b3IiOjIwLjAsImNvbnN0YW50Sml0dGVyIjpmYWxzZSwiaml0dGVyTWFnbml0dWRlIjo0NS4wLCJqaXR0ZXJUeXBlIjoiUmFuZG9tIiwibWF4Sml0dGVyRGVsYXkiOjE1LjAsIm1pbkppdHRlckRlbGF5Ijo1LjAsIm1vZEhvbGRDeWNsZXMiOjAuMCwibW9kSG9sZFRpY2tzIjowLjAsIm1vZE9mZnNldCI6MC4wLCJtb2RQaGFzZUNvdW50IjoxLjAsIm1vZFBoYXNlU3BlZWQiOjEuMCwibW9kUGhhc2VWYWx1ZTEiOi03LjAsIm1vZFBoYXNlVmFsdWUxMCI6MC4wLCJtb2RQaGFzZVZhbHVlMTEiOjAuMCwibW9kUGhhc2VWYWx1ZTEyIjowLjAsIm1vZFBoYXNlVmFsdWUyIjowLjAsIm1vZFBoYXNlVmFsdWUzIjowLjAsIm1vZFBoYXNlVmFsdWU0IjowLjAsIm1vZFBoYXNlVmFsdWU1IjowLjAsIm1vZFBoYXNlVmFsdWU2IjowLjAsIm1vZFBoYXNlVmFsdWU3IjowLjAsIm1vZFBoYXNlVmFsdWU4IjowLjAsIm1vZFBoYXNlVmFsdWU5IjowLjAsIm1vZFJhbmRvbSI6MC4wLCJtb2RSYW5kb21EZWxheSI6MC4wLCJtb2RTd2l0Y2hEZWxheSI6MC4wLCJyYW5kVHlwZSI6ImRlZmF1bHQiLCJyYW5kb21pemVKaXR0ZXJEaXJlY3Rpb24iOmZhbHNlLCJyYW5kb21pemVKaXR0ZXJNYWduaXR1ZGUiOjAuMCwicmFuZG9taXplUm90YXRpb25PcmRlciI6ZmFsc2UsInNtb290aFRyYW5zaXRpb24iOnRydWUsInNtb290aGluZ0ZhY3RvciI6NTAuMCwid2F2ZUFtcGxpdHVkZSI6NDUuMCwid2F2ZUZvcm0iOiJTaW5lIiwid2F2ZUZyZXF1ZW5jeSI6MS4wLCJ3YXZlT2Zmc2V0IjowLjB9LCJ+eWF3VHlwZSI6eyJib21iYUJ1cnN0Q2hhbmNlIjozNy4wLCJib21iYUJ1cnN0RHVyYXRpb24iOjEzOS4wLCJib21iYUJ1cnN0RW5hYmxlIjp0cnVlLCJib21iYUJ1cnN0TXVsdGlwbGllciI6MTEwLjAsImJvbWJhQ2hhb3NGYWN0b3IiOjM0LjAsImJvbWJhTWF4RGVsYXkiOjE2LjAsImJvbWJhTWluRGVsYXkiOjQuMCwiYm9tYmFSYW5kb21GYWN0b3IiOjUwLjAsImJvbWJhU21vb3RobmVzcyI6NzAuMCwiZGVsYXlIb2xkQ3ljbGVzIjowLjAsImRlbGF5SG9sZFRpY2tzIjowLjAsImRlbGF5UGhhc2VDb3VudCI6MTIuMCwiZGVsYXlQaGFzZVNwZWVkIjo1MC4wLCJkZWxheVBoYXNlVmFsdWUxIjoxMi4wLCJkZWxheVBoYXNlVmFsdWUxMCI6OC4wLCJkZWxheVBoYXNlVmFsdWUxMSI6MTguMCwiZGVsYXlQaGFzZVZhbHVlMTIiOjUuMCwiZGVsYXlQaGFzZVZhbHVlMiI6NC4wLCJkZWxheVBoYXNlVmFsdWUzIjo1LjAsImRlbGF5UGhhc2VWYWx1ZTQiOjExLjAsImRlbGF5UGhhc2VWYWx1ZTUiOjE0LjAsImRlbGF5UGhhc2VWYWx1ZTYiOjIuMCwiZGVsYXlQaGFzZVZhbHVlNyI6MTEuMCwiZGVsYXlQaGFzZVZhbHVlOCI6MTguMCwiZGVsYXlQaGFzZVZhbHVlOSI6NC4wLCJkZWxheVJhbmRvbURlbGF5Rm9yU3dpdGNoIjowLjAsImRlbGF5UmFuZG9tRnJvbSI6My4wLCJkZWxheVJhbmRvbVNwZWVkIjo1MC4wLCJkZWxheVJhbmRvbVRvIjoxOC4wLCJkZWxheVJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOnRydWUsImRlbGF5U3dpdGNoRGVsYXkiOjAuMCwiZGVsYXlUeXBlIjoiUGhhc2UiLCJoYXJtb25pY0FtcGxpdHVkZSI6MjAuMCwiaGFybW9uaWNCYXNlRGVsYXkiOjUwLjAsImhhcm1vbmljRnJlcXVlbmN5Ijo1MC4wLCJoYXJtb25pY1BoYXNlT2Zmc2V0IjowLjAsImhhcm1vbmljV2F2ZWZvcm0iOiJTaW5lIn19LCJhaXJDcm91Y2giOnsiYW50aUJydXRlZm9yY2UiOnRydWUsImJvZHlGUyI6Ik9mZiIsImJvZHlZYXciOnRydWUsImRlbGF5X3RpY2tzIjo0MC4wLCJsZWZ0TGltaXQiOjYwLjAsImxlZnRZYXdPZmZzZXQiOi0yMi4wLCJtb2RpZmllciI6IlJhbmRvbSIsInJpZ2h0TGltaXQiOjYwLjAsInJpZ2h0WWF3T2Zmc2V0Ijo0OS4wLCJ5YXdPZmZzZXQiOjAuMCwieWF3VHlwZSI6ImwvciIsIn5hbnRpQnJ1dGVmb3JjZSI6eyJhYkN1c3RvbVBoYXNlQ291bnQiOjcuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDEiOi0yMy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMiI6LTIyLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwzIjotMjEuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDQiOi0yNi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNSI6LTIzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw2IjotMTkuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDciOi0yNi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMSI6NDUuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjIiOjQ3LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIzIjo0OC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNCI6NTEuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjUiOjM1LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI2IjozNy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNyI6MzkuMCwiYWJDdXN0b21SYW5kb21pemVPcmRlciI6dHJ1ZSwiYW50aUJydXRlZm9yY2VJbmRpY2F0aW9uIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZU1vZGUiOiJjdXN0b20iLCJhbnRpQnJ1dGVmb3JjZVJlc2V0Ijp0cnVlLCJhbnRpQnJ1dGVmb3JjZVR5cGUiOiJsL3IgYWRkcyJ9LCJ+Ym9keVlhdyI6eyJkZXN5bmNPcHRpb24iOiJEZWZhdWx0Iiwicm90YXRpb25TcGVlZCI6NTAuMCwic3BlZWRPcHRpb24iOiJDb25zdGFudCJ9LCJ+bW9kaWZpZXIiOnsiYWxwaHZCYXNlRGVsYXkiOjE2LjAsImFscGh2QmFzZUhvbGQiOjEuMCwiYWxwaHZGbGlja0NoYW5jZSI6MzIuMCwiYWxwaHZGbGlja0NoYW5jZVBlclBoYXNlIjo4Ny4wLCJhbHBodkZsaWNrTWF4IjoxMS4wLCJhbHBodkZsaWNrTWluIjotOC4wLCJhbHBodkZsaWNrUmFuZ2VQZXJQaGFzZSI6NTkuMCwiYWxwaHZQaGFzZUNvdW50Ijo0LjAsImFscGh2UGhhc2VTcGVlZCI6ODAuMCwiYWxwaHZQaGFzZVZhbHVlMSI6LTQ1LjAsImFscGh2UGhhc2VWYWx1ZTEwIjotMy4wLCJhbHBodlBoYXNlVmFsdWUxMSI6LTMwLjAsImFscGh2UGhhc2VWYWx1ZTEyIjotMzcuMCwiYWxwaHZQaGFzZVZhbHVlMiI6MzguMCwiYWxwaHZQaGFzZVZhbHVlMyI6LTI1LjAsImFscGh2UGhhc2VWYWx1ZTQiOi0zNi4wLCJhbHBodlBoYXNlVmFsdWU1IjotMzYuMCwiYWxwaHZQaGFzZVZhbHVlNiI6NDAuMCwiYWxwaHZQaGFzZVZhbHVlNyI6LTI3LjAsImFscGh2UGhhc2VWYWx1ZTgiOjEwLjAsImFscGh2UGhhc2VWYWx1ZTkiOjguMCwiYWxwaHZSYW5kb21EZWxheSI6My4wLCJhbHBodlJhbmRvbUhvbGQiOjEuMCwiYWxwaHZSYW5kb21pemVQaGFzZU9yZGVyIjpmYWxzZSwiYWxwaHZTcGVlZCI6MTAwLjAsImJ1cnN0Q2hhbmNlIjo1MC4wLCJidXJzdER1cmF0aW9uIjoxOS4wLCJidXJzdE11bHRpcGxpZXIiOjIuMCwiYnVyc3RSYW5kb21GYWN0b3IiOjE4LjAsImNvbnN0YW50Sml0dGVyIjpmYWxzZSwiaml0dGVyTWFnbml0dWRlIjotNDEuMCwiaml0dGVyVHlwZSI6IlJhbmRvbSIsIm1heEppdHRlckRlbGF5IjoxNy4wLCJtaW5KaXR0ZXJEZWxheSI6Mi4wLCJtb2RIb2xkQ3ljbGVzIjoxLjAsIm1vZEhvbGRUaWNrcyI6MS4wLCJtb2RPZmZzZXQiOi0yLjAsIm1vZFBoYXNlQ291bnQiOjEyLjAsIm1vZFBoYXNlU3BlZWQiOjUwLjAsIm1vZFBoYXNlVmFsdWUxIjotNDUuMCwibW9kUGhhc2VWYWx1ZTEwIjotMy4wLCJtb2RQaGFzZVZhbHVlMTEiOi0zMC4wLCJtb2RQaGFzZVZhbHVlMTIiOi0zNy4wLCJtb2RQaGFzZVZhbHVlMiI6MzguMCwibW9kUGhhc2VWYWx1ZTMiOi0yNS4wLCJtb2RQaGFzZVZhbHVlNCI6LTM2LjAsIm1vZFBoYXNlVmFsdWU1IjotMzYuMCwibW9kUGhhc2VWYWx1ZTYiOjQwLjAsIm1vZFBoYXNlVmFsdWU3IjotMjcuMCwibW9kUGhhc2VWYWx1ZTgiOjEwLjAsIm1vZFBoYXNlVmFsdWU5Ijo4LjAsIm1vZFJhbmRvbSI6NjEuMCwibW9kUmFuZG9tRGVsYXkiOjMuMCwibW9kU3dpdGNoRGVsYXkiOjEuMCwicmFuZFR5cGUiOiJkZWxheSIsInJhbmRvbWl6ZUppdHRlckRpcmVjdGlvbiI6dHJ1ZSwicmFuZG9taXplSml0dGVyTWFnbml0dWRlIjozNS4wLCJyYW5kb21pemVSb3RhdGlvbk9yZGVyIjpmYWxzZSwic21vb3RoVHJhbnNpdGlvbiI6dHJ1ZSwic21vb3RoaW5nRmFjdG9yIjo1MC4wLCJ3YXZlQW1wbGl0dWRlIjoxMS4wLCJ3YXZlRm9ybSI6IlNpbmUiLCJ3YXZlRnJlcXVlbmN5IjoxLjAsIndhdmVPZmZzZXQiOjIxLjB9LCJ+eWF3VHlwZSI6eyJib21iYUJ1cnN0Q2hhbmNlIjo0NC4wLCJib21iYUJ1cnN0RHVyYXRpb24iOjIzMi4wLCJib21iYUJ1cnN0RW5hYmxlIjp0cnVlLCJib21iYUJ1cnN0TXVsdGlwbGllciI6NzkuMCwiYm9tYmFDaGFvc0ZhY3RvciI6MjMuMCwiYm9tYmFNYXhEZWxheSI6MTQuMCwiYm9tYmFNaW5EZWxheSI6NS4wLCJib21iYVJhbmRvbUZhY3RvciI6MjcuMCwiYm9tYmFTbW9vdGhuZXNzIjo3MC4wLCJkZWxheUhvbGRDeWNsZXMiOjEuMCwiZGVsYXlIb2xkVGlja3MiOjEuMCwiZGVsYXlQaGFzZUNvdW50IjoxMi4wLCJkZWxheVBoYXNlU3BlZWQiOjUyLjAsImRlbGF5UGhhc2VWYWx1ZTEiOjEwLjAsImRlbGF5UGhhc2VWYWx1ZTEwIjo3LjAsImRlbGF5UGhhc2VWYWx1ZTExIjoyLjAsImRlbGF5UGhhc2VWYWx1ZTEyIjoxMi4wLCJkZWxheVBoYXNlVmFsdWUyIjo3LjAsImRlbGF5UGhhc2VWYWx1ZTMiOjYuMCwiZGVsYXlQaGFzZVZhbHVlNCI6MTIuMCwiZGVsYXlQaGFzZVZhbHVlNSI6MTMuMCwiZGVsYXlQaGFzZVZhbHVlNiI6MTYuMCwiZGVsYXlQaGFzZVZhbHVlNyI6MTAuMCwiZGVsYXlQaGFzZVZhbHVlOCI6MTUuMCwiZGVsYXlQaGFzZVZhbHVlOSI6MTAuMCwiZGVsYXlSYW5kb21EZWxheUZvclN3aXRjaCI6My4wLCJkZWxheVJhbmRvbUZyb20iOjUuMCwiZGVsYXlSYW5kb21TcGVlZCI6NTIuMCwiZGVsYXlSYW5kb21UbyI6MjQuMCwiZGVsYXlSYW5kb21pemVSb3RhdGlvbk9yZGVyIjp0cnVlLCJkZWxheVN3aXRjaERlbGF5IjoyLjAsImRlbGF5VHlwZSI6IlJhbmRvbSIsImhhcm1vbmljQW1wbGl0dWRlIjoxMy4wLCJoYXJtb25pY0Jhc2VEZWxheSI6MTIuMCwiaGFybW9uaWNGcmVxdWVuY3kiOjU3LjAsImhhcm1vbmljUGhhc2VPZmZzZXQiOjU5LjAsImhhcm1vbmljV2F2ZWZvcm0iOiJTaW5lIn19LCJjcm91Y2giOnsiYW50aUJydXRlZm9yY2UiOnRydWUsImJvZHlGUyI6Ik9mZiIsImJvZHlZYXciOnRydWUsImRlbGF5X3RpY2tzIjo0MC4wLCJsZWZ0TGltaXQiOjU2LjAsImxlZnRZYXdPZmZzZXQiOi0xNy4wLCJtb2RpZmllciI6IlJhbmRvbSIsInJpZ2h0TGltaXQiOjU2LjAsInJpZ2h0WWF3T2Zmc2V0IjoyNS4wLCJ5YXdPZmZzZXQiOjAuMCwieWF3VHlwZSI6ImwvciIsIn5hbnRpQnJ1dGVmb3JjZSI6eyJhYkN1c3RvbVBoYXNlQ291bnQiOjcuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDEiOi0yMC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMiI6LTIzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwzIjotMTkuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDQiOi0yNy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNSI6LTIzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw2IjotMTguMCwiYWJDdXN0b21QaGFzZVZhbHVlTDciOi0yNi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMSI6MjQuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjIiOjE1LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIzIjoyMS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNCI6MjMuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjUiOjE5LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI2IjoxOC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNyI6MjUuMCwiYWJDdXN0b21SYW5kb21pemVPcmRlciI6dHJ1ZSwiYW50aUJydXRlZm9yY2VJbmRpY2F0aW9uIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZU1vZGUiOiJjdXN0b20iLCJhbnRpQnJ1dGVmb3JjZVJlc2V0Ijp0cnVlLCJhbnRpQnJ1dGVmb3JjZVR5cGUiOiJsL3IgYWRkcyJ9LCJ+Ym9keVlhdyI6eyJkZXN5bmNPcHRpb24iOiJEZWZhdWx0Iiwicm90YXRpb25TcGVlZCI6NTAuMCwic3BlZWRPcHRpb24iOiJDb25zdGFudCJ9LCJ+bW9kaWZpZXIiOnsiYWxwaHZCYXNlRGVsYXkiOjAuMCwiYWxwaHZCYXNlSG9sZCI6MS4wLCJhbHBodkZsaWNrQ2hhbmNlIjozMi4wLCJhbHBodkZsaWNrQ2hhbmNlUGVyUGhhc2UiOjg3LjAsImFscGh2RmxpY2tNYXgiOjExLjAsImFscGh2RmxpY2tNaW4iOi04LjAsImFscGh2RmxpY2tSYW5nZVBlclBoYXNlIjo1OS4wLCJhbHBodlBoYXNlQ291bnQiOjQuMCwiYWxwaHZQaGFzZVNwZWVkIjo4MC4wLCJhbHBodlBoYXNlVmFsdWUxIjowLjAsImFscGh2UGhhc2VWYWx1ZTEwIjotMy4wLCJhbHBodlBoYXNlVmFsdWUxMSI6LTMwLjAsImFscGh2UGhhc2VWYWx1ZTEyIjotMzcuMCwiYWxwaHZQaGFzZVZhbHVlMiI6MC4wLCJhbHBodlBoYXNlVmFsdWUzIjoxNS4wLCJhbHBodlBoYXNlVmFsdWU0IjotMTMuMCwiYWxwaHZQaGFzZVZhbHVlNSI6Ny4wLCJhbHBodlBoYXNlVmFsdWU2IjoxLjAsImFscGh2UGhhc2VWYWx1ZTciOi0yNy4wLCJhbHBodlBoYXNlVmFsdWU4IjoxMC4wLCJhbHBodlBoYXNlVmFsdWU5Ijo4LjAsImFscGh2UmFuZG9tRGVsYXkiOjIuMCwiYWxwaHZSYW5kb21Ib2xkIjoxLjAsImFscGh2UmFuZG9taXplUGhhc2VPcmRlciI6dHJ1ZSwiYWxwaHZTcGVlZCI6MTAwLjAsImJ1cnN0Q2hhbmNlIjo1MC4wLCJidXJzdER1cmF0aW9uIjoxOS4wLCJidXJzdE11bHRpcGxpZXIiOjIuMCwiYnVyc3RSYW5kb21GYWN0b3IiOjE4LjAsImNvbnN0YW50Sml0dGVyIjpmYWxzZSwiaml0dGVyTWFnbml0dWRlIjotNDEuMCwiaml0dGVyVHlwZSI6IlJhbmRvbSIsIm1heEppdHRlckRlbGF5IjoxNy4wLCJtaW5KaXR0ZXJEZWxheSI6Mi4wLCJtb2RIb2xkQ3ljbGVzIjowLjAsIm1vZEhvbGRUaWNrcyI6Mi4wLCJtb2RPZmZzZXQiOjIxLjAsIm1vZFBoYXNlQ291bnQiOjMuMCwibW9kUGhhc2VTcGVlZCI6NTAuMCwibW9kUGhhc2VWYWx1ZTEiOjAuMCwibW9kUGhhc2VWYWx1ZTEwIjotMy4wLCJtb2RQaGFzZVZhbHVlMTEiOi0zMC4wLCJtb2RQaGFzZVZhbHVlMTIiOi0zNy4wLCJtb2RQaGFzZVZhbHVlMiI6MC4wLCJtb2RQaGFzZVZhbHVlMyI6MTUuMCwibW9kUGhhc2VWYWx1ZTQiOi0xMy4wLCJtb2RQaGFzZVZhbHVlNSI6Ny4wLCJtb2RQaGFzZVZhbHVlNiI6MS4wLCJtb2RQaGFzZVZhbHVlNyI6LTI3LjAsIm1vZFBoYXNlVmFsdWU4IjoxMC4wLCJtb2RQaGFzZVZhbHVlOSI6OC4wLCJtb2RSYW5kb20iOjYxLjAsIm1vZFJhbmRvbURlbGF5IjoyLjAsIm1vZFN3aXRjaERlbGF5IjoxLjAsInJhbmRUeXBlIjoiZGVsYXkiLCJyYW5kb21pemVKaXR0ZXJEaXJlY3Rpb24iOnRydWUsInJhbmRvbWl6ZUppdHRlck1hZ25pdHVkZSI6MzUuMCwicmFuZG9taXplUm90YXRpb25PcmRlciI6ZmFsc2UsInNtb290aFRyYW5zaXRpb24iOnRydWUsInNtb290aGluZ0ZhY3RvciI6NTAuMCwid2F2ZUFtcGxpdHVkZSI6MTEuMCwid2F2ZUZvcm0iOiJTaW5lIiwid2F2ZUZyZXF1ZW5jeSI6MS4wLCJ3YXZlT2Zmc2V0IjoyMS4wfSwifnlhd1R5cGUiOnsiYm9tYmFCdXJzdENoYW5jZSI6NDQuMCwiYm9tYmFCdXJzdER1cmF0aW9uIjoxODcuMCwiYm9tYmFCdXJzdEVuYWJsZSI6dHJ1ZSwiYm9tYmFCdXJzdE11bHRpcGxpZXIiOjgzLjAsImJvbWJhQ2hhb3NGYWN0b3IiOjQ1LjAsImJvbWJhTWF4RGVsYXkiOjE0LjAsImJvbWJhTWluRGVsYXkiOjUuMCwiYm9tYmFSYW5kb21GYWN0b3IiOjY4LjAsImJvbWJhU21vb3RobmVzcyI6NzAuMCwiZGVsYXlIb2xkQ3ljbGVzIjowLjAsImRlbGF5SG9sZFRpY2tzIjowLjAsImRlbGF5UGhhc2VDb3VudCI6MTIuMCwiZGVsYXlQaGFzZVNwZWVkIjoyOC4wLCJkZWxheVBoYXNlVmFsdWUxIjoxOC4wLCJkZWxheVBoYXNlVmFsdWUxMCI6MTEuMCwiZGVsYXlQaGFzZVZhbHVlMTEiOjE3LjAsImRlbGF5UGhhc2VWYWx1ZTEyIjoxNC4wLCJkZWxheVBoYXNlVmFsdWUyIjoxMy4wLCJkZWxheVBoYXNlVmFsdWUzIjoxMy4wLCJkZWxheVBoYXNlVmFsdWU0Ijo4LjAsImRlbGF5UGhhc2VWYWx1ZTUiOjcuMCwiZGVsYXlQaGFzZVZhbHVlNiI6MTEuMCwiZGVsYXlQaGFzZVZhbHVlNyI6NS4wLCJkZWxheVBoYXNlVmFsdWU4IjoxMS4wLCJkZWxheVBoYXNlVmFsdWU5IjoxMS4wLCJkZWxheVJhbmRvbURlbGF5Rm9yU3dpdGNoIjowLjAsImRlbGF5UmFuZG9tRnJvbSI6NC4wLCJkZWxheVJhbmRvbVNwZWVkIjoyOC4wLCJkZWxheVJhbmRvbVRvIjoyNS4wLCJkZWxheVJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOnRydWUsImRlbGF5U3dpdGNoRGVsYXkiOjAuMCwiZGVsYXlUeXBlIjoiUGhhc2UiLCJoYXJtb25pY0FtcGxpdHVkZSI6MjcuMCwiaGFybW9uaWNCYXNlRGVsYXkiOjEzLjAsImhhcm1vbmljRnJlcXVlbmN5IjoxMS4wLCJoYXJtb25pY1BoYXNlT2Zmc2V0IjozOC4wLCJoYXJtb25pY1dhdmVmb3JtIjoiU2luZSJ9fSwicnVuIjp7ImFudGlCcnV0ZWZvcmNlIjp0cnVlLCJib2R5RlMiOiJPZmYiLCJib2R5WWF3Ijp0cnVlLCJkZWxheV90aWNrcyI6NDAuMCwibGVmdExpbWl0Ijo2MC4wLCJsZWZ0WWF3T2Zmc2V0IjotMjYuMCwibW9kaWZpZXIiOiJSYW5kb20iLCJyaWdodExpbWl0Ijo2MC4wLCJyaWdodFlhd09mZnNldCI6NDEuMCwieWF3T2Zmc2V0IjowLjAsInlhd1R5cGUiOiJsL3IiLCJ+YW50aUJydXRlZm9yY2UiOnsiYWJDdXN0b21QaGFzZUNvdW50Ijo3LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwxIjotMjQuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDIiOi0yNS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMyI6LTE3LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw0IjotMjcuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDUiOi0yOC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNiI6LTIzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw3IjotMjYuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjEiOjM5LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIyIjo0Mi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMyI6MzguMCwiYWJDdXN0b21QaGFzZVZhbHVlUjQiOjQzLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI1Ijo0NC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNiI6NDAuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjciOjM3LjAsImFiQ3VzdG9tUmFuZG9taXplT3JkZXIiOnRydWUsImFudGlCcnV0ZWZvcmNlSW5kaWNhdGlvbiI6dHJ1ZSwiYW50aUJydXRlZm9yY2VNb2RlIjoiY3VzdG9tIiwiYW50aUJydXRlZm9yY2VSZXNldCI6dHJ1ZSwiYW50aUJydXRlZm9yY2VUeXBlIjoibC9yIGFkZHMifSwifmJvZHlZYXciOnsiZGVzeW5jT3B0aW9uIjoiRGVmYXVsdCIsInJvdGF0aW9uU3BlZWQiOjUwLjAsInNwZWVkT3B0aW9uIjoiQ29uc3RhbnQifSwifm1vZGlmaWVyIjp7ImFscGh2QmFzZURlbGF5IjoxNi4wLCJhbHBodkJhc2VIb2xkIjoxLjAsImFscGh2RmxpY2tDaGFuY2UiOjMyLjAsImFscGh2RmxpY2tDaGFuY2VQZXJQaGFzZSI6ODcuMCwiYWxwaHZGbGlja01heCI6MTEuMCwiYWxwaHZGbGlja01pbiI6LTguMCwiYWxwaHZGbGlja1JhbmdlUGVyUGhhc2UiOjU5LjAsImFscGh2UGhhc2VDb3VudCI6NC4wLCJhbHBodlBoYXNlU3BlZWQiOjgwLjAsImFscGh2UGhhc2VWYWx1ZTEiOi00NS4wLCJhbHBodlBoYXNlVmFsdWUxMCI6LTMuMCwiYWxwaHZQaGFzZVZhbHVlMTEiOi0zMC4wLCJhbHBodlBoYXNlVmFsdWUxMiI6LTM3LjAsImFscGh2UGhhc2VWYWx1ZTIiOjM4LjAsImFscGh2UGhhc2VWYWx1ZTMiOi0yNS4wLCJhbHBodlBoYXNlVmFsdWU0IjotMzYuMCwiYWxwaHZQaGFzZVZhbHVlNSI6LTM2LjAsImFscGh2UGhhc2VWYWx1ZTYiOjQwLjAsImFscGh2UGhhc2VWYWx1ZTciOi0yNy4wLCJhbHBodlBoYXNlVmFsdWU4IjoxMC4wLCJhbHBodlBoYXNlVmFsdWU5Ijo4LjAsImFscGh2UmFuZG9tRGVsYXkiOjMuMCwiYWxwaHZSYW5kb21Ib2xkIjoxLjAsImFscGh2UmFuZG9taXplUGhhc2VPcmRlciI6ZmFsc2UsImFscGh2U3BlZWQiOjEwMC4wLCJidXJzdENoYW5jZSI6NTAuMCwiYnVyc3REdXJhdGlvbiI6MTkuMCwiYnVyc3RNdWx0aXBsaWVyIjoyLjAsImJ1cnN0UmFuZG9tRmFjdG9yIjoxOC4wLCJjb25zdGFudEppdHRlciI6ZmFsc2UsImppdHRlck1hZ25pdHVkZSI6LTQxLjAsImppdHRlclR5cGUiOiJSYW5kb20iLCJtYXhKaXR0ZXJEZWxheSI6MTcuMCwibWluSml0dGVyRGVsYXkiOjIuMCwibW9kSG9sZEN5Y2xlcyI6MS4wLCJtb2RIb2xkVGlja3MiOjEuMCwibW9kT2Zmc2V0IjotMi4wLCJtb2RQaGFzZUNvdW50IjoxMi4wLCJtb2RQaGFzZVNwZWVkIjo1MC4wLCJtb2RQaGFzZVZhbHVlMSI6LTQ1LjAsIm1vZFBoYXNlVmFsdWUxMCI6LTMuMCwibW9kUGhhc2VWYWx1ZTExIjotMzAuMCwibW9kUGhhc2VWYWx1ZTEyIjotMzcuMCwibW9kUGhhc2VWYWx1ZTIiOjM4LjAsIm1vZFBoYXNlVmFsdWUzIjotMjUuMCwibW9kUGhhc2VWYWx1ZTQiOi0zNi4wLCJtb2RQaGFzZVZhbHVlNSI6LTM2LjAsIm1vZFBoYXNlVmFsdWU2Ijo0MC4wLCJtb2RQaGFzZVZhbHVlNyI6LTI3LjAsIm1vZFBoYXNlVmFsdWU4IjoxMC4wLCJtb2RQaGFzZVZhbHVlOSI6OC4wLCJtb2RSYW5kb20iOjYxLjAsIm1vZFJhbmRvbURlbGF5IjozLjAsIm1vZFN3aXRjaERlbGF5IjoxLjAsInJhbmRUeXBlIjoiZGVsYXkiLCJyYW5kb21pemVKaXR0ZXJEaXJlY3Rpb24iOnRydWUsInJhbmRvbWl6ZUppdHRlck1hZ25pdHVkZSI6MzUuMCwicmFuZG9taXplUm90YXRpb25PcmRlciI6ZmFsc2UsInNtb290aFRyYW5zaXRpb24iOnRydWUsInNtb290aGluZ0ZhY3RvciI6NTAuMCwid2F2ZUFtcGxpdHVkZSI6MTEuMCwid2F2ZUZvcm0iOiJTaW5lIiwid2F2ZUZyZXF1ZW5jeSI6MS4wLCJ3YXZlT2Zmc2V0IjoyMS4wfSwifnlhd1R5cGUiOnsiYm9tYmFCdXJzdENoYW5jZSI6NDQuMCwiYm9tYmFCdXJzdER1cmF0aW9uIjoyMzIuMCwiYm9tYmFCdXJzdEVuYWJsZSI6dHJ1ZSwiYm9tYmFCdXJzdE11bHRpcGxpZXIiOjc5LjAsImJvbWJhQ2hhb3NGYWN0b3IiOjIzLjAsImJvbWJhTWF4RGVsYXkiOjE0LjAsImJvbWJhTWluRGVsYXkiOjUuMCwiYm9tYmFSYW5kb21GYWN0b3IiOjI3LjAsImJvbWJhU21vb3RobmVzcyI6NzAuMCwiZGVsYXlIb2xkQ3ljbGVzIjowLjAsImRlbGF5SG9sZFRpY2tzIjowLjAsImRlbGF5UGhhc2VDb3VudCI6MTIuMCwiZGVsYXlQaGFzZVNwZWVkIjoyOC4wLCJkZWxheVBoYXNlVmFsdWUxIjoxMC4wLCJkZWxheVBoYXNlVmFsdWUxMCI6Ny4wLCJkZWxheVBoYXNlVmFsdWUxMSI6Mi4wLCJkZWxheVBoYXNlVmFsdWUxMiI6MTIuMCwiZGVsYXlQaGFzZVZhbHVlMiI6Ny4wLCJkZWxheVBoYXNlVmFsdWUzIjo2LjAsImRlbGF5UGhhc2VWYWx1ZTQiOjEyLjAsImRlbGF5UGhhc2VWYWx1ZTUiOjEzLjAsImRlbGF5UGhhc2VWYWx1ZTYiOjE2LjAsImRlbGF5UGhhc2VWYWx1ZTciOjEwLjAsImRlbGF5UGhhc2VWYWx1ZTgiOjE1LjAsImRlbGF5UGhhc2VWYWx1ZTkiOjEwLjAsImRlbGF5UmFuZG9tRGVsYXlGb3JTd2l0Y2giOjAuMCwiZGVsYXlSYW5kb21Gcm9tIjo0LjAsImRlbGF5UmFuZG9tU3BlZWQiOjI4LjAsImRlbGF5UmFuZG9tVG8iOjI1LjAsImRlbGF5UmFuZG9taXplUm90YXRpb25PcmRlciI6dHJ1ZSwiZGVsYXlTd2l0Y2hEZWxheSI6MC4wLCJkZWxheVR5cGUiOiJIYXJtb25pYyBQYXR0ZXJuIiwiaGFybW9uaWNBbXBsaXR1ZGUiOjEzLjAsImhhcm1vbmljQmFzZURlbGF5IjoxMy4wLCJoYXJtb25pY0ZyZXF1ZW5jeSI6NTcuMCwiaGFybW9uaWNQaGFzZU9mZnNldCI6MzguMCwiaGFybW9uaWNXYXZlZm9ybSI6IlNpbmUifX0sInNsb3ciOnsiYW50aUJydXRlZm9yY2UiOnRydWUsImJvZHlGUyI6Ik9mZiIsImJvZHlZYXciOnRydWUsImRlbGF5X3RpY2tzIjo0MC4wLCJsZWZ0TGltaXQiOjYwLjAsImxlZnRZYXdPZmZzZXQiOi0xNy4wLCJtb2RpZmllciI6IlJhbmRvbSIsInJpZ2h0TGltaXQiOjYwLjAsInJpZ2h0WWF3T2Zmc2V0IjoyNy4wLCJ5YXdPZmZzZXQiOjAuMCwieWF3VHlwZSI6ImwvciIsIn5hbnRpQnJ1dGVmb3JjZSI6eyJhYkN1c3RvbVBoYXNlQ291bnQiOjEuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDEiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDIiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDMiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDQiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDUiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDYiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDciOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjEiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjIiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjMiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjQiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjUiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjYiOjAuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjciOjAuMCwiYWJDdXN0b21SYW5kb21pemVPcmRlciI6ZmFsc2UsImFudGlCcnV0ZWZvcmNlSW5kaWNhdGlvbiI6dHJ1ZSwiYW50aUJydXRlZm9yY2VNb2RlIjoicHJlLW1hZGUgW3NoZHddIiwiYW50aUJydXRlZm9yY2VSZXNldCI6dHJ1ZSwiYW50aUJydXRlZm9yY2VUeXBlIjoibC9yIGFkZHMifSwifmJvZHlZYXciOnsiZGVzeW5jT3B0aW9uIjoiRGVmYXVsdCIsInJvdGF0aW9uU3BlZWQiOjUwLjAsInNwZWVkT3B0aW9uIjoiQ29uc3RhbnQifSwifm1vZGlmaWVyIjp7ImFscGh2QmFzZURlbGF5IjowLjAsImFscGh2QmFzZUhvbGQiOjAuMCwiYWxwaHZGbGlja0NoYW5jZSI6NTAuMCwiYWxwaHZGbGlja0NoYW5jZVBlclBoYXNlIjozMC4wLCJhbHBodkZsaWNrTWF4IjowLjAsImFscGh2RmxpY2tNaW4iOjAuMCwiYWxwaHZGbGlja1JhbmdlUGVyUGhhc2UiOjkwLjAsImFscGh2UGhhc2VDb3VudCI6NC4wLCJhbHBodlBoYXNlU3BlZWQiOjgwLjAsImFscGh2UGhhc2VWYWx1ZTEiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMTAiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMTEiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMTIiOjAuMCwiYWxwaHZQaGFzZVZhbHVlMiI6MC4wLCJhbHBodlBoYXNlVmFsdWUzIjowLjAsImFscGh2UGhhc2VWYWx1ZTQiOjAuMCwiYWxwaHZQaGFzZVZhbHVlNSI6MC4wLCJhbHBodlBoYXNlVmFsdWU2IjowLjAsImFscGh2UGhhc2VWYWx1ZTciOjAuMCwiYWxwaHZQaGFzZVZhbHVlOCI6MC4wLCJhbHBodlBoYXNlVmFsdWU5IjowLjAsImFscGh2UmFuZG9tRGVsYXkiOjMuMCwiYWxwaHZSYW5kb21Ib2xkIjowLjAsImFscGh2UmFuZG9taXplUGhhc2VPcmRlciI6ZmFsc2UsImFscGh2U3BlZWQiOjEwMC4wLCJidXJzdENoYW5jZSI6NTAuMCwiYnVyc3REdXJhdGlvbiI6MTAuMCwiYnVyc3RNdWx0aXBsaWVyIjoxLjAsImJ1cnN0UmFuZG9tRmFjdG9yIjoyMC4wLCJjb25zdGFudEppdHRlciI6ZmFsc2UsImppdHRlck1hZ25pdHVkZSI6MTAuMCwiaml0dGVyVHlwZSI6IldhdmUiLCJtYXhKaXR0ZXJEZWxheSI6MTUuMCwibWluSml0dGVyRGVsYXkiOjUuMCwibW9kSG9sZEN5Y2xlcyI6MS4wLCJtb2RIb2xkVGlja3MiOjEuMCwibW9kT2Zmc2V0IjotMzcuMCwibW9kUGhhc2VDb3VudCI6MS4wLCJtb2RQaGFzZVNwZWVkIjo1MC4wLCJtb2RQaGFzZVZhbHVlMSI6MC4wLCJtb2RQaGFzZVZhbHVlMTAiOjAuMCwibW9kUGhhc2VWYWx1ZTExIjowLjAsIm1vZFBoYXNlVmFsdWUxMiI6MC4wLCJtb2RQaGFzZVZhbHVlMiI6MC4wLCJtb2RQaGFzZVZhbHVlMyI6MC4wLCJtb2RQaGFzZVZhbHVlNCI6MC4wLCJtb2RQaGFzZVZhbHVlNSI6MC4wLCJtb2RQaGFzZVZhbHVlNiI6MC4wLCJtb2RQaGFzZVZhbHVlNyI6MC4wLCJtb2RQaGFzZVZhbHVlOCI6MC4wLCJtb2RQaGFzZVZhbHVlOSI6MC4wLCJtb2RSYW5kb20iOjcxLjAsIm1vZFJhbmRvbURlbGF5IjozLjAsIm1vZFN3aXRjaERlbGF5IjoyLjAsInJhbmRUeXBlIjoiZGVsYXkiLCJyYW5kb21pemVKaXR0ZXJEaXJlY3Rpb24iOmZhbHNlLCJyYW5kb21pemVKaXR0ZXJNYWduaXR1ZGUiOjAuMCwicmFuZG9taXplUm90YXRpb25PcmRlciI6ZmFsc2UsInNtb290aFRyYW5zaXRpb24iOnRydWUsInNtb290aGluZ0ZhY3RvciI6NTAuMCwid2F2ZUFtcGxpdHVkZSI6NDUuMCwid2F2ZUZvcm0iOiJTaW5lIiwid2F2ZUZyZXF1ZW5jeSI6MS4wLCJ3YXZlT2Zmc2V0IjowLjB9LCJ+eWF3VHlwZSI6eyJib21iYUJ1cnN0Q2hhbmNlIjo3Ny4wLCJib21iYUJ1cnN0RHVyYXRpb24iOjEwMC4wLCJib21iYUJ1cnN0RW5hYmxlIjp0cnVlLCJib21iYUJ1cnN0TXVsdGlwbGllciI6MzI4LjAsImJvbWJhQ2hhb3NGYWN0b3IiOjY2LjAsImJvbWJhTWF4RGVsYXkiOjE3LjAsImJvbWJhTWluRGVsYXkiOjUuMCwiYm9tYmFSYW5kb21GYWN0b3IiOjUwLjAsImJvbWJhU21vb3RobmVzcyI6NzAuMCwiZGVsYXlIb2xkQ3ljbGVzIjoxLjAsImRlbGF5SG9sZFRpY2tzIjoxLjAsImRlbGF5UGhhc2VDb3VudCI6MS4wLCJkZWxheVBoYXNlU3BlZWQiOjUwLjAsImRlbGF5UGhhc2VWYWx1ZTEiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTEwIjo0MC4wLCJkZWxheVBoYXNlVmFsdWUxMSI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlMTIiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTIiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTMiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTQiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTUiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTYiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTciOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTgiOjQwLjAsImRlbGF5UGhhc2VWYWx1ZTkiOjQwLjAsImRlbGF5UmFuZG9tRGVsYXlGb3JTd2l0Y2giOjIxLjAsImRlbGF5UmFuZG9tRnJvbSI6Ni4wLCJkZWxheVJhbmRvbVNwZWVkIjo1MC4wLCJkZWxheVJhbmRvbVRvIjoyNS4wLCJkZWxheVJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOmZhbHNlLCJkZWxheVN3aXRjaERlbGF5IjozLjAsImRlbGF5VHlwZSI6IlN3aXRjaCIsImhhcm1vbmljQW1wbGl0dWRlIjoyMC4wLCJoYXJtb25pY0Jhc2VEZWxheSI6NTAuMCwiaGFybW9uaWNGcmVxdWVuY3kiOjUwLjAsImhhcm1vbmljUGhhc2VPZmZzZXQiOjAuMCwiaGFybW9uaWNXYXZlZm9ybSI6IlNpbmUifX0sInNuZWFrIjp7ImFudGlCcnV0ZWZvcmNlIjp0cnVlLCJib2R5RlMiOiJPZmYiLCJib2R5WWF3Ijp0cnVlLCJkZWxheV90aWNrcyI6NDAuMCwibGVmdExpbWl0Ijo2MC4wLCJsZWZ0WWF3T2Zmc2V0IjotMjMuMCwibW9kaWZpZXIiOiJSYW5kb20iLCJyaWdodExpbWl0Ijo2MC4wLCJyaWdodFlhd09mZnNldCI6MjcuMCwieWF3T2Zmc2V0IjowLjAsInlhd1R5cGUiOiJsL3IiLCJ+YW50aUJydXRlZm9yY2UiOnsiYWJDdXN0b21QaGFzZUNvdW50Ijo3LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwxIjotMjUuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDIiOi0yNC4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMMyI6LTE5LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw0IjotMjcuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDUiOi0yMy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNiI6LTE4LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw3IjotMjYuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjEiOjI4LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIyIjoyNi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMyI6MjUuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjQiOjI0LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI1IjoyOS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNiI6MjcuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjciOjI1LjAsImFiQ3VzdG9tUmFuZG9taXplT3JkZXIiOnRydWUsImFudGlCcnV0ZWZvcmNlSW5kaWNhdGlvbiI6dHJ1ZSwiYW50aUJydXRlZm9yY2VNb2RlIjoiY3VzdG9tIiwiYW50aUJydXRlZm9yY2VSZXNldCI6dHJ1ZSwiYW50aUJydXRlZm9yY2VUeXBlIjoibC9yIGFkZHMifSwifmJvZHlZYXciOnsiZGVzeW5jT3B0aW9uIjoiRGVmYXVsdCIsInJvdGF0aW9uU3BlZWQiOjUwLjAsInNwZWVkT3B0aW9uIjoiQ29uc3RhbnQifSwifm1vZGlmaWVyIjp7ImFscGh2QmFzZURlbGF5IjoxNi4wLCJhbHBodkJhc2VIb2xkIjoxLjAsImFscGh2RmxpY2tDaGFuY2UiOjMyLjAsImFscGh2RmxpY2tDaGFuY2VQZXJQaGFzZSI6ODcuMCwiYWxwaHZGbGlja01heCI6MTEuMCwiYWxwaHZGbGlja01pbiI6LTguMCwiYWxwaHZGbGlja1JhbmdlUGVyUGhhc2UiOjU5LjAsImFscGh2UGhhc2VDb3VudCI6NC4wLCJhbHBodlBoYXNlU3BlZWQiOjgwLjAsImFscGh2UGhhc2VWYWx1ZTEiOi0yMC4wLCJhbHBodlBoYXNlVmFsdWUxMCI6LTMuMCwiYWxwaHZQaGFzZVZhbHVlMTEiOi0zMC4wLCJhbHBodlBoYXNlVmFsdWUxMiI6LTM3LjAsImFscGh2UGhhc2VWYWx1ZTIiOi0xMy4wLCJhbHBodlBoYXNlVmFsdWUzIjotNy4wLCJhbHBodlBoYXNlVmFsdWU0IjotMTMuMCwiYWxwaHZQaGFzZVZhbHVlNSI6Ny4wLCJhbHBodlBoYXNlVmFsdWU2IjoxLjAsImFscGh2UGhhc2VWYWx1ZTciOi0yNy4wLCJhbHBodlBoYXNlVmFsdWU4IjoxMC4wLCJhbHBodlBoYXNlVmFsdWU5Ijo4LjAsImFscGh2UmFuZG9tRGVsYXkiOjAuMCwiYWxwaHZSYW5kb21Ib2xkIjoxLjAsImFscGh2UmFuZG9taXplUGhhc2VPcmRlciI6ZmFsc2UsImFscGh2U3BlZWQiOjEwMC4wLCJidXJzdENoYW5jZSI6NTAuMCwiYnVyc3REdXJhdGlvbiI6MTkuMCwiYnVyc3RNdWx0aXBsaWVyIjoyLjAsImJ1cnN0UmFuZG9tRmFjdG9yIjoxOC4wLCJjb25zdGFudEppdHRlciI6ZmFsc2UsImppdHRlck1hZ25pdHVkZSI6LTQxLjAsImppdHRlclR5cGUiOiJSYW5kb20iLCJtYXhKaXR0ZXJEZWxheSI6MTcuMCwibWluSml0dGVyRGVsYXkiOjIuMCwibW9kSG9sZEN5Y2xlcyI6MC4wLCJtb2RIb2xkVGlja3MiOjEuMCwibW9kT2Zmc2V0IjoxMS4wLCJtb2RQaGFzZUNvdW50Ijo3LjAsIm1vZFBoYXNlU3BlZWQiOjI1LjAsIm1vZFBoYXNlVmFsdWUxIjotMjAuMCwibW9kUGhhc2VWYWx1ZTEwIjotMy4wLCJtb2RQaGFzZVZhbHVlMTEiOi0zMC4wLCJtb2RQaGFzZVZhbHVlMTIiOi0zNy4wLCJtb2RQaGFzZVZhbHVlMiI6LTEzLjAsIm1vZFBoYXNlVmFsdWUzIjotNy4wLCJtb2RQaGFzZVZhbHVlNCI6LTEzLjAsIm1vZFBoYXNlVmFsdWU1Ijo3LjAsIm1vZFBoYXNlVmFsdWU2IjoxLjAsIm1vZFBoYXNlVmFsdWU3IjotMjcuMCwibW9kUGhhc2VWYWx1ZTgiOjEwLjAsIm1vZFBoYXNlVmFsdWU5Ijo4LjAsIm1vZFJhbmRvbSI6NjEuMCwibW9kUmFuZG9tRGVsYXkiOjAuMCwibW9kU3dpdGNoRGVsYXkiOjEuMCwicmFuZFR5cGUiOiJkZWxheSIsInJhbmRvbWl6ZUppdHRlckRpcmVjdGlvbiI6dHJ1ZSwicmFuZG9taXplSml0dGVyTWFnbml0dWRlIjozNS4wLCJyYW5kb21pemVSb3RhdGlvbk9yZGVyIjpmYWxzZSwic21vb3RoVHJhbnNpdGlvbiI6dHJ1ZSwic21vb3RoaW5nRmFjdG9yIjo1MC4wLCJ3YXZlQW1wbGl0dWRlIjoxMS4wLCJ3YXZlRm9ybSI6IlNpbmUiLCJ3YXZlRnJlcXVlbmN5IjoxLjAsIndhdmVPZmZzZXQiOjIxLjB9LCJ+eWF3VHlwZSI6eyJib21iYUJ1cnN0Q2hhbmNlIjo0NC4wLCJib21iYUJ1cnN0RHVyYXRpb24iOjEyOS4wLCJib21iYUJ1cnN0RW5hYmxlIjp0cnVlLCJib21iYUJ1cnN0TXVsdGlwbGllciI6OTEuMCwiYm9tYmFDaGFvc0ZhY3RvciI6NDAuMCwiYm9tYmFNYXhEZWxheSI6Ny4wLCJib21iYU1pbkRlbGF5IjoyLjAsImJvbWJhUmFuZG9tRmFjdG9yIjo2NS4wLCJib21iYVNtb290aG5lc3MiOjcwLjAsImRlbGF5SG9sZEN5Y2xlcyI6MC4wLCJkZWxheUhvbGRUaWNrcyI6MC4wLCJkZWxheVBoYXNlQ291bnQiOjEyLjAsImRlbGF5UGhhc2VTcGVlZCI6MjguMCwiZGVsYXlQaGFzZVZhbHVlMSI6MTAuMCwiZGVsYXlQaGFzZVZhbHVlMTAiOjcuMCwiZGVsYXlQaGFzZVZhbHVlMTEiOjIuMCwiZGVsYXlQaGFzZVZhbHVlMTIiOjEyLjAsImRlbGF5UGhhc2VWYWx1ZTIiOjcuMCwiZGVsYXlQaGFzZVZhbHVlMyI6Ni4wLCJkZWxheVBoYXNlVmFsdWU0IjoxMi4wLCJkZWxheVBoYXNlVmFsdWU1IjoxMy4wLCJkZWxheVBoYXNlVmFsdWU2IjoxNi4wLCJkZWxheVBoYXNlVmFsdWU3IjoxMC4wLCJkZWxheVBoYXNlVmFsdWU4IjoxNS4wLCJkZWxheVBoYXNlVmFsdWU5IjoxMC4wLCJkZWxheVJhbmRvbURlbGF5Rm9yU3dpdGNoIjowLjAsImRlbGF5UmFuZG9tRnJvbSI6NC4wLCJkZWxheVJhbmRvbVNwZWVkIjoyOC4wLCJkZWxheVJhbmRvbVRvIjoyNS4wLCJkZWxheVJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOnRydWUsImRlbGF5U3dpdGNoRGVsYXkiOjAuMCwiZGVsYXlUeXBlIjoiUGhhc2UiLCJoYXJtb25pY0FtcGxpdHVkZSI6MjcuMCwiaGFybW9uaWNCYXNlRGVsYXkiOjEzLjAsImhhcm1vbmljRnJlcXVlbmN5IjoxMS4wLCJoYXJtb25pY1BoYXNlT2Zmc2V0IjozOC4wLCJoYXJtb25pY1dhdmVmb3JtIjoiU2luZSJ9fSwic3RhbmQiOnsiYW50aUJydXRlZm9yY2UiOnRydWUsImJvZHlGUyI6Ik9mZiIsImJvZHlZYXciOnRydWUsImRlbGF5X3RpY2tzIjo0MC4wLCJsZWZ0TGltaXQiOjU4LjAsImxlZnRZYXdPZmZzZXQiOi0xNi4wLCJtb2RpZmllciI6IlJhbmRvbSIsInJpZ2h0TGltaXQiOjU4LjAsInJpZ2h0WWF3T2Zmc2V0IjoyNS4wLCJ5YXdPZmZzZXQiOjAuMCwieWF3VHlwZSI6ImwvciIsIn5hbnRpQnJ1dGVmb3JjZSI6eyJhYkN1c3RvbVBoYXNlQ291bnQiOjcuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDEiOi05LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUwyIjotMTUuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDMiOi0xMy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNCI6MTQuMCwiYWJDdXN0b21QaGFzZVZhbHVlTDUiOi0xMi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVMNiI6LTEwLjAsImFiQ3VzdG9tUGhhc2VWYWx1ZUw3IjotNy4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSMSI6MTIuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjIiOjE2LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVIzIjoxMS4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNCI6MTUuMCwiYWJDdXN0b21QaGFzZVZhbHVlUjUiOjE3LjAsImFiQ3VzdG9tUGhhc2VWYWx1ZVI2IjoxMi4wLCJhYkN1c3RvbVBoYXNlVmFsdWVSNyI6OS4wLCJhYkN1c3RvbVJhbmRvbWl6ZU9yZGVyIjp0cnVlLCJhbnRpQnJ1dGVmb3JjZUluZGljYXRpb24iOnRydWUsImFudGlCcnV0ZWZvcmNlTW9kZSI6ImN1c3RvbSIsImFudGlCcnV0ZWZvcmNlUmVzZXQiOnRydWUsImFudGlCcnV0ZWZvcmNlVHlwZSI6ImwvciBhZGRzIn0sIn5ib2R5WWF3Ijp7ImRlc3luY09wdGlvbiI6IkRlZmF1bHQiLCJyb3RhdGlvblNwZWVkIjo1MC4wLCJzcGVlZE9wdGlvbiI6IkNvbnN0YW50In0sIn5tb2RpZmllciI6eyJhbHBodkJhc2VEZWxheSI6My4wLCJhbHBodkJhc2VIb2xkIjoxLjAsImFscGh2RmxpY2tDaGFuY2UiOjMuMCwiYWxwaHZGbGlja0NoYW5jZVBlclBoYXNlIjoxMDAuMCwiYWxwaHZGbGlja01heCI6NDIuMCwiYWxwaHZGbGlja01pbiI6LTQ4LjAsImFscGh2RmxpY2tSYW5nZVBlclBoYXNlIjoxNC4wLCJhbHBodlBoYXNlQ291bnQiOjEyLjAsImFscGh2UGhhc2VTcGVlZCI6MTAwLjAsImFscGh2UGhhc2VWYWx1ZTEiOjQxLjAsImFscGh2UGhhc2VWYWx1ZTEwIjowLjAsImFscGh2UGhhc2VWYWx1ZTExIjowLjAsImFscGh2UGhhc2VWYWx1ZTEyIjowLjAsImFscGh2UGhhc2VWYWx1ZTIiOjEwLjAsImFscGh2UGhhc2VWYWx1ZTMiOjI1LjAsImFscGh2UGhhc2VWYWx1ZTQiOjM4LjAsImFscGh2UGhhc2VWYWx1ZTUiOi00MS4wLCJhbHBodlBoYXNlVmFsdWU2Ijo0NC4wLCJhbHBodlBoYXNlVmFsdWU3Ijo0OS4wLCJhbHBodlBoYXNlVmFsdWU4IjotNi4wLCJhbHBodlBoYXNlVmFsdWU5IjoxMi4wLCJhbHBodlJhbmRvbURlbGF5IjozLjAsImFscGh2UmFuZG9tSG9sZCI6Mi4wLCJhbHBodlJhbmRvbWl6ZVBoYXNlT3JkZXIiOmZhbHNlLCJhbHBodlNwZWVkIjoxMDAuMCwiYnVyc3RDaGFuY2UiOjUwLjAsImJ1cnN0RHVyYXRpb24iOjEwLjAsImJ1cnN0TXVsdGlwbGllciI6MS4wLCJidXJzdFJhbmRvbUZhY3RvciI6MjAuMCwiY29uc3RhbnRKaXR0ZXIiOmZhbHNlLCJqaXR0ZXJNYWduaXR1ZGUiOjQ1LjAsImppdHRlclR5cGUiOiJSYW5kb20iLCJtYXhKaXR0ZXJEZWxheSI6MTUuMCwibWluSml0dGVyRGVsYXkiOjUuMCwibW9kSG9sZEN5Y2xlcyI6MC4wLCJtb2RIb2xkVGlja3MiOjEuMCwibW9kT2Zmc2V0IjotMTkuMCwibW9kUGhhc2VDb3VudCI6OS4wLCJtb2RQaGFzZVNwZWVkIjoxMDAuMCwibW9kUGhhc2VWYWx1ZTEiOjQxLjAsIm1vZFBoYXNlVmFsdWUxMCI6MC4wLCJtb2RQaGFzZVZhbHVlMTEiOjAuMCwibW9kUGhhc2VWYWx1ZTEyIjowLjAsIm1vZFBoYXNlVmFsdWUyIjoxMC4wLCJtb2RQaGFzZVZhbHVlMyI6MjUuMCwibW9kUGhhc2VWYWx1ZTQiOjM4LjAsIm1vZFBoYXNlVmFsdWU1IjotNDEuMCwibW9kUGhhc2VWYWx1ZTYiOjQ0LjAsIm1vZFBoYXNlVmFsdWU3Ijo0OS4wLCJtb2RQaGFzZVZhbHVlOCI6LTYuMCwibW9kUGhhc2VWYWx1ZTkiOjEyLjAsIm1vZFJhbmRvbSI6MC4wLCJtb2RSYW5kb21EZWxheSI6My4wLCJtb2RTd2l0Y2hEZWxheSI6MS4wLCJyYW5kVHlwZSI6ImRlbGF5IiwicmFuZG9taXplSml0dGVyRGlyZWN0aW9uIjpmYWxzZSwicmFuZG9taXplSml0dGVyTWFnbml0dWRlIjowLjAsInJhbmRvbWl6ZVJvdGF0aW9uT3JkZXIiOnRydWUsInNtb290aFRyYW5zaXRpb24iOnRydWUsInNtb290aGluZ0ZhY3RvciI6NTAuMCwid2F2ZUFtcGxpdHVkZSI6NDUuMCwid2F2ZUZvcm0iOiJTaW5lIiwid2F2ZUZyZXF1ZW5jeSI6MS4wLCJ3YXZlT2Zmc2V0IjowLjB9LCJ+eWF3VHlwZSI6eyJib21iYUJ1cnN0Q2hhbmNlIjoxNi4wLCJib21iYUJ1cnN0RHVyYXRpb24iOjE4MC4wLCJib21iYUJ1cnN0RW5hYmxlIjp0cnVlLCJib21iYUJ1cnN0TXVsdGlwbGllciI6OTIuMCwiYm9tYmFDaGFvc0ZhY3RvciI6OTUuMCwiYm9tYmFNYXhEZWxheSI6MTIuMCwiYm9tYmFNaW5EZWxheSI6MS4wLCJib21iYVJhbmRvbUZhY3RvciI6NzMuMCwiYm9tYmFTbW9vdGhuZXNzIjo1NC4wLCJkZWxheUhvbGRDeWNsZXMiOjAuMCwiZGVsYXlIb2xkVGlja3MiOjAuMCwiZGVsYXlQaGFzZUNvdW50IjoxMS4wLCJkZWxheVBoYXNlU3BlZWQiOjU0LjAsImRlbGF5UGhhc2VWYWx1ZTEiOjguMCwiZGVsYXlQaGFzZVZhbHVlMTAiOjEzLjAsImRlbGF5UGhhc2VWYWx1ZTExIjoxMy4wLCJkZWxheVBoYXNlVmFsdWUxMiI6NDAuMCwiZGVsYXlQaGFzZVZhbHVlMiI6NS4wLCJkZWxheVBoYXNlVmFsdWUzIjoyLjAsImRlbGF5UGhhc2VWYWx1ZTQiOjE1LjAsImRlbGF5UGhhc2VWYWx1ZTUiOjE2LjAsImRlbGF5UGhhc2VWYWx1ZTYiOjEwLjAsImRlbGF5UGhhc2VWYWx1ZTciOjEyLjAsImRlbGF5UGhhc2VWYWx1ZTgiOjQuMCwiZGVsYXlQaGFzZVZhbHVlOSI6MTcuMCwiZGVsYXlSYW5kb21EZWxheUZvclN3aXRjaCI6MC4wLCJkZWxheVJhbmRvbUZyb20iOjAuMCwiZGVsYXlSYW5kb21TcGVlZCI6NTQuMCwiZGVsYXlSYW5kb21UbyI6MTUuMCwiZGVsYXlSYW5kb21pemVSb3RhdGlvbk9yZGVyIjp0cnVlLCJkZWxheVN3aXRjaERlbGF5IjowLjAsImRlbGF5VHlwZSI6Ikhhcm1vbmljIFBhdHRlcm4iLCJoYXJtb25pY0FtcGxpdHVkZSI6MTMuMCwiaGFybW9uaWNCYXNlRGVsYXkiOjEzLjAsImhhcm1vbmljRnJlcXVlbmN5Ijo1Ni4wLCJoYXJtb25pY1BoYXNlT2Zmc2V0Ijo0My4wLCJoYXJtb25pY1dhdmVmb3JtIjoiU2luZSJ9fX19LCJzZWxlY3RvciI6NS4wLCJ0ZWFtX3NlbGVjdG9yIjoiVCJ9LCJjb25maWciOnsiY29uZmlnTGlzdCI6Mi4wLCJjb25maWdOYW1lSW5wdXQiOiJib2JybyJ9LCJ1dGlsaXR5X2dyb3VwXzEiOnsiYXV0b0Rpc2Nvbm5lY3QiOmZhbHNlLCJjbGVhckNvbnNvbGUiOmZhbHNlfSwidXRpbGl0eV9ncm91cF8yIjp7ImFuaW1CcmVha2VycyI6dHJ1ZSwiZmFzdExhZGRlciI6dHJ1ZSwiZnBzQm9vc3QiOnRydWUsIm5vRmFsbERtZyI6ZmFsc2UsInN1cGVyVG9zcyI6dHJ1ZSwifmFuaW1CcmVha2VycyI6eyJhbmltQWlyIjoiU3RhdGljIiwiYW5pbUdyb3VuZCI6IkRpc2FibGVkIiwiYW5pbUdyb3VuZEFtb3VudCI6ODAuMCwiYW5pbU90aGVyIjpbIk1vdmUgTGVhbiIsIn4iXSwiYW5pbU90aGVyTGVhbiI6NzUuMH0sIn5mcHNCb29zdCI6eyJmcHNCb29zdE9wdGlvbnMiOjEuMH19LCJ1dGlsaXR5X2dyb3VwXzMiOnsiYWlybGFnIjpmYWxzZSwiYXNwZWN0UmF0aW8iOnRydWUsImNsYW50YWciOnRydWUsImNvbnNvbGVfbG9ncyI6ZmFsc2UsImRtZ0luZGljYXRvciI6ZmFsc2UsImhpdG1hcmtlciI6ZmFsc2UsImxvZ3MiOnRydWUsInZpZXdtb2RlbCI6dHJ1ZSwifmFpcmxhZyI6eyJhaXJsYWdUaWNrcyI6MC4wfSwifmFzcGVjdFJhdGlvIjp7ImFzcGVjdFJhdGlvVmFsdWUiOjExLjB9LCJ+Y29uc29sZV9sb2dzIjp7ImJ1eV9sb2dzIjp0cnVlLCJoaXRfbG9ncyI6ZmFsc2V9LCJ+ZG1nSW5kaWNhdG9yIjp7ImNvbG9yIjoiI0ZGRkZGRkZGIiwiZm9udCI6IkRlZmF1bHQiLCJ4IjowLjAsInkiOjAuMH0sIn5sb2dzIjp7ImJhY2tncm91bmQiOnRydWUsImJhY2tncm91bmRfY29sb3IiOiIjMDAwMDAwRTYiLCJjdXN0b21fYmFja2dyb3VuZF9jb2xvciI6ZmFsc2UsImN1c3RvbV9jb2xvciI6dHJ1ZSwiZmFkZV9hbmltYXRpb25fdHlwZSI6Imluc3RhbnQiLCJmaXJzdF9jb2xvciI6IiNBNzhEOUZGRiIsImdsb3dfY29sb3IiOiIjQTc4RDlGRkYiLCJnbG93X3N0cmVuZ3RoIjo1MC4wLCJoaXRfY29sb3IiOiIjQTc4RDlGRkYiLCJsaW1pdCI6Ni4wLCJtaXNzX2NvbG9yIjoiI0E3OEQ4REZGIiwib2Zmc2V0IjoyMDAuMCwicHJlZml4X3R5cGUiOiJncmFkaWVudCIsInNlY29uZF9jb2xvciI6IiNCMjk4QUFGRiIsInNob3dfYXZhdGFyX2ljb24iOmZhbHNlLCJ0aW1lIjozLjB9LCJ+dmlld21vZGVsIjp7ImZpZWxkT2ZWaWV3Ijo2Mi4wLCJvZmZzZXRYIjotOS4wLCJvZmZzZXRZIjotMTIuMCwib2Zmc2V0WiI6MTIuMH19fQ=="

    local defaultConfig = {
        cfgName = {"Default"},
        Default = default_config_base64_string
    }

    files.write(filePath, json.stringify(defaultConfig))
    configsData = defaultConfig
else
    configsData = json.parse(configsData)
end

local groups = {
    config = pui.create("main", "config system", 1),
    info = ui.create("main", "shadowyaw", 2),
    states = pui.create("anti aim", "states", 0),
    antiaim = pui.create("anti aim", "main", 1),
    builder = pui.create("anti aim", "builder", 2),
    
    utility_group_1 = pui.create("utility", "$", 0),
    utility_group_2 = pui.create("utility", "$$", 1),
    utility_group_3 = pui.create("utility", "$$$", 2),
}

local menuInfo = {
    [1] = "      welcome, ".. common.get_username(),
    [2] = "build: nightly",
	[3] = "version: 1.0" 
}

local states = {
    {"stand", "standing"},
    {"run", "moving"},
    {"slow", "slow motion"},
    {"air", "air"},
    {"airCrouch", "air crouching"},
    {"crouch", "crouching"},
    {"sneak", "sneaking"}
}

local stateNames = {} for i, v in ipairs(states) do stateNames[i] = v[2] end

local SHADOWYAW_COLOR = color(255, 135, 153)
local WHITE_COLOR = color(235, 135, 153)
local animated_sidebar_text = gradient.text_animate("shadowyaw", -3, {
    SHADOWYAW_COLOR,
    WHITE_COLOR
})

ui.sidebar(animated_sidebar_text:get_animated_text(), "crown")

local menu = {
    ["information"] = {
        groups.info:label(menuInfo[1]),

        groups.info:button("              \a7E92FFFF          "..ui.get_icon('discord').."                          ",function()
            panorama.SteamOverlayAPI.OpenExternalBrowserURL("https://discord.gg/775")
        end, true),
        groups.info:button("       \aFF1D1DFF                 "..ui.get_icon('youtube').."                          ",function()
            panorama.SteamOverlayAPI.OpenExternalBrowserURL("https://youtube.com/@shadow_hvh")
        end, true),
        groups.info:button("               \a7E92FFFF          "..ui.get_icon('gear').."                          ",function()
            panorama.SteamOverlayAPI.OpenExternalBrowserURL("https://en.neverlose.cc/market/item?id=9n02XS")
        end, true),
		
        groups.info:label(menuInfo[2]), 
	    groups.info:label(menuInfo[3]),


    },
    ["anti aim"] = {
        pitch = groups.antiaim:combo("pitch", refs.pitch:list(), 3),
        yawBase = groups.antiaim:combo("yaw base", {"off", "At Target", "Forward", "Left", "Right"}, 2),
        freestanding = groups.antiaim:switch("freestanding", false, nil, function(gear)
            return {
                disableModifiers = gear:switch("disable yaw modifiers"),
                bodyFreestand = gear:switch("body freestanding")
            }
        end),
        anti_backstab = groups.antiaim:switch("anti-backstab"),
        safe_head_on_knife = groups.antiaim:switch("safe head (knife/zeus)")
    },
    ["anti aim states"] = {
        team_selector = groups.states:combo(gradient.text_animate("team", 0, {color(161, 135, 153), color(161, 135, 153)}):get_animated_text(), {"CT", "T"}),
        selector = groups.states:list("states", stateNames),
        cache = { 
            ct = {}, 
            t = {}   
        }
    },
    ["config"] = {
        configList = groups.config:list("", configsData.cfgName),
        configNameInput = groups.config:input("enter config name:", ""),
        loadConfigButton = groups.config:button("load"),
        saveConfigButton = groups.config:button("save"),
        deleteConfigButton = groups.config:button("delete"),
        exportConfigButton = groups.config:button("export"),
        importConfigButton = groups.config:button("import"),
    },
    ["utility_group_1"] = { 
        autoDisconnect = groups.utility_group_1:switch("auto disconnect on match end"),
        clearConsole = groups.utility_group_1:switch("clear console on round end"),
    },
    ["utility_group_2"] = {
        fastLadder = groups.utility_group_2:switch("fast ladder"),
        fpsBoost = groups.utility_group_2:switch("fps boost", false, nil, function(gear)
            return {
                fpsBoostOptions = gear:list("select option", {"low", "medium", "high"})
            }
        end),
        superToss = groups.utility_group_2:switch("super toss"),
        noFallDmg = groups.utility_group_2:switch('no fall dmg'),
        animBreakers = groups.utility_group_2:switch("anim breakers", false, nil, function(gear)
            return {
                animGround = gear:combo('on ground', {'Disabled', 'Static', 'Sliding', 'Moonwalk', 'Jitter', 'Other Jitter'}),
                animGroundAmount = gear:slider('jitter amount', 0, 100, 80),
                animAir = gear:combo('in air', {'Disabled', 'Static', 'Moonwalk', 'Jitter', 'Other Jitter', 'Flying'}),
                animOther = gear:selectable('other', {'Zero Pitch On Land', 'Move Lean', 'EarthQuake'}),
                animOtherLean = gear:slider('move lean amount', 0, 100, 100),
            }
        end),
    },
    ["utility_group_3"] = { 
        logs = groups.utility_group_3:switch( 'aimbot logs', false, nil, function( gear ) 
            local limit = gear:slider( 'limit', 1, 20, 6 ) 
            local time = gear:slider( 'time', 1, 20, 6 ) 

            local offset = gear:slider( 'offset', 0, 500, 200 ) 

            local background = gear:switch( 'background', true ) 

            local glow_strength = gear:slider( 'glow strength', 0, 255, 50 ) 
            local glow_color_picker = gear:color_picker( 'glow color', color( 'A78D9FFF' ) ) 

            local show_avatar_icon = gear:switch( 'show avatar icon', false ) 

            local fade_animation_type = gear:combo('fade animation', {'instant', 'animated'}, 1) 

            local prefix_type = gear:combo( 'prefix color' , {'gradient'}, 1 ) 
            local first_color = gear:color_picker( 'first color', color( 'A78D9FFF' ) ) 
            local second_color = gear:color_picker( 'second color', color( 'B298AAFF' ) ); 

            local custom_color = gear:switch( 'custom color', true ) 

            local hit_color = gear:color_picker( 'hit color', color( 'A78D9FFF' ) ); hit_color:depend( custom_color ) 
            local miss_color = gear:color_picker( 'miss color', color( 'A78D8DFF' ) ); miss_color:depend( custom_color ) 

            local custom_background_color_switch = gear:switch( 'custom background color', false )
            local background_color_picker = gear:color_picker( 'background color', color(0, 0, 0, 230) ) 
            background_color_picker:depend( custom_background_color_switch )

            return {
                limit = limit,
                time = time,
                offset = offset,
                background = background,
                glow_strength = glow_strength, 
                glow_color = glow_color_picker,
                show_avatar_icon = show_avatar_icon, 
                fade_animation_type = fade_animation_type,
                custom_color = custom_color,
                hit_color = hit_color,
                miss_color = miss_color,
                prefix_type = prefix_type,
                first_color = first_color,
                second_color = second_color,
                custom_background_color = custom_background_color_switch,
                background_color = background_color_picker
            }, true
        end ),

        console_logs = groups.utility_group_3:switch( 'console logs', false, nil, function( gear ) 
            local buy_logs = gear:switch( 'buy logs', true ) 
            local hit_logs = gear:switch( 'hit logs', true ) 

            return {
                buy_logs = buy_logs,
                hit_logs = hit_logs,
            }, true
        end),

        viewmodel = groups.utility_group_3:switch("viewmodel", false, nil, function(gear)
            return {
                fieldOfView = gear:slider("field of view", -100, 100, 60),
                offsetX = gear:slider("offset x", -150, 150, 20, 0.1),
                offsetY = gear:slider("offset y", -150, 150, 10, 0.1),
                offsetZ = gear:slider("offset z", -150, 150, 40, 0.1),
            }
        end),
        aspectRatio = groups.utility_group_3:switch("aspect ratio", false, nil, function(gear)
            return {
                aspectRatioValue = gear:slider("aspect ratio", 0, 20, 0, 0.1),
                aspectRatio4_3Button = gear:button("4:3"),
                aspectRatio16_9Button = gear:button("16:9"),
                aspectRatio16_10Button = gear:button("16:10"),
                aspectRatio21_9Button = gear:button("21:9")
            }
        end),
        airlag = groups.utility_group_3:switch('airlag', false, nil, function(gear)
            return {
                airlagTicks = gear:slider('Ticks', 0, 10, 0)
            }
        end),
        clantag = groups.utility_group_3:switch('clantag'),
        hitmarker = groups.utility_group_3:switch("hitmarker"),
        dmgIndicator = groups.utility_group_3:switch("world dmg indicator", false, nil, function(gear)
            return {
                x = gear:slider("x", -400, 400, 0),
                y = gear:slider("y", -400, 400, 0),
                color = gear:color_picker("accent color", color(255,255,255,255)),
                font = gear:combo("font", {"Default", "Small", "Console", "Bold"}),
            }
        end),
    },
}

Utility.copyStateSettings = function(sourceTeamPrefix, destTeamPrefix, stateIdx)
    local stateKey = states[stateIdx][1] 
    local sourceCtx = menu["anti aim states"].cache[sourceTeamPrefix][stateKey]
    local destCtx = menu["anti aim states"].cache[destTeamPrefix][stateKey]

    if not sourceCtx or not destCtx then
        print_raw(Utility.color_text({"Error: Source or destination state context not found for copying.", "FF0000FF"}))
        return
    end

    local directKeysToCopy = {
        "yawType", "yawOffset", "leftYawOffset", "rightYawOffset", 
        "delay_ticks", 
        "bodyYaw", 
        "leftLimit", "rightLimit", "bodyFS",
        "modifier", 
        "antiBruteforce",
        "anti_backstab"
    }
    
    for _, key in ipairs(directKeysToCopy) do
        if sourceCtx[key] and destCtx[key] then
            local value_to_copy = sourceCtx[key]:get()
            if value_to_copy ~= nil then
                local success, err = pcall(destCtx[key].set, destCtx[key], value_to_copy)
                if not success then print("Error setting direct key " .. key .. ": " .. err) end
            end
        end
    end

    local yawTypeGearKeys = {
        "delayType", "delayHoldTicks", "delayHoldCycles", "delaySwitchDelay",
        "delayRandomDelayForSwitch", "delayRandomFrom", "delayRandomTo", "delayRandomSpeed", 
        "delayPhaseCount", "delayPhaseSpeed", "delayRandomizeRotationOrder",
        "bombaMinDelay", "bombaMaxDelay", "bombaRandomFactor", "bombaSmoothness",
        "bombaBurstEnable", "bombaBurstChance", "bombaBurstDuration", "bombaBurstMultiplier",
        "bombaChaosFactor",
        "harmonicBaseDelay", "harmonicAmplitude", "harmonicFrequency", "harmonicWaveform", "harmonicPhaseOffset"
    }
    if sourceCtx.yawType and destCtx.yawType then
        for _, key in ipairs(yawTypeGearKeys) do
            if sourceCtx.yawType[key] and destCtx.yawType[key] then
                local value_to_copy = sourceCtx.yawType[key]:get()
                if value_to_copy ~= nil then
                    local success, err = pcall(destCtx.yawType[key].set, destCtx.yawType[key], value_to_copy)
                    if not success then print("Error setting yawType gear key " .. key .. ": " .. err) end
                end
            end
        end
        for i = 1, 12 do
            local phase_value_key = "delayPhaseValue" .. i
            if sourceCtx.yawType[phase_value_key] and destCtx.yawType[phase_value_key] then
                local value_to_copy = sourceCtx.yawType[phase_value_key]:get()
                if value_to_copy ~= nil then
                    local success, err = pcall(destCtx.yawType[phase_value_key].set, destCtx.yawType[phase_value_key], value_to_copy)
                    if not success then print("Error setting yawType phase value " .. i .. ": " .. err) end
                end
            end
        end
    end

    local modifierGearKeys = {
        "randType", "modOffset", "modRandom", "modHoldTicks", "modHoldCycles", 
        "modSwitchDelay", "modRandomDelay", "modPhaseCount", "modPhaseSpeed", 
        "randomizeRotationOrder",
        "alphvSpeed", "alphvFlickChance", "alphvFlickMin", "alphvFlickMax", 
        "alphvBaseHold", "alphvRandomHold", "alphvBaseDelay", "alphvRandomDelay",
        "alphvPhaseCount", "alphvFlickChancePerPhase", "alphvFlickRangePerPhase",
        "alphvRandomizePhaseOrder", "alphvPhaseSpeed",
        "jitterType", "jitterMagnitude", "minJitterDelay", "maxJitterDelay", "smoothingFactor",
        "waveAmplitude", "waveFrequency", "waveOffset", "waveForm",
        "burstChance", "burstDuration", "burstMultiplier", "burstRandomFactor",
        "randomizeJitterDirection", "randomizeJitterMagnitude",
        "smoothTransition", "constantJitter"
    }
    if sourceCtx.modifier and destCtx.modifier then
        for _, key in ipairs(modifierGearKeys) do
            if sourceCtx.modifier[key] and destCtx.modifier[key] then
                local value_to_copy = sourceCtx.modifier[key]:get()
                if value_to_copy ~= nil then
                    local success, err = pcall(destCtx.modifier[key].set, destCtx.modifier[key], value_to_copy)
                    if not success then print("Error setting modifier gear key " .. key .. ": " .. err) end
                end
            end
        end
        for i = 1, 12 do
            local phase_value_key = "modPhaseValue" .. i
            if sourceCtx.modifier[phase_value_key] and destCtx.modifier[phase_value_key] then
                local value_to_copy = sourceCtx.modifier[phase_value_key]:get()
                if value_to_copy ~= nil then
                    local success, err = pcall(destCtx.modifier[phase_value_key].set, destCtx.modifier[phase_value_key], value_to_copy)
                    if not success then print("Error setting modifier phase value " .. i .. ": " .. err) end
                end
            end
        end
        for i = 1, 12 do
            local phase_value_key = "alphvPhaseValue" .. i
            if sourceCtx.modifier[phase_value_key] and destCtx.modifier[phase_value_key] then
                local value_to_copy = sourceCtx.modifier[phase_value_key]:get()
                if value_to_copy ~= nil then
                    local success, err = pcall(destCtx.modifier[phase_value_key].set, destCtx.modifier[phase_value_key], value_to_copy)
                    if not success then print("Error setting ALPHV phase value " .. i .. ": " .. err) end
                end
            end
        end
    end

    local antiBruteforceGearKeys = {
        "antiBruteforceType", "antiBruteforceMode", "antiBruteforceReset", "antiBruteforceIndication",
        "abCustomPhaseCount", "abCustomRandomizeOrder",
    }
    if sourceCtx.antiBruteforce and destCtx.antiBruteforce then
        for _, key in ipairs(antiBruteforceGearKeys) do
            if sourceCtx.antiBruteforce[key] and destCtx.antiBruteforce[key] then
                local value_to_copy = sourceCtx.antiBruteforce[key]:get()
                if value_to_copy ~= nil then
                    local success, err = pcall(destCtx.antiBruteforce[key].set, destCtx.antiBruteforce[key], value_to_copy)
                    if not success then print("Error setting AB gear key " .. key .. ": " .. err) end
                end
            end
        end
        for i = 1, 7 do
            local phase_value_key_L = "abCustomPhaseValueL" .. i
            local phase_value_key_R = "abCustomPhaseValueR" .. i
            if sourceCtx.antiBruteforce[phase_value_key_L] and destCtx.antiBruteforce[phase_value_key_L] then
                local value_to_copy = sourceCtx.antiBruteforce[phase_value_key_L]:get()
                if value_to_copy ~= nil then
                    local success, err = pcall(destCtx.antiBruteforce[phase_value_key_L].set, destCtx.antiBruteforce[phase_value_key_L], value_to_copy)
                    if not success then print("Error setting AB L phase " .. i .. ": " .. err) end
                end
            end
            if sourceCtx.antiBruteforce[phase_value_key_R] and destCtx.antiBruteforce[phase_value_key_R] then
                local value_to_copy = sourceCtx.antiBruteforce[phase_value_key_R]:get()
                if value_to_copy ~= nil then
                    local success, err = pcall(destCtx.antiBruteforce[phase_value_key_R].set, destCtx.antiBruteforce[phase_value_key_R], value_to_copy)
                    if not success then print("Error setting AB R phase " .. i .. ": " .. err) end
                end
            end
        end
    end

    if sourceCtx.bodyYaw and destCtx.bodyYaw then
        if sourceCtx.bodyYaw.desyncOption and destCtx.bodyYaw.desyncOption then
            local value_to_copy = sourceCtx.bodyYaw.desyncOption:get()
            if value_to_copy ~= nil then
                local success, err = pcall(destCtx.bodyYaw.desyncOption.set, destCtx.bodyYaw.desyncOption, value_to_copy)
                if not success then print("Error setting bodyYaw desyncOption: " .. err) end
            end
        end
        if sourceCtx.bodyYaw.speedOption and destCtx.bodyYaw.speedOption then
            local value_to_copy = sourceCtx.bodyYaw.speedOption:get()
            if value_to_copy ~= nil then
                local success, err = pcall(destCtx.bodyYaw.speedOption.set, destCtx.bodyYaw.speedOption, value_to_copy)
                if not success then print("Error setting bodyYaw speedOption: " .. err) end
            end
        end
        if sourceCtx.bodyYaw.rotationSpeed and destCtx.bodyYaw.rotationSpeed then
            local value_to_copy = sourceCtx.bodyYaw.rotationSpeed:get()
            if value_to_copy ~= nil then
                local success, err = pcall(destCtx.bodyYaw.rotationSpeed.set, destCtx.bodyYaw.rotationSpeed, value_to_copy)
                if not success then print("Error setting bodyYaw rotationSpeed: " .. err) end
            end
        end
    end

    print_raw(Utility.color_text({"Copied ", SHADOWYAW_COLOR_HEX}) .. 
             Utility.color_text({states[stateIdx][2] .. " settings from ", "FFFFFFFF"}) .. 
             Utility.color_text({sourceTeamPrefix:upper() .. " to " .. destTeamPrefix:upper() .. "!", SHADOWYAW_COLOR_HEX}))
end

local function randomize_func(original_value, percent)
    local min_range = original_value - (original_value * percent / 100)
    local max_range = original_value + (original_value * percent / 100)
    return math.random(min_range, max_range)
end

Utility.createCtx = function(state_idx_in_list, builder, team_prefix)
    local ctx = {
        yawType = builder:combo("yaw type", {"l/r"}, nil, function(gear)
            local delayTypeCombo = gear:combo("delay type", {"Switch", "Random", "Phase", "Bomba", "Harmonic Pattern"})
            
            local holdTicksSlider = gear:slider("hold ticks", 0, 10, 0)
            local holdCyclesSlider = gear:slider("hold cycles", 0, 30, 0)
            local switchDelaySlider = gear:slider("switch delay", 0, 100, 0)
            local randomDelayForSwitchSlider = gear:slider("random delay", 0, 50, 0)

            local randomFromSlider = gear:slider("random from", 0, 100, 0)
            local randomToSlider = gear:slider("random to", 0, 100, 50)
            local randomSpeedSlider = gear:slider("rotation speed", 1, 100, 50)

            local phaseCountSlider = gear:slider("phases", 1, 12, 1)
            local phaseSpeedSlider = gear:slider("rotation speed", 1, 100, 50)
            
            local phaseValueSliders = {}
            for i = 1, 12 do
                phaseValueSliders[i] = gear:slider("[" .. i .. "]", 1, 100, 40)
            end

            local randomizeRotationOrderDelaySwitch = gear:switch("randomize rotation order") 
            local generateRandomDelayPhaseValuesButton = gear:button("generate random values")


            local bombaMinDelaySlider = gear:slider("min delay", 1, 200, 20)
            local bombaMaxDelaySlider = gear:slider("max delay", 1, 200, 80)
            local bombaRandomFactorSlider = gear:slider("random factor", 0, 100, 50, 1, "%")
            local bombaSmoothnessSlider = gear:slider("smoothness", 1, 100, 70)
            local bombaBurstEnableSwitch = gear:switch("burst enable", false)
            local bombaBurstChanceSlider = gear:slider("burst chance", 0, 100, 30, 1, "%")
            local bombaBurstDurationSlider = gear:slider("burst duration", 1, 500, 100)
            local bombaBurstMultiplierSlider = gear:slider("burst multiplier", 1, 1000, 200, 1, "%")
            local bombaChaosFactorSlider = gear:slider("chaos factor", 0, 100, 10, 1, "%")

            local harmonicBaseDelaySlider = gear:slider("base delay", 1, 200, 50)
            local harmonicAmplitudeSlider = gear:slider("amplitude", 0, 100, 20)
            local harmonicFrequencySlider = gear:slider("frequency", 1, 100, 50, 0.01)
            local harmonicWaveformCombo = gear:combo("waveform", {"Sine", "Cosine", "Sawtooth", "Triangle"})
            local harmonicPhaseOffsetSlider = gear:slider("phase offset", 0, 360, 0)

            holdTicksSlider:depend({delayTypeCombo, "Switch"})
            holdCyclesSlider:depend({delayTypeCombo, "Switch"})
            switchDelaySlider:depend({delayTypeCombo, "Switch"})
            randomDelayForSwitchSlider:depend({delayTypeCombo, "Switch"})

            randomFromSlider:depend({delayTypeCombo, "Random"})
            randomToSlider:depend({delayTypeCombo, "Random"})
            randomSpeedSlider:depend({delayTypeCombo, "Random"})

            phaseCountSlider:depend({delayTypeCombo, "Phase"})
            phaseSpeedSlider:depend({delayTypeCombo, "Phase"})
            
            for i = 1, 12 do
                local phase_value_slider = phaseValueSliders[i]
                if phase_value_slider then
                    phase_value_slider:depend({delayTypeCombo, "Phase"}, {phaseCountSlider, function(item) return i <= item:get() end})
                end
            end
            
            randomizeRotationOrderDelaySwitch:depend({delayTypeCombo, "Phase"})
            generateRandomDelayPhaseValuesButton:depend({delayTypeCombo, "Phase"})

            generateRandomDelayPhaseValuesButton:set_callback(function()
                local num_phases = phaseCountSlider:get()
                for i = 1, num_phases do
                    if phaseValueSliders[i] then
                        phaseValueSliders[i]:set(math.random(1, 18))
                    end
                end
            end)

            bombaMinDelaySlider:depend({delayTypeCombo, "Bomba"})
            bombaMaxDelaySlider:depend({delayTypeCombo, "Bomba"})
            bombaRandomFactorSlider:depend({delayTypeCombo, "Bomba"})
            bombaSmoothnessSlider:depend({delayTypeCombo, "Bomba"})
            bombaBurstEnableSwitch:depend({delayTypeCombo, "Bomba"})
            bombaBurstChanceSlider:depend({delayTypeCombo, "Bomba"}, bombaBurstEnableSwitch)
            bombaBurstDurationSlider:depend({delayTypeCombo, "Bomba"}, bombaBurstEnableSwitch)
            bombaBurstMultiplierSlider:depend({delayTypeCombo, "Bomba"}, bombaBurstEnableSwitch)
            bombaChaosFactorSlider:depend({delayTypeCombo, "Bomba"})

            harmonicBaseDelaySlider:depend({delayTypeCombo, "Harmonic Pattern"})
            harmonicAmplitudeSlider:depend({delayTypeCombo, "Harmonic Pattern"})
            harmonicFrequencySlider:depend({delayTypeCombo, "Harmonic Pattern"})
            harmonicWaveformCombo:depend({delayTypeCombo, "Harmonic Pattern"})
            harmonicPhaseOffsetSlider:depend({delayTypeCombo, "Harmonic Pattern"})

            local gear_return_table = {
                delayType = delayTypeCombo,
                delayHoldTicks = holdTicksSlider,
                delayHoldCycles = holdCyclesSlider,
                delaySwitchDelay = switchDelaySlider,
                delayRandomDelayForSwitch = randomDelayForSwitchSlider,

                delayRandomFrom = randomFromSlider,
                delayRandomTo = randomToSlider,
                delayRandomSpeed = randomSpeedSlider,

                delayPhaseCount = phaseCountSlider,
                delayPhaseSpeed = phaseSpeedSlider,
                delayRandomizeRotationOrder = randomizeRotationOrderDelaySwitch,
                generateRandomDelayPhaseValues = generateRandomDelayPhaseValuesButton,

                bombaMinDelay = bombaMinDelaySlider,
                bombaMaxDelay = bombaMaxDelaySlider,
                bombaRandomFactor = bombaRandomFactorSlider,
                bombaSmoothness = bombaSmoothnessSlider,
                bombaBurstEnable = bombaBurstEnableSwitch,
                bombaBurstChance = bombaBurstChanceSlider,
                bombaBurstDuration = bombaBurstDurationSlider,
                bombaBurstMultiplier = bombaBurstMultiplierSlider,
                bombaChaosFactor = bombaChaosFactorSlider,

                harmonicBaseDelay = harmonicBaseDelaySlider,
                harmonicAmplitude = harmonicAmplitudeSlider,
                harmonicFrequency = harmonicFrequencySlider,
                harmonicWaveform = harmonicWaveformCombo,
                harmonicPhaseOffset = harmonicPhaseOffsetSlider,
            }

            for i = 1, 12 do
                gear_return_table["delayPhaseValue" .. i] = phaseValueSliders[i]
            end

            return gear_return_table
        end),
        yawOffset = builder:slider("yaw offset", -180, 180, 0),
        leftYawOffset = builder:slider("> left add", -180, 180, 0),
        rightYawOffset = builder:slider("> right add", -180, 180, 0),
        delay_ticks = builder:slider("delay ticks", 1, 100, 40),
        
        modifier = builder:combo("modifier", refs.yaw_modifier:list(), nil, function(gear)
            local modifierTypeCombo = gear:combo("modifier type", {'default', 'delay', 'random', 'phase', 'alphv', 'chaotic'})
            local modOffsetSlider = gear:slider("offset", -180, 180, 0)
            local modRandomSlider = gear:slider("random", 0, 100, 0, 1, "%")
            local modHoldTicksSlider = gear:slider('hold ticks', 0, 4, 0)
            local modHoldCyclesSlider = gear:slider('hold cycles', 0, 30, 0)
            local modSwitchDelaySlider = gear:slider('switch delay', 0, 10, 0)
            local modRandomDelaySlider = gear:slider('random delay', 0, 5, 0)

            local modPhaseCountSlider = gear:slider("phases", 1, 12, 1)
            local modPhaseSpeedSlider = gear:slider("rotation speed", 1, 100, 50)

            local modPhaseValueSliders = {}
            for i = 1, 12 do
                modPhaseValueSliders[i] = gear:slider("[" .. i .. "]", -180, 180, 0)
            end

            local generateRandomValuesButton = gear:button("generate random values")
            local randomizeRotationOrderSwitch = gear:switch("randomize rotation order")

            local alphvSpeed = gear:slider('speed', 1, 100, 100)
            local alphvFlickChance = gear:slider('flick chance', 0, 100, 50, 1, '%')
            local alphvFlickMin = gear:slider('flick min', -180, 180, 0)
            local alphvFlickMax = gear:slider('flick max', -180, 180, 0)
            local alphvBaseHold = gear:slider('base hold', 0, 10, 0)
            local alphvRandomHold = gear:slider('random hold', 0, 10, 0)
            local alphvBaseDelay = gear:slider('base delay', 0, 100, 0)
            local alphvRandomDelay = gear:slider('random delay', 0, 50, 0)
            
            local alphvPhaseCount = gear:slider('flick phases', 1, 12, 4)
            local alphvFlickChancePerPhase = gear:slider('phase flick chance', 0, 100, 30, 1, '%')
            local alphvFlickRangePerPhase = gear:slider('phase flick range', 0, 180, 90)
            local alphvRandomizePhaseOrder = gear:switch('randomize phase order')
            local alphvPhaseSpeed = gear:slider('phase speed', 1, 100, 80)

            local alphvPhaseValueSliders = {}
            for i = 1, 12 do
                alphvPhaseValueSliders[i] = gear:slider("[" .. i .. "]", -180, 180, 0)
                alphvPhaseValueSliders[i]:depend({modifierTypeCombo, "alphv"}, {alphvPhaseCount, function(item) return i <= item:get() end})
            end
            local generateRandomAlphvValuesButton = gear:button("generate random phase values")
            generateRandomAlphvValuesButton:depend({modifierTypeCombo, "alphv"})

            local jitterTypeCombo = gear:combo("jitter type", {"Random", "Wave", "Burst"})
            local jitterMagnitudeSlider = gear:slider("jitter magnitude", -180, 180, 45)
            local minJitterDelaySlider = gear:slider("min jitter delay (ticks)", 1, 60, 5)
            local maxJitterDelaySlider = gear:slider("max jitter delay (ticks)", 1, 60, 15)
            local smoothingFactorSlider = gear:slider("smoothing factor (%)", 0, 100, 50)

            local waveAmplitudeSlider = gear:slider("wave amplitude", 0, 180, 45)
            local waveFrequencySlider = gear:slider("wave frequency", 0.01, 10, 1, 0.01)
            local waveOffsetSlider = gear:slider("wave phase offset", 0, 360, 0)
            local waveFormCombo = gear:combo("wave form", {"Sine", "Cosine", "Sawtooth", "Triangle"})

            local burstChanceSlider = gear:slider("burst chance (%)", 0, 100, 50)
            local burstDurationSlider = gear:slider("burst duration (ticks)", 1, 60, 10)
            local burstMultiplierSlider = gear:slider("burst multiplier", 0, 5, 1, 0.1)
            local burstRandomFactorSlider = gear:slider("burst random factor (%)", 0, 100, 20)

            local randomizeJitterDirectionSwitch = gear:switch("randomize jitter direction")
            local randomizeJitterMagnitudeSlider = gear:slider("randomize magnitude (%)", 0, 100, 0)

            local smoothTransitionSwitch = gear:switch("smooth transition", true)
            local constantJitterSwitch = gear:switch("constant jitter")


            modOffsetSlider:depend({modifierTypeCombo, function(item) return item:get() == "default" or item:get() == "random" or item:get() == "delay" end})
            modRandomSlider:depend({modifierTypeCombo, "random"})

            modHoldTicksSlider:depend({modifierTypeCombo, 'delay'})
            modHoldCyclesSlider:depend({modifierTypeCombo, 'delay'})
            modSwitchDelaySlider:depend({modifierTypeCombo, 'delay'})
            modRandomDelaySlider:depend({modifierTypeCombo, 'delay'}, {modSwitchDelaySlider, function(item) return item:get() > 0 end})

            modPhaseCountSlider:depend({modifierTypeCombo, "phase"})
            modPhaseSpeedSlider:depend({modifierTypeCombo, "phase"})
            generateRandomValuesButton:depend({modifierTypeCombo, "phase"})
            randomizeRotationOrderSwitch:depend({modifierTypeCombo, "phase"})

            alphvSpeed:depend({modifierTypeCombo, "alphv"})
            alphvFlickChance:depend({modifierTypeCombo, "alphv"})
            alphvFlickMin:depend({modifierTypeCombo, "alphv"})
            alphvFlickMax:depend({modifierTypeCombo, "alphv"})
            alphvBaseHold:depend({modifierTypeCombo, "alphv"})
            alphvRandomHold:depend({modifierTypeCombo, "alphv"})
            alphvBaseDelay:depend({modifierTypeCombo, "alphv"})
            alphvRandomDelay:depend({modifierTypeCombo, "alphv"})
            alphvPhaseCount:depend({modifierTypeCombo, "alphv"})
            alphvFlickChancePerPhase:depend({modifierTypeCombo, "alphv"}, {alphvPhaseCount, function(item) return item:get() > 0 end})
            alphvFlickRangePerPhase:depend({modifierTypeCombo, "alphv"}, {alphvPhaseCount, function(item) return item:get() > 0 end})
            alphvRandomizePhaseOrder:depend({modifierTypeCombo, "alphv"}, {alphvPhaseCount, function(item) return item:get() > 0 end})
            alphvPhaseSpeed:depend({modifierTypeCombo, "alphv"}, {alphvPhaseCount, function(item) return item:get() > 0 end})

            for i = 1, 12 do
                local phase_value_slider = modPhaseValueSliders[i]
                if phase_value_slider then
                    phase_value_slider:depend({modifierTypeCombo, "phase"}, {modPhaseCountSlider, function(item) return i <= item:get() end})
                end
            end
            
            generateRandomValuesButton:set_callback(function()
                local num_phases = modPhaseCountSlider:get()
                for i = 1, num_phases do
                    if modPhaseValueSliders[i] then
                        modPhaseValueSliders[i]:set(math.random(-49, 49))
                    end
                end
            end)

            generateRandomAlphvValuesButton:set_callback(function()
                local num_alphv_phases = alphvPhaseCount:get()
                for i = 1, num_alphv_phases do
                    if alphvPhaseValueSliders[i] then
                        alphvPhaseValueSliders[i]:set(math.random(-53, 53))
                    end
                end
            end)

            jitterTypeCombo:depend({modifierTypeCombo, "chaotic"})
            jitterMagnitudeSlider:depend({modifierTypeCombo, "chaotic"})
            minJitterDelaySlider:depend({modifierTypeCombo, "chaotic"})
            maxJitterDelaySlider:depend({modifierTypeCombo, "chaotic"})
            smoothingFactorSlider:depend({modifierTypeCombo, "chaotic"}, smoothTransitionSwitch)

            waveAmplitudeSlider:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, "Wave"})
            waveFrequencySlider:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, "Wave"})
            waveOffsetSlider:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, "Wave"})
            waveFormCombo:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, "Wave"})

            burstChanceSlider:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, "Burst"})
            burstDurationSlider:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, "Burst"})
            burstMultiplierSlider:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, "Burst"})
            burstRandomFactorSlider:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, "Burst"})

            randomizeJitterDirectionSwitch:depend({modifierTypeCombo, "chaotic"})
            randomizeJitterMagnitudeSlider:depend({modifierTypeCombo, "chaotic"}, {jitterTypeCombo, function(item) return item:get() == "Random" or item:get() == "Burst" end})

            smoothTransitionSwitch:depend({modifierTypeCombo, "chaotic"})
            constantJitterSwitch:depend({modifierTypeCombo, "chaotic"})

            local gear_return_table = {
                randType = modifierTypeCombo,
                modOffset = modOffsetSlider,
                modRandom = modRandomSlider,
                modHoldTicks = modHoldTicksSlider,
                modHoldCycles = modHoldCyclesSlider,
                modSwitchDelay = modSwitchDelaySlider,
                modRandomDelay = modRandomDelaySlider,

                modPhaseCount = modPhaseCountSlider,
                modPhaseSpeed = modPhaseSpeedSlider,
                generateRandomValues = generateRandomValuesButton,
                randomizeRotationOrder = randomizeRotationOrderSwitch,
                
                alphvSpeed = alphvSpeed,
                alphvFlickChance = alphvFlickChance,
                alphvFlickMin = alphvFlickMin,
                alphvFlickMax = alphvFlickMax,
                alphvBaseHold = alphvBaseHold,
                alphvRandomHold = alphvRandomHold,
                alphvBaseDelay = alphvBaseDelay,
                alphvRandomDelay = alphvRandomDelay,
                alphvPhaseCount = alphvPhaseCount,
                alphvFlickChancePerPhase = alphvFlickChancePerPhase,
                alphvFlickRangePerPhase = alphvFlickRangePerPhase,
                alphvRandomizePhaseOrder = alphvRandomizePhaseOrder,
                alphvPhaseSpeed = alphvPhaseSpeed,
                generateRandomAlphvValues = generateRandomAlphvValuesButton,

                jitterType = jitterTypeCombo,
                jitterMagnitude = jitterMagnitudeSlider,
                minJitterDelay = minJitterDelaySlider,
                maxJitterDelay = maxJitterDelaySlider,
                smoothingFactor = smoothingFactorSlider,
                waveAmplitude = waveAmplitudeSlider,
                waveFrequency = waveFrequencySlider,
                waveOffset = waveOffsetSlider,
                waveForm = waveFormCombo,
                burstChance = burstChanceSlider,
                burstDuration = burstDurationSlider,
                burstMultiplier = burstMultiplierSlider,
                burstRandomFactor = burstRandomFactorSlider,
                randomizeJitterDirection = randomizeJitterDirectionSwitch,
                randomizeJitterMagnitude = randomizeJitterMagnitudeSlider,
                smoothTransition = smoothTransitionSwitch,
                constantJitter = constantJitterSwitch,
            }

            for i = 1, 12 do
                gear_return_table["modPhaseValue" .. i] = modPhaseValueSliders[i]
            end
            for i = 1, 12 do
                gear_return_table["alphvPhaseValue" .. i] = alphvPhaseValueSliders[i]
            end

            return gear_return_table
        end),

        bodyYaw = builder:switch("body yaw", true, nil, function(gear)
            local desyncOption = gear:combo("desync options", {"Default", "Random"})
            
            local speedOption = gear:combo("speed", {"Constant", "Custom"})
            local rotationSpeedSlider = gear:slider("rotation speed", 1, 100, 50)

            speedOption:depend({desyncOption, "Random"})
            rotationSpeedSlider:depend({desyncOption, "Random"}, {speedOption, "Custom"})

            return {
                desyncOption = desyncOption,
                speedOption = speedOption,
                rotationSpeed = rotationSpeedSlider
            }
        end),
        leftLimit = builder:slider("left limit", 0, 60, 60),
        rightLimit = builder:slider("right limit", 0, 60, 60),
        bodyFS = builder:combo("body freestanding", refs.body_fs:list()),

        antiBruteforce = builder:switch(" anti bruteforce ", false, nil, function(gear)
            local antiBruteforceType = gear:combo("type", {"l/r adds"})
            local antiBruteforceMode = gear:combo("mode", {"pre-made [shdw]", "custom"})
            local antiBruteforceReset = gear:switch("reset after new round")
            local antiBruteforceIndication = gear:switch("indication")

            local abCustomPhaseCount = gear:slider("phases", 1, 7, 1)
            local abCustomRandomizeOrder = gear:switch("randomize order")
            
            local abCustomPhaseValueSlidersL = {}
            local abCustomPhaseValueSlidersR = {}
            for i = 1, 7 do
                abCustomPhaseValueSlidersL[i] = gear:slider("[" .. i .. ", L]", -180, 180, 0)
                abCustomPhaseValueSlidersR[i] = gear:slider("[" .. i .. ", R]", -180, 180, 0)
            end

            local generateRandomAntiBruteforceValuesButton = gear:button("generate random values")

            abCustomPhaseCount:depend({antiBruteforceMode, "custom"})
            abCustomRandomizeOrder:depend({antiBruteforceMode, "custom"})
            for i = 1, 7 do
                abCustomPhaseValueSlidersL[i]:depend({antiBruteforceMode, "custom"}, {abCustomPhaseCount, function(item) return i <= item:get() end})
                abCustomPhaseValueSlidersR[i]:depend({antiBruteforceMode, "custom"}, {abCustomPhaseCount, function(item) return i <= item:get() end})
            end
            generateRandomAntiBruteforceValuesButton:depend({antiBruteforceMode, "custom"})

            generateRandomAntiBruteforceValuesButton:set_callback(function()
                local num_phases = abCustomPhaseCount:get()
                for i = 1, num_phases do
                    if abCustomPhaseValueSlidersL[i] then
                        abCustomPhaseValueSlidersL[i]:set(math.random(-39, 39))
                    end
                    if abCustomPhaseValueSlidersR[i] then
                        abCustomPhaseValueSlidersR[i]:set(math.random(-39, 39))
                    end
                end
            end)

            local gear_return_table = {
                antiBruteforceType = antiBruteforceType,
                antiBruteforceMode = antiBruteforceMode,
                antiBruteforceReset = antiBruteforceReset,
                antiBruteforceIndication = antiBruteforceIndication,
                abCustomPhaseCount = abCustomPhaseCount,
                abCustomRandomizeOrder = abCustomRandomizeOrder,
                generateRandomAntiBruteforceValues = generateRandomAntiBruteforceValuesButton,
            }
            for i = 1, 7 do
                gear_return_table["abCustomPhaseValueL" .. i] = abCustomPhaseValueSlidersL[i]
                gear_return_table["abCustomPhaseValueR" .. i] = abCustomPhaseValueSlidersR[i]
            end
            return gear_return_table
        end),
    }

    ctx.forwardButton = builder:button("", function()
        local current_team_ui = menu["anti aim states"].team_selector:get() 
        local other_team_prefix = (current_team_ui == "CT") and "t" or "ct"
        Utility.copyStateSettings(current_team_ui:lower(), other_team_prefix, state_idx_in_list)
    end)

    local state_selector_dep = {menu["anti aim states"].selector, function(item) return item:get() == state_idx_in_list end}
    local team_selector_dep = {menu["anti aim states"].team_selector, function(item) return item:get():lower() == team_prefix end}

    for k, ref in pairs(ctx) do
        if k == "yawOffset" then
            ref:depend(state_selector_dep, team_selector_dep, {ctx.yawType, function(item) return item:get() == "single" end})
        elseif k == "leftYawOffset" or k == "rightYawOffset" then
            ref:depend(state_selector_dep, team_selector_dep, {ctx.yawType, function(item) return item:get() == "l/r" end})
        elseif k == "delay_ticks" then
            ref:depend(state_selector_dep, team_selector_dep, {ctx.yawType, function(item) return false end})
        elseif k == "leftLimit" or k == "rightLimit" or k == "bodyFS" then
            ref:depend(state_selector_dep, team_selector_dep, ctx.bodyYaw)
        elseif k == "antiBruteforce" then
            ref:depend(state_selector_dep, team_selector_dep)
        else
            ref:depend(state_selector_dep, team_selector_dep)
        end
        if k == "forwardButton" then
            ref:depend(state_selector_dep)
            menu["anti aim states"].team_selector:set_callback(function()
                if menu["anti aim states"].selector:get() == state_idx_in_list then
                    local current_team_ui = menu["anti aim states"].team_selector:get()
                    local button_text = (current_team_ui == "CT") and ">forward" or ">forward"
                    ref:name(button_text)
                end
            end)
            local current_team_ui_initial = menu["anti aim states"].team_selector:get()
            local button_text_initial = (current_team_ui_initial == "CT") and ">forward" or ">forward"
            ref:name(button_text_initial)
        end
    end

    return ctx
end

for i = 1, #states do
    local id = states[i][1]
    local state_idx_in_list = i
    menu["anti aim states"].cache.ct[id] = Utility.createCtx(state_idx_in_list, groups.builder, "ct")
    menu["anti aim states"].cache.t[id] = Utility.createCtx(state_idx_in_list, groups.builder, "t")
end

local copiedStateSettings = nil
local copiedStateId = nil
local copiedTeamPrefix = nil

local function copyStateSettings()
    local selected_state_idx = menu["anti aim states"].selector:get()
    if not selected_state_idx then
        print_raw(Utility.color_text({"Please select a state to copy.", "FF0000FF"}))
        return
    end

    local selected_state_id = states[selected_state_idx][1]
    local selected_team_prefix = menu["anti aim states"].team_selector:get():lower()
    local sourceCtx = menu["anti aim states"].cache[selected_team_prefix][selected_state_id]
    
    if not sourceCtx then
        print_raw(Utility.color_text({"Error: Source state context not found for copying.", "FF0000FF"}))
        return
    end

    copiedStateSettings = {
        yawType = sourceCtx.yawType:get(),
        yawOffset = sourceCtx.yawOffset:get(),
        leftYawOffset = sourceCtx.leftYawOffset:get(),
        rightYawOffset = sourceCtx.rightYawOffset:get(),
        delay_ticks = sourceCtx.delay_ticks:get(),
        
        modifier = sourceCtx.modifier:get(),
        randType = sourceCtx.modifier.randType:get(), 
        modOffset = sourceCtx.modifier.modOffset:get(), 
        modRandom = sourceCtx.modifier.modRandom:get(), 
        modHoldTicks = sourceCtx.modifier.modHoldTicks:get(), 
        modHoldCycles = sourceCtx.modifier.modHoldCycles:get(), 
        modSwitchDelay = sourceCtx.modifier.modSwitchDelay:get(), 
        modRandomDelay = sourceCtx.modifier.modRandomDelay:get(),
        modPhaseCount = sourceCtx.modifier.modPhaseCount:get(),
        modPhaseSpeed = sourceCtx.modifier.modPhaseSpeed:get(),
        modRandomizeRotationOrder = sourceCtx.modifier.randomizeRotationOrder:get(),
        modPhaseValues = {},

        alphvSpeed = sourceCtx.modifier.alphvSpeed:get(),
        alphvFlickChance = sourceCtx.modifier.alphvFlickChance:get(),
        alphvFlickMin = sourceCtx.modifier.alphvFlickMin:get(),
        alphvFlickMax = sourceCtx.modifier.alphvFlickMax:get(),
        alphvBaseHold = sourceCtx.modifier.alphvBaseHold:get(),
        alphvRandomHold = sourceCtx.modifier.alphvRandomHold:get(),
        alphvBaseDelay = sourceCtx.modifier.alphvBaseDelay:get(),
        alphvRandomDelay = sourceCtx.modifier.alphvRandomDelay:get(),
        alphvPhaseCount = sourceCtx.modifier.alphvPhaseCount:get(),
        alphvFlickChancePerPhase = sourceCtx.modifier.alphvFlickChancePerPhase:get(),
        alphvFlickRangePerPhase = sourceCtx.modifier.alphvFlickRangePerPhase:get(),
        alphvRandomizePhaseOrder = sourceCtx.modifier.alphvRandomizePhaseOrder:get(),
        alphvPhaseSpeed = sourceCtx.modifier.alphvPhaseSpeed:get(),
        alphvPhaseValues = {},

        jitterMagnitude = sourceCtx.modifier.jitterMagnitude:get(),
        minJitterDelay = sourceCtx.modifier.minJitterDelay:get(),
        maxJitterDelay = sourceCtx.modifier.maxJitterDelay:get(),
        smoothingFactor = sourceCtx.modifier.smoothingFactor:get(),
        jitterType = sourceCtx.modifier.jitterType:get(),
        waveAmplitude = sourceCtx.modifier.waveAmplitude:get(),
        waveFrequency = sourceCtx.modifier.waveFrequency:get(),
        waveOffset = sourceCtx.modifier.waveOffset:get(),
        waveForm = sourceCtx.modifier.waveForm:get(),
        burstChance = sourceCtx.modifier.burstChance:get(),
        burstDuration = sourceCtx.modifier.burstDuration:get(),
        burstMultiplier = sourceCtx.modifier.burstMultiplier:get(),
        burstRandomFactor = sourceCtx.modifier.burstRandomFactor:get(),
        randomizeJitterDirection = sourceCtx.modifier.randomizeJitterDirection:get(),
        randomizeJitterMagnitude = sourceCtx.modifier.randomizeJitterMagnitude:get(),
        smoothTransition = sourceCtx.modifier.smoothTransition:get(),
        constantJitter = sourceCtx.modifier.constantJitter:get(),

        bodyYaw = sourceCtx.bodyYaw:get(),
        bodyYawDesyncOption = sourceCtx.bodyYaw.desyncOption:get(),
        bodyYawSpeedOption = sourceCtx.bodyYaw.speedOption:get(),
        bodyYawRotationSpeed = sourceCtx.bodyYaw.rotationSpeed:get(),
        leftLimit = sourceCtx.leftLimit:get(),
        rightLimit = sourceCtx.rightLimit:get(),
        bodyFS = sourceCtx.bodyFS:get(),
        delayType = sourceCtx.yawType.delayType:get(),
        delayHoldTicks = sourceCtx.yawType.delayHoldTicks:get(),
        delayHoldCycles = sourceCtx.yawType.delayHoldCycles:get(),
        delaySwitchDelay = sourceCtx.yawType.delaySwitchDelay:get(),
        delayRandomDelayForSwitch = sourceCtx.yawType.delayRandomDelayForSwitch:get(),
        delayRandomFrom = sourceCtx.yawType.delayRandomFrom:get(),    
        delayRandomTo = sourceCtx.yawType.delayRandomTo:get(),      
        delayRandomSpeed = sourceCtx.yawType.delayRandomSpeed:get(),
        delayPhaseCount = sourceCtx.yawType.delayPhaseCount:get(), 
        delayPhaseSpeed = sourceCtx.yawType.delayPhaseSpeed:get(), 
        delayRandomizeRotationOrder = sourceCtx.yawType.delayRandomizeRotationOrder:get(),
        delayPhaseValues = {},

        bombaMinDelay = sourceCtx.yawType.bombaMinDelay:get(),
        bombaMaxDelay = sourceCtx.yawType.bombaMaxDelay:get(),
        bombaRandomFactor = sourceCtx.yawType.bombaRandomFactor:get(),
        bombaSmoothness = sourceCtx.yawType.bombaSmoothness:get(),
        bombaBurstEnable = sourceCtx.yawType.bombaBurstEnable:get(),
        bombaBurstChance = sourceCtx.yawType.bombaBurstChance:get(),
        bombaBurstDuration = sourceCtx.yawType.bombaBurstDuration:get(),
        bombaBurstMultiplier = sourceCtx.yawType.bombaBurstMultiplier:get(),
        bombaChaosFactor = sourceCtx.yawType.bombaChaosFactor:get(),

        harmonicBaseDelay = sourceCtx.yawType.harmonicBaseDelay:get(),
        harmonicAmplitude = sourceCtx.yawType.harmonicAmplitude:get(),
        harmonicFrequency = sourceCtx.yawType.harmonicFrequency:get(),
        harmonicWaveform = sourceCtx.yawType.harmonicWaveform:get(),
        harmonicPhaseOffset = sourceCtx.yawType.harmonicPhaseOffset:get(),

        antiBruteforce = sourceCtx.antiBruteforce:get(),
        antiBruteforceType = sourceCtx.antiBruteforce.antiBruteforceType:get(),
        antiBruteforceMode = sourceCtx.antiBruteforce.antiBruteforceMode:get(),
        antiBruteforceReset = sourceCtx.antiBruteforce.antiBruteforceReset:get(),
        antiBruteforceIndication = sourceCtx.antiBruteforce.antiBruteforceIndication:get(),
        abCustomPhaseCount = sourceCtx.antiBruteforce.abCustomPhaseCount:get(),
        abCustomRandomizeOrder = sourceCtx.antiBruteforce.abCustomRandomizeOrder:get(),
        abCustomPhaseValuesL = {},
        abCustomPhaseValuesR = {},

        anti_backstab = menu["anti aim"].anti_backstab:get(),
        safe_head_on_knife = menu["anti aim"].safe_head_on_knife:get(),
    }
    
    for i = 1, 12 do
        local phase_value_key = "delayPhaseValue" .. i
        if sourceCtx.yawType[phase_value_key] then
            copiedStateSettings.delayPhaseValues[i] = sourceCtx.yawType[phase_value_key]:get()
        end
    end

    for i = 1, 12 do
        local phase_value_key = "modPhaseValue" .. i
        if sourceCtx.modifier[phase_value_key] then
            copiedStateSettings.modPhaseValues[i] = sourceCtx.modifier[phase_value_key]:get()
        end
    end

    for i = 1, 12 do
        local phase_value_key = "alphvPhaseValue" .. i
        if sourceCtx.modifier[phase_value_key] then
            copiedStateSettings.alphvPhaseValues[i] = sourceCtx.modifier[phase_value_key]:get()
        end
    end

    for i = 1, 7 do
        local phase_value_key_L = "abCustomPhaseValueL" .. i
        local phase_value_key_R = "abCustomPhaseValueR" .. i
        if sourceCtx.antiBruteforce and sourceCtx.antiBruteforce[phase_value_key_L] then
            copiedStateSettings.abCustomPhaseValuesL[i] = sourceCtx.antiBruteforce[phase_value_key_L]:get()
        end
        if sourceCtx.antiBruteforce and sourceCtx.antiBruteforce[phase_value_key_R] then
            copiedStateSettings.abCustomPhaseValuesR[i] = sourceCtx.antiBruteforce[phase_value_key_R]:get()
        end
    end

    copiedStateId = selected_state_id
    copiedTeamPrefix = selected_team_prefix
    
    print_raw(Utility.color_text({"Copied ", SHADOWYAW_COLOR_HEX}) .. 
              Utility.color_text({states[selected_state_idx][2] .. " settings for " .. selected_team_prefix:upper(), "FFFFFFFF"}))
end

local function pasteStateSettings()
    if not copiedStateSettings then
        print_raw(Utility.color_text({"No settings copied yet!", "FF0000FF"}))
        return
    end

    local selected_state_idx = menu["anti aim states"].selector:get()
    if not selected_state_idx then
        print_raw(Utility.color_text({"Please select a state to paste to.", "FF0000FF"}))
        return
    end

    local selected_state_id = states[selected_state_idx][1]
    local selected_team_prefix = menu["anti aim states"].team_selector:get():lower()
    local targetCtx = menu["anti aim states"].cache[selected_team_prefix][selected_state_id]

    if not targetCtx then
        print_raw(Utility.color_text({"Error: Target state context not found for pasting.", "FF0000FF"}))
        return
    end

    local success, err

    if targetCtx.yawType then success, err = pcall(targetCtx.yawType.set, targetCtx.yawType, copiedStateSettings.yawType); if not success then print("Error setting yawType: " .. err) end end
    if targetCtx.yawOffset then success, err = pcall(targetCtx.yawOffset.set, targetCtx.yawOffset, copiedStateSettings.yawOffset); if not success then print("Error setting yawOffset: " .. err) end end
    if targetCtx.leftYawOffset then success, err = pcall(targetCtx.leftYawOffset.set, targetCtx.leftYawOffset, copiedStateSettings.leftYawOffset); if not success then print("Error setting leftYawOffset: " .. err) end end
    if targetCtx.rightYawOffset then success, err = pcall(targetCtx.rightYawOffset.set, targetCtx.rightYawOffset, copiedStateSettings.rightYawOffset); if not success then print("Error setting rightYawOffset: " .. err) end end
    if targetCtx.delay_ticks then success, err = pcall(targetCtx.delay_ticks.set, targetCtx.delay_ticks, copiedStateSettings.delay_ticks); if not success then print("Error setting delay_ticks: " .. err) end end

    if targetCtx.modifier then success, err = pcall(targetCtx.modifier.set, targetCtx.modifier, copiedStateSettings.modifier); if not success then print("Error setting modifier: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.randType then success, err = pcall(targetCtx.modifier.randType.set, targetCtx.modifier.randType, copiedStateSettings.randType); if not success then print("Error setting randType: " .. err) end end
    if targetCtx.modifier and copiedStateSettings.randType ~= 'phase' and copiedStateSettings.randType ~= 'alphv' and copiedStateSettings.randType ~= 'chaotic' and targetCtx.modifier.modOffset then
        success, err = pcall(targetCtx.modifier.modOffset.set, targetCtx.modifier.modOffset, copiedStateSettings.modOffset); if not success then print("Error setting modOffset: " .. err) end
    end
    if targetCtx.modifier and targetCtx.modifier.modRandom then success, err = pcall(targetCtx.modifier.modRandom.set, targetCtx.modifier.modRandom, copiedStateSettings.modRandom); if not success then print("Error setting modRandom: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.modHoldTicks then success, err = pcall(targetCtx.modifier.modHoldTicks.set, targetCtx.modifier.modHoldTicks, copiedStateSettings.modHoldTicks); if not success then print("Error setting modHoldTicks: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.modHoldCycles then success, err = pcall(targetCtx.modifier.modHoldCycles.set, targetCtx.modifier.modHoldCycles, copiedStateSettings.modHoldCycles); if not success then print("Error setting modHoldCycles: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.modSwitchDelay then success, err = pcall(targetCtx.modifier.modSwitchDelay.set, targetCtx.modifier.modSwitchDelay, copiedStateSettings.modSwitchDelay); if not success then print("Error setting modSwitchDelay: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.modRandomDelay then success, err = pcall(targetCtx.modifier.modRandomDelay.set, targetCtx.modifier.modRandomDelay, copiedStateSettings.modRandomDelay); if not success then print("Error setting modRandomDelay: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.modPhaseCount then success, err = pcall(targetCtx.modifier.modPhaseCount.set, targetCtx.modifier.modPhaseCount, copiedStateSettings.modPhaseCount); if not success then print("Error setting modPhaseCount: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.modPhaseSpeed then success, err = pcall(targetCtx.modifier.modPhaseSpeed.set, targetCtx.modifier.modPhaseSpeed, copiedStateSettings.modPhaseSpeed); if not success then print("Error setting modPhaseSpeed: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.randomizeRotationOrder then success, err = pcall(targetCtx.modifier.randomizeRotationOrder.set, targetCtx.modifier.randomizeRotationOrder, copiedStateSettings.modRandomizeRotationOrder); if not success then print("Error setting randomizeRotationOrder: " .. err) end end

    if targetCtx.modifier and targetCtx.modifier.alphvSpeed then success, err = pcall(targetCtx.modifier.alphvSpeed.set, targetCtx.modifier.alphvSpeed, copiedStateSettings.alphvSpeed); if not success then print("Error setting alphvSpeed: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvFlickChance then success, err = pcall(targetCtx.modifier.alphvFlickChance.set, targetCtx.modifier.alphvFlickChance, copiedStateSettings.alphvFlickChance); if not success then print("Error setting alphvFlickChance: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvFlickMin then success, err = pcall(targetCtx.modifier.alphvFlickMin.set, targetCtx.modifier.alphvFlickMin, copiedStateSettings.alphvFlickMin); if not success then print("Error setting alphvFlickMin: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvFlickMax then success, err = pcall(targetCtx.modifier.alphvFlickMax.set, targetCtx.modifier.alphvFlickMax, copiedStateSettings.alphvFlickMax); if not success then print("Error setting alphvFlickMax: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvBaseHold then success, err = pcall(targetCtx.modifier.alphvBaseHold.set, targetCtx.modifier.alphvBaseHold, copiedStateSettings.alphvBaseHold); if not success then print("Error setting alphvBaseHold: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvRandomHold then success, err = pcall(targetCtx.modifier.alphvRandomHold.set, targetCtx.modifier.alphvRandomHold, copiedStateSettings.alphvRandomHold); if not success then print("Error setting alphvRandomHold: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvBaseDelay then success, err = pcall(targetCtx.modifier.alphvBaseDelay.set, targetCtx.modifier.alphvBaseDelay, copiedStateSettings.alphvBaseDelay); if not success then print("Error setting alphvBaseDelay: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvRandomDelay then success, err = pcall(targetCtx.modifier.alphvRandomDelay.set, targetCtx.modifier.alphvRandomDelay, copiedStateSettings.alphvRandomDelay); if not success then print("Error setting alphvRandomDelay: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvPhaseCount then success, err = pcall(targetCtx.modifier.alphvPhaseCount.set, targetCtx.modifier.alphvPhaseCount, copiedStateSettings.alphvPhaseCount); if not success then print("Error setting alphvPhaseCount: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvFlickChancePerPhase then success, err = pcall(targetCtx.modifier.alphvFlickChancePerPhase.set, targetCtx.modifier.alphvFlickChancePerPhase, copiedStateSettings.alphvFlickChancePerPhase); if not success then print("Error setting alphvFlickChancePerPhase: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvFlickRangePerPhase then success, err = pcall(targetCtx.modifier.alphvFlickRangePerPhase.set, targetCtx.modifier.alphvFlickRangePerPhase, copiedStateSettings.alphvFlickRangePerPhase); if not success then print("Error setting alphvFlickRangePerPhase: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvRandomizePhaseOrder then success, err = pcall(targetCtx.modifier.alphvRandomizePhaseOrder.set, targetCtx.modifier.alphvRandomizePhaseOrder, copiedStateSettings.alphvRandomizePhaseOrder); if not success then print("Error setting alphvRandomizePhaseOrder: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.alphvPhaseSpeed then success, err = pcall(targetCtx.modifier.alphvPhaseSpeed.set, targetCtx.modifier.alphvPhaseSpeed, copiedStateSettings.alphvPhaseSpeed); if not success then print("Error setting alphvPhaseSpeed:  " .. err) end end

    if targetCtx.modifier and targetCtx.modifier.jitterMagnitude then success, err = pcall(targetCtx.modifier.jitterMagnitude.set, targetCtx.modifier.jitterMagnitude, copiedStateSettings.jitterMagnitude); if not success then print("Error setting jitterMagnitude: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.minJitterDelay then success, err = pcall(targetCtx.modifier.minJitterDelay.set, targetCtx.modifier.minJitterDelay, copiedStateSettings.minJitterDelay); if not success then print("Error setting minJitterDelay: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.maxJitterDelay then success, err = pcall(targetCtx.modifier.maxJitterDelay.set, targetCtx.modifier.maxJitterDelay, copiedStateSettings.maxJitterDelay); if not success then print("Error setting maxJitterDelay: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.smoothingFactor then success, err = pcall(targetCtx.modifier.smoothingFactor.set, targetCtx.modifier.smoothingFactor, copiedStateSettings.smoothingFactor); if not success then print("Error setting smoothingFactor: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.jitterType then success, err = pcall(targetCtx.modifier.jitterType.set, targetCtx.modifier.jitterType, copiedStateSettings.jitterType); if not success then print("Error setting jitterType: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.waveAmplitude then success, err = pcall(targetCtx.modifier.waveAmplitude.set, targetCtx.modifier.waveAmplitude, copiedStateSettings.waveAmplitude); if not success then print("Error setting waveAmplitude: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.waveFrequency then success, err = pcall(targetCtx.modifier.waveFrequency.set, targetCtx.modifier.waveFrequency, copiedStateSettings.waveFrequency); if not success then print("Error setting waveFrequency: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.waveOffset then success, err = pcall(targetCtx.modifier.waveOffset.set, targetCtx.modifier.waveOffset, copiedStateSettings.waveOffset); if not success then print("Error setting waveOffset: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.waveForm then success, err = pcall(targetCtx.modifier.waveForm.set, targetCtx.modifier.waveForm, copiedStateSettings.waveForm); if not success then print("Error setting waveForm: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.burstChance then success, err = pcall(targetCtx.modifier.burstChance.set, targetCtx.modifier.burstChance, copiedStateSettings.burstChance); if not success then print("Error setting burstChance: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.burstDuration then success, err = pcall(targetCtx.modifier.burstDuration.set, targetCtx.modifier.burstDuration, copiedStateSettings.burstDuration); if not success then print("Error setting burstDuration: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.burstMultiplier then success, err = pcall(targetCtx.modifier.burstMultiplier.set, targetCtx.modifier.burstMultiplier, copiedStateSettings.burstMultiplier); if not success then print("Error setting burstMultiplier: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.burstRandomFactor then success, err = pcall(targetCtx.modifier.burstRandomFactor.set, targetCtx.modifier.burstRandomFactor, copiedStateSettings.burstRandomFactor); if not success then print("Error setting burstRandomFactor: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.randomizeJitterDirection then success, err = pcall(targetCtx.modifier.randomizeJitterDirection.set, targetCtx.modifier.randomizeJitterDirection, copiedStateSettings.randomizeJitterDirection); if not success then print("Error setting randomizeJitterDirection: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.randomizeJitterMagnitude then success, err = pcall(targetCtx.modifier.randomizeJitterMagnitude.set, targetCtx.modifier.randomizeJitterMagnitude, copiedStateSettings.randomizeJitterMagnitude); if not success then print("Error setting randomizeJitterMagnitude: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.smoothTransition then success, err = pcall(targetCtx.modifier.smoothTransition.set, targetCtx.modifier.smoothTransition, copiedStateSettings.smoothTransition); if not success then print("Error setting smoothTransition: " .. err) end end
    if targetCtx.modifier and targetCtx.modifier.constantJitter then success, err = pcall(targetCtx.modifier.constantJitter.set, targetCtx.modifier.constantJitter, copiedStateSettings.constantJitter); if not success then print("Error setting constantJitter: " .. err) end end

    for i = 1, 12 do
        local phase_value_key = "modPhaseValue" .. i
        if targetCtx.modifier and targetCtx.modifier[phase_value_key] and copiedStateSettings.modPhaseValues[i] ~= nil then
            success, err = pcall(targetCtx.modifier[phase_value_key].set, targetCtx.modifier[phase_value_key], copiedStateSettings.modPhaseValues[i])
            if not success then print("Error setting modifier phase value " .. i .. ": " .. err) end
        end
    end

    for i = 1, 12 do
        local phase_value_key = "alphvPhaseValue" .. i
        if targetCtx.modifier and targetCtx.modifier[phase_value_key] and copiedStateSettings.alphvPhaseValues[i] ~= nil then
            success, err = pcall(targetCtx.modifier[phase_value_key].set, targetCtx.modifier[phase_value_key], copiedStateSettings.alphvPhaseValues[i])
            if not success then print("Error setting ALPHV phase value " .. i .. ": " .. err) end
        end
    end

    if targetCtx.bodyYaw then success, err = pcall(targetCtx.bodyYaw.set, targetCtx.bodyYaw, copiedStateSettings.bodyYaw); if not success then print("Error setting bodyYaw: " .. err) end end
    if targetCtx.bodyYaw and targetCtx.bodyYaw.desyncOption then success, err = pcall(targetCtx.bodyYaw.desyncOption.set, targetCtx.bodyYaw.desyncOption, copiedStateSettings.bodyYawDesyncOption); if not success then print("Error setting bodyYaw desyncOption: " .. err) end end
    if targetCtx.bodyYaw and targetCtx.bodyYaw.speedOption then success, err = pcall(targetCtx.bodyYaw.speedOption.set, targetCtx.bodyYaw.speedOption, copiedStateSettings.bodyYawSpeedOption); if not success then print("Error setting bodyYaw speedOption: " .. err) end end
    if targetCtx.bodyYaw and targetCtx.bodyYaw.rotationSpeed then success, err = pcall(targetCtx.bodyYaw.rotationSpeed.set, targetCtx.bodyYaw.rotationSpeed, copiedStateSettings.bodyYawRotationSpeed); if not success then print("Error setting bodyYaw rotationSpeed: " .. err) end end
    if targetCtx.leftLimit then success, err = pcall(targetCtx.leftLimit.set, targetCtx.leftLimit, copiedStateSettings.leftLimit); if not success then print("Error setting leftLimit: " .. err) end end
    if targetCtx.rightLimit then success, err = pcall(targetCtx.rightLimit.set, targetCtx.rightLimit, copiedStateSettings.rightLimit); if not success then print("Error setting rightLimit: " .. err) end end
    if targetCtx.bodyFS then success, err = pcall(targetCtx.bodyFS.set, targetCtx.bodyFS, copiedStateSettings.bodyFS); if not success then print("Error setting bodyFS: " .. err) end end
    
    if targetCtx.yawType and targetCtx.yawType.delayType then success, err = pcall(targetCtx.yawType.delayType.set, targetCtx.yawType.delayType, copiedStateSettings.delayType); if not success then print("Error setting delayType: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayHoldTicks then success, err = pcall(targetCtx.yawType.delayHoldTicks.set, targetCtx.yawType.delayHoldTicks, copiedStateSettings.delayHoldTicks); if not success then print("Error setting delayHoldTicks: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayHoldCycles then success, err = pcall(targetCtx.yawType.delayHoldCycles.set, targetCtx.yawType.delayHoldCycles, copiedStateSettings.delayHoldCycles); if not success then print("Error setting delayHoldCycles: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delaySwitchDelay then success, err = pcall(targetCtx.yawType.delaySwitchDelay.set, targetCtx.yawType.delaySwitchDelay, copiedStateSettings.delaySwitchDelay); if not success then print("Error setting delaySwitchDelay: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayRandomDelayForSwitch then success, err = pcall(targetCtx.yawType.delayRandomDelayForSwitch.set, targetCtx.yawType.delayRandomDelayForSwitch, copiedStateSettings.delayRandomDelayForSwitch); if not success then print("Error setting delayRandomDelayForSwitch: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayRandomFrom then success, err = pcall(targetCtx.yawType.delayRandomFrom.set, targetCtx.yawType.delayRandomFrom, copiedStateSettings.delayRandomFrom); if not success then print("Error setting delayRandomFrom: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayRandomTo then success, err = pcall(targetCtx.yawType.delayRandomTo.set, targetCtx.yawType.delayRandomTo, copiedStateSettings.delayRandomTo); if not success then print("Error setting delayRandomTo: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayRandomSpeed then success, err = pcall(targetCtx.yawType.delayRandomSpeed.set, targetCtx.yawType.delayRandomSpeed, copiedStateSettings.delayRandomSpeed); if not success then print("Error setting delayRandomSpeed: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayPhaseCount then success, err = pcall(targetCtx.yawType.delayPhaseCount.set, targetCtx.yawType.delayPhaseCount, copiedStateSettings.delayPhaseCount); if not success then print("Error setting delayPhaseCount: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayPhaseSpeed then success, err = pcall(targetCtx.yawType.delayPhaseSpeed.set, targetCtx.yawType.delayPhaseSpeed, copiedStateSettings.delayPhaseSpeed); if not success then print("Error setting delayPhaseSpeed: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.delayRandomizeRotationOrder then success, err = pcall(targetCtx.yawType.delayRandomizeRotationOrder.set, targetCtx.yawType.delayRandomizeRotationOrder, copiedStateSettings.delayRandomizeRotationOrder); if not success then print("Error setting delayRandomizeRotationOrder: " .. err) end end

    for i = 1, 12 do
        local phase_value_key = "delayPhaseValue" .. i
        if targetCtx.yawType and targetCtx.yawType[phase_value_key] and copiedStateSettings.delayPhaseValues[i] ~= nil then
            success, err = pcall(targetCtx.yawType[phase_value_key].set, targetCtx.yawType[phase_value_key], copiedStateSettings.delayPhaseValues[i])
            if not success then print("Error setting delayPhaseValues " .. i .. ": " .. err) end
        end
    end

    if targetCtx.yawType and targetCtx.yawType.bombaMinDelay then success, err = pcall(targetCtx.yawType.bombaMinDelay.set, targetCtx.yawType.bombaMinDelay, copiedStateSettings.bombaMinDelay); if not success then print("Error setting bombaMinDelay: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.bombaMaxDelay then success, err = pcall(targetCtx.yawType.bombaMaxDelay.set, targetCtx.yawType.bombaMaxDelay, copiedStateSettings.bombaMaxDelay); if not success then print("Error setting bombaMaxDelay: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.bombaRandomFactor then success, err = pcall(targetCtx.yawType.bombaRandomFactor.set, targetCtx.yawType.bombaRandomFactor, copiedStateSettings.bombaRandomFactor); if not success then print("Error setting bombaRandomFactor: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.bombaSmoothness then success, err = pcall(targetCtx.yawType.bombaSmoothness.set, targetCtx.yawType.bombaSmoothness, copiedStateSettings.bombaSmoothness); if not success then print("Error setting bombaSmoothness: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.bombaBurstEnable then success, err = pcall(targetCtx.yawType.bombaBurstEnable.set, targetCtx.yawType.bombaBurstEnable, copiedStateSettings.bombaBurstEnable); if not success then print("Error setting bombaBurstEnable: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.bombaBurstChance then success, err = pcall(targetCtx.yawType.bombaBurstChance.set, targetCtx.yawType.bombaBurstChance, copiedStateSettings.bombaBurstChance); if not success then print("Error setting bombaBurstChance: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.bombaBurstDuration then success, err = pcall(targetCtx.yawType.bombaBurstDuration.set, targetCtx.yawType.bombaBurstDuration, copiedStateSettings.bombaBurstDuration); if not success then print("Error setting bombaBurstDuration: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.bombaBurstMultiplier then success, err = pcall(targetCtx.yawType.bombaBurstMultiplier.set, targetCtx.yawType.bombaBurstMultiplier, copiedStateSettings.bombaBurstMultiplier); if not success then print("Error setting bombaBurstMultiplier: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.bombaChaosFactor then success, err = pcall(targetCtx.yawType.bombaChaosFactor.set, targetCtx.yawType.bombaChaosFactor, copiedStateSettings.bombaChaosFactor); if not success then print("Error setting bombaChaosFactor: " .. err) end end

    if targetCtx.yawType and targetCtx.yawType.harmonicBaseDelay then success, err = pcall(targetCtx.yawType.harmonicBaseDelay.set, targetCtx.yawType.harmonicBaseDelay, copiedStateSettings.harmonicBaseDelay); if not success then print("Error setting harmonicBaseDelay: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.harmonicAmplitude then success, err = pcall(targetCtx.yawType.harmonicAmplitude.set, targetCtx.yawType.harmonicAmplitude, copiedStateSettings.harmonicAmplitude); if not success then print("Error setting harmonicAmplitude: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.harmonicFrequency then success, err = pcall(targetCtx.yawType.harmonicFrequency.set, targetCtx.yawType.harmonicFrequency, copiedStateSettings.harmonicFrequency); if not success then print("Error setting harmonicFrequency: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.harmonicWaveform then success, err = pcall(targetCtx.yawType.harmonicWaveform.set, targetCtx.yawType.harmonicWaveform, copiedStateSettings.harmonicWaveform); if not success then print("Error setting harmonicWaveform: " .. err) end end
    if targetCtx.yawType and targetCtx.yawType.harmonicPhaseOffset then success, err = pcall(targetCtx.yawType.harmonicPhaseOffset.set, targetCtx.yawType.harmonicPhaseOffset, copiedStateSettings.harmonicPhaseOffset); if not success then print("Error setting harmonicPhaseOffset: " .. err) end end

    if targetCtx.antiBruteforce and copiedStateSettings.antiBruteforce ~= nil then
        success, err = pcall(targetCtx.antiBruteforce.set, targetCtx.antiBruteforce, copiedStateSettings.antiBruteforce)
        if not success then print("Error setting antiBruteforce switch: " .. err) end
    end
    
    if targetCtx.antiBruteforce and targetCtx.antiBruteforce.antiBruteforceType then
        success, err = pcall(targetCtx.antiBruteforce.antiBruteforceType.set, targetCtx.antiBruteforce.antiBruteforceType, copiedStateSettings.antiBruteforceType)
        if not success then print("Error setting antiBruteforceType: " .. err) end
    end
    if targetCtx.antiBruteforce and targetCtx.antiBruteforce.antiBruteforceMode then
        success, err = pcall(targetCtx.antiBruteforce.antiBruteforceMode.set, targetCtx.antiBruteforce.antiBruteforceMode, copiedStateSettings.antiBruteforceMode)
        if not success then print("Error setting antiBruteforceMode: " .. err) end
    end
    if targetCtx.antiBruteforce and targetCtx.antiBruteforce.antiBruteforceReset then
        success, err = pcall(targetCtx.antiBruteforce.antiBruteforceReset.set, targetCtx.antiBruteforce.antiBruteforceReset, copiedStateSettings.antiBruteforceReset)
        if not success then print("Error setting antiBruteforceReset: " .. err) end
    end
    if targetCtx.antiBruteforce and targetCtx.antiBruteforce.antiBruteforceIndication then
        success, err = pcall(targetCtx.antiBruteforce.antiBruteforceIndication.set, targetCtx.antiBruteforce.antiBruteforceIndication, copiedStateSettings.antiBruteforceIndication)
        if not success then print("Error setting antiBruteforceIndication: " .. err) end
    end
    if targetCtx.antiBruteforce and targetCtx.antiBruteforce.abCustomPhaseCount then
        success, err = pcall(targetCtx.antiBruteforce.abCustomPhaseCount.set, targetCtx.antiBruteforce.abCustomPhaseCount, copiedStateSettings.abCustomPhaseCount)
        if not success then print("Error setting abCustomPhaseCount: " .. err) end
    end
    if targetCtx.antiBruteforce and targetCtx.antiBruteforce.abCustomRandomizeOrder then
        success, err = pcall(targetCtx.antiBruteforce.abCustomRandomizeOrder.set, targetCtx.antiBruteforce.abCustomRandomizeOrder, copiedStateSettings.abCustomRandomizeOrder)
        if not success then print("Error setting abCustomRandomizeOrder: " .. err) end
    end

    for i = 1, 7 do
        local phase_value_key_L = "abCustomPhaseValueL" .. i
        local phase_value_key_R = "abCustomPhaseValueR" .. i
        if targetCtx.antiBruteforce and targetCtx.antiBruteforce[phase_value_key_L] and copiedStateSettings.abCustomPhaseValuesL[i] ~= nil then
            success, err = pcall(targetCtx.antiBruteforce[phase_value_key_L].set, targetCtx.antiBruteforce[phase_value_key_L], copiedStateSettings.abCustomPhaseValuesL[i])
            if not success then print("Error setting L phase " .. i .. ": " .. err) end
        end
        if targetCtx.antiBruteforce and targetCtx.antiBruteforce[phase_value_key_R] and copiedStateSettings.abCustomPhaseValuesR[i] ~= nil then
            success, err = pcall(targetCtx.antiBruteforce[phase_value_key_R].set, targetCtx.antiBruteforce[phase_value_key_R], copiedStateSettings.abCustomPhaseValuesR[i])
            if not success then print("Error setting R phase " .. i .. ": " .. err) end
        end
    end

    if menu["anti aim"].anti_backstab then success, err = pcall(menu["anti aim"].anti_backstab.set, menu["anti aim"].anti_backstab, copiedStateSettings.anti_backstab); if not success then print("Error setting anti_backstab: " .. err) end end
    if menu["anti aim"].safe_head_on_knife then success, err = pcall(menu["anti aim"].safe_head_on_knife.set, menu["anti aim"].safe_head_on_knife, copiedStateSettings.safe_head_on_knife); if not success then print("Error setting safe_head_on_knife: " .. err) end end

    print_raw(Utility.color_text({"Pasted ", SHADOWYAW_COLOR_HEX}) .. 
              Utility.color_text({states[selected_state_idx][2] .. " settings to " .. selected_team_prefix:upper() .. "!", "FFFFFFFF"}))
end

menu["anti aim states"].copy = groups.builder:button("copy", copyStateSettings)
menu["anti aim states"].paste = groups.builder:button("paste", pasteStateSettings)

menu["anti aim states"].copy:depend({menu["anti aim states"].selector, function(item) return item:get() ~= nil end})
menu["anti aim states"].paste:depend({menu["anti aim states"].selector, function(item) return item:get() ~= nil end})

menu["anti aim"].freestanding.disableModifiers:depend(menu["anti aim"].freestanding)
menu["anti aim"].freestanding.bodyFreestand:depend(menu["anti aim"].freestanding)

menu.utility_group_2.fpsBoost.fpsBoostOptions:depend(menu.utility_group_2.fpsBoost)

menu.utility_group_2.animBreakers.animGround:depend(menu.utility_group_2.animBreakers)
menu.utility_group_2.animBreakers.animGroundAmount:depend(menu.utility_group_2.animBreakers, {menu.utility_group_2.animBreakers.animGround, function(item) return item:get() == 'Jitter' or item:get() == 'Other Jitter' end})
menu.utility_group_2.animBreakers.animAir:depend(menu.utility_group_2.animBreakers)
menu.utility_group_2.animBreakers.animOther:depend(menu.utility_group_2.animBreakers)
menu.utility_group_2.animBreakers.animOtherLean:depend(menu.utility_group_2.animBreakers, {menu.utility_group_2.animBreakers.animOther, 'Move Lean'})

menu.utility_group_3.logs.limit:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.time:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.offset:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.background:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.glow_strength:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.glow_color:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.show_avatar_icon:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.fade_animation_type:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.prefix_type:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.first_color:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.second_color:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.custom_color:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.hit_color:depend(menu.utility_group_3.logs.custom_color)
menu.utility_group_3.logs.miss_color:depend(menu.utility_group_3.logs.custom_color)
menu.utility_group_3.logs.custom_background_color:depend(menu.utility_group_3.logs)
menu.utility_group_3.logs.background_color:depend(menu.utility_group_3.logs.custom_background_color)

menu.utility_group_3.console_logs.buy_logs:depend(menu.utility_group_3.console_logs)
menu.utility_group_3.console_logs.hit_logs:depend(menu.utility_group_3.console_logs)


menu.utility_group_3.viewmodel.fieldOfView:depend(menu.utility_group_3.viewmodel)
menu.utility_group_3.viewmodel.offsetX:depend(menu.utility_group_3.viewmodel)
menu.utility_group_3.viewmodel.offsetY:depend(menu.utility_group_3.viewmodel)
menu.utility_group_3.viewmodel.offsetZ:depend(menu.utility_group_3.viewmodel)
menu.utility_group_3.aspectRatio.aspectRatioValue:depend(menu.utility_group_3.aspectRatio)
menu.utility_group_3.aspectRatio.aspectRatio4_3Button:depend(menu.utility_group_3.aspectRatio)
menu.utility_group_3.aspectRatio.aspectRatio16_9Button:depend(menu.utility_group_3.aspectRatio)
menu.utility_group_3.aspectRatio.aspectRatio16_10Button:depend(menu.utility_group_3.aspectRatio)
menu.utility_group_3.aspectRatio.aspectRatio21_9Button:depend(menu.utility_group_3.aspectRatio)

menu.utility_group_3.airlag.airlagTicks:depend(menu.utility_group_3.airlag)

menu.utility_group_3.dmgIndicator.x:depend(menu.utility_group_3.dmgIndicator)
menu.utility_group_3.dmgIndicator.y:depend(menu.utility_group_3.dmgIndicator)
menu.utility_group_3.dmgIndicator.color:depend(menu.utility_group_3.dmgIndicator)
menu.utility_group_3.dmgIndicator.font:depend(menu.utility_group_3.dmgIndicator)


Utility.getState = function()
    local localPlayer = player()
    if not localPlayer then return end

    local flags = localPlayer.m_fFlags
    local ducking = bit.band(flags, bit.lshift(1, 1)) ~= 0 or (refs.fd and refs.fd:get())
    local ground = bit.band(flags, bit.lshift(1, 0)) ~= 0
    local velocityLength = localPlayer.m_vecVelocity:length() 
    local moving = velocityLength > 2 
    local standing = velocityLength < 2
    local slowWalk = refs.slow_walk and refs.slow_walk:get()

    if standing and ground and not ducking and not slowWalk then return "standing" end
    if moving and ground and not ducking and not slowWalk then return "moving" end
    if slowWalk and ground then return "slow motion" end
    if not ground and not ducking then return "air" end
    if not ground and ducking then return "air crouching" end
    if ducking and ground and not moving then return "crouching" end
    if ducking and ground and moving then return "sneaking" end
    
    return "standing"
end

Utility.getCondition = function()
    local state = Utility.getState()
    local stateToCondition = {
        ["standing"] = 1,
        ["moving"] = 2,
        ["slow motion"] = 3,
        ["air"] = 4,
        ["air crouching"] = 5,
        ["crouching"] = 6,
        ["sneaking"] = 7,
    }
    return stateToCondition[state]
end

Utility.getBodyYaw = function()
    local localPlayer = player()
    if not localPlayer or globals.choked_commands ~= 0 then
        return
    end

    return localPlayer.m_flPoseParameter[11] * 120 - 60
end

Utility.getSide = function()
    return nil
end

Utility.timeToTicks = function(time)
    return math.floor(time / globals.tickinterval + 0.5)
end

local l_r_delay_ind = false
local l_r_last_switch_tick = 0
local l_r_hold_tick_counter = 0
local l_r_hold_cycle_counter = 0
local l_r_random_target_delay = 0
local l_r_phase_index = 1
local l_r_last_phase_change_tick = 0

local bomba_current_delay = 0
local bomba_target_delay = 0
local bomba_last_target_update_tick = 0
local bomba_is_bursting = false
local bomba_burst_end_tick = 0
local bomba_last_toggle_tick = 0

local harmonic_last_toggle_tick = 0
local harmonic_time_offset = 0

local modifier_delay_ind = false
local modifier_last_switch_tick = 0
local modifier_hold_tick_counter = 0
local modifier_hold_cycle_counter = 0
local modifier_phase_index = 1
local modifier_last_phase_change_tick = 0

local chaotic_current_yaw_offset = 0
local chaotic_last_update_tick = 0
local chaotic_next_update_delay = 0
local chaotic_target_yaw_offset = 0
local chaotic_is_bursting = false
local chaotic_burst_end_tick = 0
local chaotic_wave_start_time = 0

local anti_bruteforce_last_shot_tick = 0
local anti_bruteforce_custom_phase_index = 1
local anti_bruteforce_active_override = false 
local anti_bruteforce_current_left_add = 0
local anti_bruteforce_current_right_add = 0

local last_displayed_ab_left = 0
local last_displayed_ab_right = 0
local anti_bruteforce_log_active = false

local last_modifier_type = ""
local last_fade_animation_type = nil

local body_yaw_random_current_value = 0
local body_yaw_random_last_switch_tick = 0
local body_yaw_random_next_switch_delay = 0

Functions.antiaim = function()
    local lp = player()
    if not lp then return end

    local team_prefix_for_logic = (lp.m_iTeamNum == 2) and "t" or "ct"
    local condition = Utility.getCondition()
    local state_id = states[condition][1]
    local antiAimState = menu["anti aim states"].cache[team_prefix_for_logic][state_id]

    if not antiAimState then
        return
    end

    local inverted = lp.m_flPoseParameter[11] * 120 - 60 > 0

    local yawOffset = antiAimState.yawOffset:get()

    local delay_type = antiAimState.yawType.delayType:get()

    if delay_type ~= "Bomba" then
        bomba_current_delay = 0
        bomba_target_delay = 0
        bomba_last_target_update_tick = 0
        bomba_is_bursting = false
        bomba_burst_end_tick = 0
        bomba_last_toggle_tick = 0
    end
    if delay_type ~= "Harmonic Pattern" then
        harmonic_last_toggle_tick = 0
        harmonic_time_offset = 0
    end

    if antiAimState.yawType:get() == "l/r" then
        local current_tick = globals.tickcount

        if delay_type == "Switch" then
            local hold_ticks = antiAimState.yawType.delayHoldTicks:get()
            local hold_cycles = antiAimState.yawType.delayHoldCycles:get()
            local switch_delay = antiAimState.yawType.delaySwitchDelay:get()
            local random_delay_for_switch = antiAimState.yawType.delayRandomDelayForSwitch:get()

            if current_tick >= l_r_last_switch_tick + switch_delay + math.random(0, random_delay_for_switch) then
                if globals.choked_commands == 0 then
                    if l_r_hold_tick_counter < hold_ticks then
                        l_r_hold_tick_counter = l_r_hold_tick_counter + 1
                    else
                        l_r_hold_tick_counter = 0
                        l_r_hold_cycle_counter = l_r_hold_cycle_counter + 1

                        if l_r_hold_cycle_counter >= hold_cycles then
                            l_r_delay_ind = not l_r_delay_ind
                            l_r_hold_cycle_counter = 0
                            l_r_last_switch_tick = current_tick
                        end
                    end
                end
            end
        elseif delay_type == "Random" then
            local random_from = antiAimState.yawType.delayRandomFrom:get()
            local random_to = antiAimState.yawType.delayRandomTo:get()
            local rotation_speed = antiAimState.yawType.delayRandomSpeed:get()

            local speed_factor_divisor = 1 + 2 * ((rotation_speed - 1) / 99) 
            speed_factor_divisor = math.max(speed_factor_divisor, 1)

            if l_r_random_target_delay == 0 or current_tick >= l_r_last_switch_tick + l_r_random_target_delay then
                if globals.choked_commands == 0 then
                    l_r_delay_ind = not l_r_delay_ind
                    l_r_last_switch_tick = current_tick
                    l_r_random_target_delay = math.random(random_from, random_to) / speed_factor_divisor
                end
            end
        elseif delay_type == "Phase" then
            local phase_count = antiAimState.yawType.delayPhaseCount:get()
            local rotation_speed = antiAimState.yawType.delayPhaseSpeed:get()
            local randomize_rotation_order_delay = antiAimState.yawType.delayRandomizeRotationOrder:get()

            local current_phase_delay_ticks = 0
            if antiAimState.yawType["delayPhaseValue" .. l_r_phase_index] then
                current_phase_delay_ticks = antiAimState.yawType["delayPhaseValue" .. l_r_phase_index]:get()
            end
            
            local speed_factor_divisor = 1 + 2 * ((rotation_speed - 1) / 99) 
            speed_factor_divisor = math.max(speed_factor_divisor, 1)
            local actual_phase_delay = current_phase_delay_ticks / speed_factor_divisor
            
            if current_tick >= l_r_last_phase_change_tick + actual_phase_delay then
                if globals.choked_commands == 0 then
                    if randomize_rotation_order_delay then
                        l_r_phase_index = math.random(1, phase_count)
                    else
                        l_r_phase_index = l_r_phase_index + 1
                        if l_r_phase_index > phase_count then
                            l_r_phase_index = 1
                        end
                    end
                    l_r_delay_ind = not l_r_delay_ind
                    l_r_last_phase_change_tick = current_tick
                end
            end
        elseif delay_type == "Bomba" then
            local min_delay = antiAimState.yawType.bombaMinDelay:get()
            local max_delay = antiAimState.yawType.bombaMaxDelay:get()
            local random_factor = antiAimState.yawType.bombaRandomFactor:get() / 100
            local smoothness = antiAimState.yawType.bombaSmoothness:get() / 100
            local burst_enable = antiAimState.yawType.bombaBurstEnable:get()
            local burst_chance = antiAimState.yawType.bombaBurstChance:get()
            local burst_duration = antiAimState.yawType.bombaBurstDuration:get()
            local burst_multiplier = antiAimState.yawType.bombaBurstMultiplier:get() / 100
            local chaos_factor = antiAimState.yawType.bombaChaosFactor:get() / 100

            if bomba_current_delay == 0 then
                bomba_current_delay = math.random(min_delay, max_delay)
                bomba_target_delay = bomba_current_delay
                bomba_last_target_update_tick = current_tick
                bomba_last_toggle_tick = current_tick
            end

            local update_interval = math.random(20, 60) * (1 + random_factor)
            if current_tick >= bomba_last_target_update_tick + update_interval then
                bomba_target_delay = bomba_target_delay * (1 + (math.random() * 2 - 1) * random_factor)
                bomba_target_delay = math.clamp(bomba_target_delay, min_delay, max_delay)

                bomba_last_target_update_tick = current_tick

                if burst_enable and not bomba_is_bursting then
                    if math.random(0, 100) < burst_chance then
                        bomba_is_bursting = true
                        bomba_burst_end_tick = current_tick + burst_duration
                    end
                end
            end

            if bomba_is_bursting and current_tick >= bomba_burst_end_tick then
                bomba_is_bursting = false
            end

            local effective_target_delay = bomba_target_delay
            if bomba_is_bursting then
                effective_target_delay = effective_target_delay * burst_multiplier
            end

            bomba_current_delay = math.lerp(bomba_current_delay, effective_target_delay, smoothness)

            local chaos_deviation = (math.random() * 2 - 1) * (max_delay - min_delay) * chaos_factor * 0.1
            bomba_current_delay = bomba_current_delay + chaos_deviation
            bomba_current_delay = math.clamp(bomba_current_delay, min_delay * 0.5, max_delay * 2)

            if current_tick >= bomba_last_toggle_tick + bomba_current_delay then
                if globals.choked_commands == 0 then
                    l_r_delay_ind = not l_r_delay_ind
                    bomba_last_toggle_tick = current_tick
                end
            end
        elseif delay_type == "Harmonic Pattern" then
            local base_delay = antiAimState.yawType.harmonicBaseDelay:get()
            local amplitude = antiAimState.yawType.harmonicAmplitude:get()
            local frequency = antiAimState.yawType.harmonicFrequency:get()
            local waveform = antiAimState.yawType.harmonicWaveform:get()
            local phase_offset_deg = antiAimState.yawType.harmonicPhaseOffset:get()
            local phase_offset_rad = math.rad(phase_offset_deg)

            local current_time = globals.curtime
            if harmonic_time_offset == 0 then
                harmonic_time_offset = current_time
            end
            local time_in_pattern = current_time - harmonic_time_offset

            local wave_value = 0
            if waveform == "Sine" then
                wave_value = math.sin(2 * math.pi * frequency * time_in_pattern + phase_offset_rad)
            elseif waveform == "Cosine" then
                wave_value = math.cos(2 * math.pi * frequency * time_in_pattern + phase_offset_rad)
            elseif waveform == "Sawtooth" then
                wave_value = (2 * ((frequency * time_in_pattern) % 1)) - 1
            elseif waveform == "Triangle" then
                local t = (frequency * time_in_pattern) % 1
                if t < 0.5 then
                    wave_value = (4 * t) - 1
                else
                    wave_value = (4 * (1 - t)) - 1
                end
            end

            local calculated_delay = base_delay + (amplitude * wave_value)
            calculated_delay = math.max(1, calculated_delay)

            if current_tick >= harmonic_last_toggle_tick + calculated_delay then
                if globals.choked_commands == 0 then
                    l_r_delay_ind = not l_r_delay_ind
                    harmonic_last_toggle_tick = current_tick
                end
            end
        end

        if l_r_delay_ind then
            yawOffset = antiAimState.leftYawOffset:get()
        else
            yawOffset = antiAimState.rightYawOffset:get()
        end
        
        refs.inverter:override(l_r_delay_ind)
        refs.yaw_modifier:override("Disabled")
        refs.modifier_offset:override(0)

    else
        yawOffset = antiAimState.yawOffset:get()
        refs.inverter:override(inverted)
        refs.yaw_modifier:override(antiAimState.modifier:get())
    end

    local anti_bruteforce_enabled = antiAimState.antiBruteforce:get()

    if anti_bruteforce_enabled and anti_bruteforce_active_override then
        if l_r_delay_ind then
            yawOffset = anti_bruteforce_current_left_add
        else
            yawOffset = anti_bruteforce_current_right_add
        end
    end

    refs.yaw_offset:override(yawOffset)
    
    local current_modifier_type = antiAimState.modifier:get()
    local current_modifier_rand_type = antiAimState.modifier.randType:get()
    local mod_offset = antiAimState.modifier.modOffset:get()
    local mod_random = antiAimState.modifier.modRandom:get()
    local mod_hold_ticks = antiAimState.modifier.modHoldTicks:get()
    local mod_hold_cycles = antiAimState.modifier.modHoldCycles:get()
    local mod_switch_delay = antiAimState.modifier.modSwitchDelay:get()
    local mod_random_delay = antiAimState.modifier.modRandomDelay:get()

    local mod_phase_count = antiAimState.modifier.modPhaseCount:get()
    local mod_phase_speed = antiAimState.modifier.modPhaseSpeed:get()
    local mod_randomize_rotation_order = antiAimState.modifier.randomizeRotationOrder:get()

    local alphv_speed = antiAimState.modifier.alphvSpeed:get()
    local alphv_flick_chance = antiAimState.modifier.alphvFlickChance:get()
    local alphv_flick_min = antiAimState.modifier.alphvFlickMin:get()
    local alphv_flick_max = antiAimState.modifier.alphvFlickMax:get()
    local alphv_base_hold = antiAimState.modifier.alphvBaseHold:get()
    local alphv_random_hold = antiAimState.modifier.alphvRandomHold:get()
    local alphv_base_delay = antiAimState.modifier.alphvBaseDelay:get()
    local alphv_random_delay = antiAimState.modifier.alphvRandomDelay:get()
    local alphv_phase_count = antiAimState.modifier.alphvPhaseCount:get()
    local alphv_flick_chance_per_phase = antiAimState.modifier.alphvFlickChancePerPhase:get()
    local alphv_flick_range_per_phase = antiAimState.modifier.alphvFlickRangePerPhase:get()
    local alphv_randomize_phase_order = antiAimState.modifier.alphvRandomizePhaseOrder:get()
    local alphv_phase_speed = antiAimState.modifier.alphvPhaseSpeed:get()

    local jitter_type = antiAimState.modifier.jitterType:get()
    local jitter_magnitude = antiAimState.modifier.jitterMagnitude:get()
    local min_jitter_delay = antiAimState.modifier.minJitterDelay:get()
    local max_jitter_delay = antiAimState.modifier.maxJitterDelay:get()
    local smoothing_factor = antiAimState.modifier.smoothingFactor:get() / 100

    local wave_amplitude = antiAimState.modifier.waveAmplitude:get()
    local wave_frequency = antiAimState.modifier.waveFrequency:get()
    local wave_offset = antiAimState.modifier.waveOffset:get()
    local wave_form = antiAimState.modifier.waveForm:get()

    local burst_chance = antiAimState.modifier.burstChance:get()
    local burst_duration = antiAimState.modifier.burstDuration:get()
    local burst_multiplier = antiAimState.modifier.burstMultiplier:get()
    local burst_random_factor = antiAimState.modifier.burstRandomFactor:get() / 100

    local randomize_jitter_direction = antiAimState.modifier.randomizeJitterDirection:get()
    local randomize_jitter_magnitude = antiAimState.modifier.randomizeJitterMagnitude:get() / 100

    local smooth_transition = antiAimState.modifier.smoothTransition:get()
    local constant_jitter = antiAimState.modifier.constantJitter:get()

    local state_key = team_prefix_for_logic .. ":" .. state_id
    
    if not alphv_states[state_key] then
        alphv_states[state_key] = {
            state = "decision",
            current_hold_ticks = 0,
            current_delay_ticks = 0,
            last_phase_change_tick = 0,
            phase_index = 1,
            base_flick_value = 0,
            current_phase_offset = 0,
            alphv_last_action_tick = 0,
            alphv_current_hold_duration = 0,
            alphv_current_delay_duration = 0,
        }
    end
    local alphv_data = alphv_states[state_key]

    if last_modifier_type ~= current_modifier_rand_type then
        alphv_states[state_key] = {
            state = "decision",
            current_hold_ticks = 0,
            current_delay_ticks = 0,
            last_phase_change_tick = 0,
            phase_index = 1,
            base_flick_value = 0,
            current_phase_offset = 0,
            alphv_last_action_tick = 0,
            alphv_current_hold_duration = 0,
            alphv_current_delay_duration = 0,
        }
        chaotic_current_yaw_offset = 0
        chaotic_last_update_tick = 0
        chaotic_next_update_delay = 0
        chaotic_target_yaw_offset = 0
        chaotic_is_bursting = false
        chaotic_burst_end_tick = 0
        chaotic_wave_start_time = 0
    end

    if current_modifier_type ~= "Disabled" then
        refs.yaw_modifier:override(current_modifier_type)

        if current_modifier_rand_type == 'default' then
            refs.modifier_offset:override(mod_offset)
        elseif current_modifier_rand_type == 'random' then
            refs.modifier_offset:override(randomize_func(mod_offset, mod_random))
        elseif current_modifier_rand_type == 'delay' then
            local current_tick = globals.tickcount
            if current_tick > modifier_last_switch_tick + mod_switch_delay + math.random(0, mod_random_delay) then
                if globals.choked_commands == 0 then
                    if modifier_hold_tick_counter < mod_hold_ticks then
                        modifier_hold_tick_counter = modifier_hold_tick_counter + 1
                    else
                        modifier_hold_tick_counter = 0
                        modifier_hold_cycle_counter = modifier_hold_cycle_counter + 1

                        if modifier_hold_cycle_counter >= mod_hold_cycles then
                            modifier_delay_ind = not modifier_delay_ind
                            modifier_hold_cycle_counter = 0
                            modifier_last_switch_tick = current_tick
                        end
                    end
                end
            elseif current_tick < modifier_last_switch_tick then
                modifier_last_switch_tick = current_tick
            end

            refs.modifier_offset:override(mod_offset) 
            refs.options:override('')
            refs.inverter:override(modifier_delay_ind)
        elseif current_modifier_rand_type == 'phase' then
            local current_tick = globals.tickcount
            
            local speed_factor = 1 + 2 * ((mod_phase_speed - 1) / 99) 
            speed_factor = math.max(speed_factor, 1)
            local actual_phase_delay = 100 / speed_factor

            if current_tick >= modifier_last_phase_change_tick + actual_phase_delay then
                if globals.choked_commands == 0 then
                    if mod_randomize_rotation_order then
                        modifier_phase_index = math.random(1, mod_phase_count)
                    else
                        modifier_phase_index = modifier_phase_index + 1
                        if modifier_phase_index > mod_phase_count then
                            modifier_phase_index = 1
                        end
                    end
                    modifier_last_phase_change_tick = current_tick
                end
            end

            local current_phase_value = 0
            if antiAimState.modifier["modPhaseValue" .. modifier_phase_index] then
                current_phase_value = antiAimState.modifier["modPhaseValue" .. modifier_phase_index]:get()
            end
            refs.modifier_offset:override(current_phase_value)
            refs.options:override('')
            refs.inverter:override(false)
        elseif current_modifier_rand_type == 'alphv' then
            local current_tick = globals.tickcount
            
            local effective_speed_factor = 1 + ((100 - alphv_speed) / 100) 
            
            local effective_base_hold = alphv_base_hold * effective_speed_factor
            local effective_random_hold = alphv_random_hold * effective_speed_factor
            local effective_base_delay = alphv_base_delay * effective_speed_factor
            local effective_random_delay = alphv_random_delay * effective_speed_factor
            
            if alphv_data.state == "decision" then
                if math.random(0, 100) < alphv_flick_chance then
                    alphv_data.base_flick_value = math.random(alphv_flick_min, alphv_flick_max)
                    alphv_data.state = "flick_hold"
                    alphv_data.alphv_current_hold_duration = math.max(1, math.floor(effective_base_hold + math.random(0, effective_random_hold)))
                else
                    alphv_data.base_flick_value = 0
                    alphv_data.state = "delay"
                    alphv_data.alphv_current_delay_duration = math.max(1, math.floor(effective_base_delay + math.random(0, effective_random_delay)))
                end
                alphv_data.alphv_last_action_tick = current_tick
            elseif alphv_data.state == "flick_hold" then
                if current_tick >= alphv_data.alphv_last_action_tick + alphv_data.alphv_current_hold_duration then
                    alphv_data.state = "delay"
                    alphv_data.alphv_current_delay_duration = math.max(1, math.floor(effective_base_delay + math.random(0, effective_random_delay)))
                    alphv_data.alphv_last_action_tick = current_tick
                end
            elseif alphv_data.state == "delay" then
                if current_tick >= alphv_data.alphv_last_action_tick + alphv_data.alphv_current_delay_duration then
                    alphv_data.state = "decision"
                end
            end
            
            local current_phase_offset_value = 0
            if alphv_phase_count > 0 then
                local effective_phase_speed = 1 + ((100 - alphv_phase_speed) / 100)
                local phase_delay_ticks = math.max(1, math.floor(100 / effective_phase_speed))

                if current_tick >= alphv_data.last_phase_change_tick + phase_delay_ticks then
                    if globals.choked_commands == 0 then
                        if alphv_randomize_phase_order then
                            alphv_data.phase_index = math.random(1, alphv_phase_count)
                        else
                            alphv_data.phase_index = (alphv_data.phase_index % alphv_phase_count) + 1
                        end
                        
                        local base_phase_value = 0
                        if antiAimState.modifier["alphvPhaseValue" .. alphv_data.phase_index] then
                            base_phase_value = antiAimState.modifier["alphvPhaseValue" .. alphv_data.phase_index]:get()
                        end

                        if math.random(0, 100) < alphv_flick_chance_per_phase then
                            local phase_offset_val = math.random(-alphv_flick_range_per_phase, alphv_flick_range_per_phase)
                            current_phase_offset_value = base_phase_value + phase_offset_val
                        else
                            current_phase_offset_value = base_phase_value
                        end
                        
                        alphv_data.current_phase_offset = current_phase_offset_value
                        alphv_data.last_phase_change_tick = current_tick
                    end
                end
            else
                alphv_data.current_phase_offset = 0
            end

            local final_alphv_offset = alphv_data.base_flick_value + alphv_data.current_phase_offset
            refs.modifier_offset:override(final_alphv_offset)
            
            refs.options:override('')
            refs.inverter:override(false)
        elseif current_modifier_rand_type == 'chaotic' then
            local current_tick = globals.tickcount
            local current_time = globals.curtime

            if jitter_type == "Burst" then
                if not chaotic_is_bursting then
                    if math.random(0, 100) < burst_chance then
                        chaotic_is_bursting = true
                        chaotic_burst_end_tick = current_tick + burst_duration + math.random(0, math.floor(burst_duration * burst_random_factor))
                    end
                elseif current_tick >= chaotic_burst_end_tick then
                    chaotic_is_bursting = false
                end
            else
                chaotic_is_bursting = false
            end

            local effective_jitter_magnitude = jitter_magnitude
            if chaotic_is_bursting then
                effective_jitter_magnitude = jitter_magnitude * burst_multiplier
            end

            local new_target_yaw = chaotic_target_yaw_offset

            if constant_jitter then
                if jitter_type == "Random" or jitter_type == "Burst" then
                    new_target_yaw = math.random(-effective_jitter_magnitude, effective_jitter_magnitude)
                elseif jitter_type == "Wave" then
                    if chaotic_wave_start_time == 0 then chaotic_wave_start_time = current_time end
                    local time_in_wave = current_time - chaotic_wave_start_time + math.rad(wave_offset) / (2 * math.pi * wave_frequency)
                    local wave_val = 0
                    if wave_form == "Sine" then
                        wave_val = math.sin(2 * math.pi * wave_frequency * time_in_wave)
                    elseif wave_form == "Cosine" then
                        wave_val = math.cos(2 * math.pi * wave_frequency * time_in_wave)
                    elseif wave_form == "Sawtooth" then
                        wave_val = (2 * ((wave_frequency * time_in_wave) % 1)) - 1
                    elseif wave_form == "Triangle" then
                        local t = (wave_frequency * time_in_wave) % 1
                        if t < 0.5 then
                            wave_val = (4 * t) - 1
                        else
                            wave_val = (4 * (1 - t)) - 1
                        end
                    end
                    new_target_yaw = wave_amplitude * wave_val
                end
            else
                if chaotic_next_update_delay == 0 or current_tick >= chaotic_last_update_tick + chaotic_next_update_delay then
                    if globals.choked_commands == 0 then
                        if jitter_type == "Random" or jitter_type == "Burst" then
                            new_target_yaw = math.random(-effective_jitter_magnitude, effective_jitter_magnitude)
                            if randomize_jitter_magnitude > 0 then
                                new_target_yaw = randomize_func(new_target_yaw, randomize_jitter_magnitude * 100)
                            end
                        elseif jitter_type == "Wave" then
                            chaotic_wave_start_time = current_time 
                            local time_in_wave = current_time - chaotic_wave_start_time + math.rad(wave_offset) / (2 * math.pi * wave_frequency)
                            local wave_val = 0
                            if wave_form == "Sine" then
                                wave_val = math.sin(2 * math.pi * wave_frequency * time_in_wave)
                            elseif wave_form == "Cosine" then
                                wave_val = math.cos(2 * math.pi * wave_frequency * time_in_wave)
                            elseif wave_form == "Sawtooth" then
                                wave_val = (2 * ((wave_frequency * time_in_wave) % 1)) - 1
                            elseif wave_form == "Triangle" then
                                local t = (wave_frequency * time_in_wave) % 1
                                if t < 0.5 then wave_val = (4 * t) - 1 else wave_val = (4 * (1 - t)) - 1 end
                            end
                            new_target_yaw = wave_amplitude * wave_val
                        end

                        if randomize_jitter_direction and math.random(0, 1) == 1 then
                            new_target_yaw = -new_target_yaw
                        end
                        
                        chaotic_target_yaw_offset = new_target_yaw
                        chaotic_last_update_tick = current_tick
                        chaotic_next_update_delay = math.random(min_jitter_delay, max_jitter_delay)
                    end
                end
            end
            
            if smooth_transition then
                chaotic_current_yaw_offset = math.lerp(chaotic_current_yaw_offset, chaotic_target_yaw_offset, smoothing_factor)
            else
                chaotic_current_yaw_offset = chaotic_target_yaw_offset
            end
            
            chaotic_current_yaw_offset = math.clamp(chaotic_current_yaw_offset, -180, 180)

            refs.modifier_offset:override(chaotic_current_yaw_offset)
            refs.options:override('')
            refs.inverter:override(false)
        end
    else
        refs.yaw_modifier:override("Disabled")
        refs.modifier_offset:override(0)
    end

    last_modifier_type = current_modifier_rand_type

    refs.body_yaw:override(antiAimState.bodyYaw:get())

    local current_body_yaw_desync_option = antiAimState.bodyYaw.desyncOption:get()
    local current_body_yaw_speed_option = antiAimState.bodyYaw.speedOption:get()
    local current_body_yaw_rotation_speed = antiAimState.bodyYaw.rotationSpeed:get()
    local current_tick = globals.tickcount

    if current_body_yaw_desync_option == "Random" then
        local min_desync_value = antiAimState.leftLimit:get()
        local max_desync_value = antiAimState.rightLimit:get()

        local switch_interval = 0
        if current_body_yaw_speed_option == "Constant" then
            switch_interval = 10 
        elseif current_body_yaw_speed_option == "Custom" then
            switch_interval = math.lerp(50, 5, (current_body_yaw_rotation_speed - 1) / 99)
        end

        if body_yaw_random_next_switch_delay == 0 or current_tick >= body_yaw_random_last_switch_tick + body_yaw_random_next_switch_delay then
            body_yaw_random_current_value = math.random(min_desync_value, max_desync_value)
            body_yaw_random_last_switch_tick = current_tick
            body_yaw_random_next_switch_delay = math.floor(switch_interval)
        end

        refs.left_limit:override(body_yaw_random_current_value)
        refs.right_limit:override(body_yaw_random_current_value)
    else
        refs.left_limit:override(antiAimState.leftLimit:get())
        refs.right_limit:override(antiAimState.rightLimit:get())
    end

    refs.body_fs:override(antiAimState.bodyFS:get())
    
    refs.pitch:override(menu["anti aim"].pitch:get())

    if menu["anti aim"].yawBase:get() == "At Target" then
        refs.yaw_base:override("At Target")
        refs.freestanding:override(false)
    elseif menu["anti aim"].yawBase:get() == "off" then
        refs.yaw_base:override("Local View")
        refs.freestanding:override(menu["anti aim"].freestanding:get())
    elseif menu["anti aim"].yawBase:get() == "Forward" then
        refs.yaw_base:override("Local View")
        refs.yaw_offset:override(180)
        refs.freestanding:override(false)
    elseif menu["anti aim"].yawBase:get() == "Left" then
        refs.yaw_base:override("Local View")
        refs.yaw_offset:override(-90)
        refs.freestanding:override(false)
    elseif menu["anti aim"].yawBase:get() == "Right" then
        refs.yaw_base:override("Local View")
        refs.yaw_offset:override(90)
        refs.freestanding:override(false)
    end    

    refs.antiback_stab:override(menu["anti aim"].anti_backstab:get())
    refs.freestanding:override(menu["anti aim"].freestanding:get())
    refs.disableModifiers:override(menu["anti aim"].freestanding.disableModifiers:get())
    refs.bodyFreestanding:override(menu["anti aim"].freestanding.bodyFreestand:get())
end

Functions.customViewModel = function()
    if menu.utility_group_3.viewmodel:get() then
        cvar.viewmodel_fov:float(menu.utility_group_3.viewmodel.fieldOfView:get(), true)
        cvar.viewmodel_offset_x:float(menu.utility_group_3.viewmodel.offsetX:get() / 10, true)
        cvar.viewmodel_offset_y:float(menu.utility_group_3.viewmodel.offsetY:get() / 10, true)
        cvar.viewmodel_offset_z:float(menu.utility_group_3.viewmodel.offsetZ:get() / 10, true)
    else
        cvar.viewmodel_fov:float(60)
        cvar.viewmodel_offset_x:float(2.5)
        cvar.viewmodel_offset_y:float(0)
        cvar.viewmodel_offset_z:float(-5)
    end
end

Functions.disableCustomViewModel = function()
    cvar.viewmodel_fov:float(60)
    cvar.viewmodel_offset_x:float(2.5)
    cvar.viewmodel_offset_y:float(0)
    cvar.viewmodel_offset_z:float(-5)
end    

menu.utility_group_3.viewmodel.fieldOfView:set_callback(Functions.customViewModel)
menu.utility_group_3.viewmodel.offsetX:set_callback(Functions.customViewModel)
menu.utility_group_3.viewmodel.offsetY:set_callback(Functions.customViewModel)
menu.utility_group_3.viewmodel.offsetZ:set_callback(Functions.customViewModel)

local aspect_ratio_switch = menu.utility_group_3.aspectRatio
local aspect_ratio_slider = menu.utility_group_3.aspectRatio.aspectRatioValue

local aspectRatioValues = {
    ["4:3"] = 1.333,
    ["16:9"] = 1.778,
    ["16:10"] = 1.6,
    ["21:9"] = 2.333
}

local function setAspectRatio(value)
    aspect_ratio_slider:set(value * 10)
end

local function setAspectRatio4_3()
    setAspectRatio(aspectRatioValues["4:3"])
end

local function setAspectRatio16_9()
    setAspectRatio(aspectRatioValues["16:9"])
end

local function setAspectRatio16_10()
    setAspectRatio(aspectRatioValues["16:10"])
end

local function setAspectRatio21_9()
    setAspectRatio(aspectRatioValues["21:9"])
end

menu.utility_group_3.aspectRatio.aspectRatio4_3Button:set_callback(setAspectRatio4_3)
menu.utility_group_3.aspectRatio.aspectRatio16_9Button:set_callback(setAspectRatio16_9)
menu.utility_group_3.aspectRatio.aspectRatio16_10Button:set_callback(setAspectRatio16_10)
menu.utility_group_3.aspectRatio.aspectRatio21_9Button:set_callback(setAspectRatio21_9)

Functions.render_watermark = function()
    local screensize = render.screen_size()
    local text = "\aFFFFFFFFS H A D O W \aA78D9FFFY A W"
    local textSize = render.measure_text(1, "d", text)
    
    local x = (screensize.x / 2) - (textSize.x / 2) +20
    local y = screensize.y - textSize.y - 8 

    render.text(2, vector(x, y), color(255, 255, 255, 255), "d", text)
end

Functions.fastLadder = function(cmd)
    if not menu.utility_group_2.fastLadder:get() then
        return
    end

    local currentPlayer = player()
    if not currentPlayer then
        return
    end

    if currentPlayer.m_MoveType ~= 9 then
        return
    end

    local weaponIndex = currentPlayer:get_player_weapon():get_weapon_index()
    for k, v in pairs({43, 44, 45, 46, 47, 48}) do
        if weaponIndex == v then
            return
        end
    end

    if cmd.sidemove == 0 then
        cmd.view_angles.y = cmd.view_angles.y + 45
    end

    if cmd.in_forward and cmd.sidemove < 0 then
        cmd.view_angles.y = cmd.view_angles.y + 90
    end

    if cmd.in_back and cmd.sidemove > 0 then
        cmd.view_angles.y = cmd.view_angles.y + 90
    end

    cmd.in_moveleft = cmd.in_back
    cmd.in_moveright = cmd.in_forward

    if cmd.view_angles.x < 0 then
        cmd.view_angles.x = -45
    end
end

local cvarSettings = {
    {cvar = {cvar.r_shadows, cvar.cl_csm_static_prop_shadows, cvar.cl_csm_shadows, cvar.cl_csm_world_shadows, cvar.cl_foot_contact_shadows, cvar.cl_csm_viewmodel_shadows, cvar.cl_csm_rope_shadows, cvar.cl_csm_sprite_shadows, cvar.cl_foot_contact_shadows}},
    {cvar = {cvar.r_drawparticles, cvar.cl_detail_multiplier}},
    {cvar = {cvar.r_eyesize, cvar.r_eyeshift_z, cvar.r_eyeshift_y, cvar.r_eyeshift_x, cvar.r_eyemove, cvar.r_eyegloss}},
    {cvar = {cvar.r_drawtracers_firstperson, cvar.r_drawtracers}},
    {cvar = {cvar.mat_postprocess_enable}},
    {cvar = {cvar.fog_enable_water_fog}},
    {cvar = {cvar.m_rawinput, cvar.cl_bob_lower_amt}},
    {cvar = {cvar.cl_disablefreezecam, cvar.cl_freezecampanel_position_dynamic, cvar.cl_freezecameffects_showholiday}},
    {cvar = {cvar.r_drawropes, cvar.r_drawsprites, cvar.func_break_max_pieces, cvar.mat_drawwater}},
    {cvar = {cvar.cl_disablehtmlmotd, cvar.r_dynamic, cvar.cl_autohelp, cvar.r_drawdecals, cvar.muzzleflash_light}}
}

Functions.fpsBoost = function()
    if not menu.utility_group_2.fpsBoost:get() then
        for _, group in ipairs(cvarSettings) do
            for _, c in ipairs(group.cvar) do
                c:int(1)
            end
        end
        return
    end

    local fpsBoostOption = menu.utility_group_2.fpsBoost.fpsBoostOptions:get()
    if fpsBoostOption == 1 then
        cvar.r_shadows:int(0)
        cvar.cl_csm_static_prop_shadows:int(0)
        cvar.cl_csm_shadows:int(0)
        cvar.cl_csm_world_shadows:int(0)
        cvar.cl_foot_contact_shadows:int(0)
        cvar.cl_csm_viewmodel_shadows:int(0)
        cvar.cl_csm_rope_shadows:int(0)
        cvar.cl_csm_sprite_shadows:int(0)
        cvar.cl_foot_contact_shadows:int(0)
    else
        cvar.r_shadows:int(1)
        cvar.cl_csm_static_prop_shadows:int(1)
        cvar.cl_csm_shadows:int(1)
        cvar.cl_csm_world_shadows:int(1)
        cvar.cl_foot_contact_shadows:int(1)
        cvar.cl_csm_viewmodel_shadows:int(1)
        cvar.cl_csm_rope_shadows:int(1)
        cvar.cl_csm_sprite_shadows:int(1)
        cvar.cl_foot_contact_shadows:int(1)
    end

    if fpsBoostOption == 2 then
        cvar.r_drawparticles:int(0)
        cvar.cl_detail_multiplier:int(0)

        cvar.r_eyesize:int(0)
        cvar.r_eyeshift_z:int(0)
        cvar.r_eyeshift_y:int(0)
        cvar.r_eyeshift_x:int(0)
        cvar.r_eyemove:int(0)
        cvar.r_eyegloss:int(0)

        cvar.r_drawtracers_firstperson:int(0)
        cvar.r_drawtracers:int(0)

    elseif fpsBoostOption == 3 then
        for _, group in ipairs(cvarSettings) do
            for _, c in ipairs(group.cvar) do
                c:int(0)
            end
        end
    else
        for _, group in ipairs(cvarSettings) do
            for _, c in ipairs(group.cvar) do
                c:int(1)
            end
        end
    end
end
Functions.disableFpsBoost = function()
    for _, group in ipairs(cvarSettings) do
        for _, c in ipairs(group.cvar) do
            c:int(1)
            end
        end
end    

menu.utility_group_2.fpsBoost:set_callback(Functions.fpsBoost)
menu.utility_group_2.fpsBoost.fpsBoostOptions:set_callback(Functions.fpsBoost)

events.cs_win_panel_match:set(function()
    if menu.utility_group_1.autoDisconnect:get() then
        utils.console_exec("disconnect")
    end
end)

events.round_start:set(function()
    if menu.utility_group_1.clearConsole:get() then
        utils.console_exec("clear")
    end

    l_r_delay_ind = false
    l_r_last_switch_tick = 0
    l_r_hold_tick_counter = 0
    l_r_hold_cycle_counter = 0
    l_r_random_target_delay = 0
    l_r_phase_index = 1
    l_r_last_phase_change_tick = 0

    bomba_current_delay = 0
    bomba_target_delay = 0
    bomba_last_target_update_tick = 0
    bomba_is_bursting = false
    bomba_burst_end_tick = 0
    bomba_last_toggle_tick = 0

    harmonic_last_toggle_tick = 0
    harmonic_time_offset = 0

    modifier_delay_ind = false
    modifier_last_switch_tick = 0
    modifier_hold_tick_counter = 0
    modifier_hold_cycle_counter = 0
    modifier_phase_index = 1
    modifier_last_phase_change_tick = 0

    chaotic_current_yaw_offset = 0
    chaotic_last_update_tick = 0
    chaotic_next_update_delay = 0
    chaotic_target_yaw_offset = 0
    chaotic_is_bursting = false
    chaotic_burst_end_tick = 0
    chaotic_wave_start_time = 0

    body_yaw_random_current_value = 0
    body_yaw_random_last_switch_tick = 0
    body_yaw_random_next_switch_delay = 0

    local lp = player()
    if not lp then return end
    local team_prefix_for_logic = (lp.m_iTeamNum == 2) and "t" or "ct"
    local antiAimState = menu["anti aim states"].cache[team_prefix_for_logic][states[Utility.getCondition()][1]]

    if antiAimState and antiAimState.antiBruteforce and antiAimState.antiBruteforce:get() and antiAimState.antiBruteforce.antiBruteforceReset:get() then
        anti_bruteforce_active_override = false
        anti_bruteforce_current_left_add = antiAimState.leftYawOffset:get() 
        anti_bruteforce_current_right_add = antiAimState.rightYawOffset:get() 
        anti_bruteforce_custom_phase_index = 1
        anti_bruteforce_last_shot_tick = 0
        anti_bruteforce_log_active = false
        last_displayed_ab_left = 0
        last_displayed_ab_right = 0
        if aimbot_logs then
            print_raw(Utility.color_text({"Anti Bruteforce reset for new round!", SHADOWYAW_COLOR_HEX}))
        end
    end
end)

local function interpolate(a, b, t)
    return a + t * (b - a)
end

Functions.grenade_toss = {}

function Functions.grenade_toss.adjust(value)
    if value.x > -10 then
        value.x = 0.9 * value.x + 9
    else
        value.x = 1.125 * value.x + 11.25
    end
    return value
end

function Functions.grenade_toss.calculate_grenade_path(desired_angles, speed, strength, current_velocity)
    desired_angles.x = desired_angles.x - 10 + math.abs(desired_angles.x) / 9

    local direction = vector():angles(desired_angles)
    local player_velocity = current_velocity * 1.25

    local adjusted_speed = math.clamp(speed * 0.9, 15, 750)
    local strength_factor = math.clamp(strength, 0, 1)

    adjusted_speed = adjusted_speed * interpolate(0.3, 1.0, strength_factor)

    local new_direction = direction

    for _ = 1, 8 do
        new_direction = (direction * (new_direction * adjusted_speed + player_velocity):length() - player_velocity) / adjusted_speed
        new_direction:normalize()
    end

    local final_angles = new_direction:angles()

    final_angles = Functions.grenade_toss.adjust(final_angles)

    return final_angles
end

function Functions.grenade_toss.on_grenade_view_override(event)
    if not menu.utility_group_2.superToss:get() then return end

    local lp = entity.get_local_player()
    if not lp then return end
    local player_weapon = lp:get_player_weapon()
    if not player_weapon then return end
    local weapon_info = player_weapon:get_weapon_info()
    if not weapon_info then return end
    event.angles = Functions.grenade_toss.calculate_grenade_path(event.angles, weapon_info.throw_velocity, player_weapon.m_flThrowStrength, event.velocity)
end

function Functions.grenade_toss.on_move(cmd)
    if not menu.utility_group_2.superToss:get() then return end
    
    if cmd.jitter_move ~= true then return end 

    local lp = entity.get_local_player()
    if not lp then return end
    local player_weapon = lp:get_player_weapon()
    if not player_weapon then return end
    local weapon_info = player_weapon:get_weapon_info()
    if not weapon_info or weapon_info.weapon_type ~= 9 then return end
    if player_weapon.m_fThrowTime < (globals.curtime - to_time(globals.clock_offset)) then return end
    
    cmd.in_speed = true
    local simulation_context = lp:simulate_movement()
    simulation_context:think()
    cmd.view_angles = Functions.grenade_toss.calculate_grenade_path(cmd.view_angles, weapon_info.throw_velocity, player_weapon.m_flThrowStrength, simulation_context.velocity)
end

local supertoss_createmove_event_handle = nil
local supertoss_grenade_override_view_event_handle = nil

local function register_supertoss_events()
    if not supertoss_createmove_event_handle then
        supertoss_createmove_event_handle = events.createmove:set(Functions.grenade_toss.on_move)
    end
    if not supertoss_grenade_override_view_event_handle then
        supertoss_grenade_override_view_event_handle = events.grenade_override_view:set(Functions.grenade_toss.on_grenade_view_override)
    end
end

local function unregister_supertoss_events()
    if supertoss_createmove_event_handle then
        events.createmove:set(nil, false, supertoss_createmove_event_handle)
        supertoss_createmove_event_handle = nil
    end
    if supertoss_grenade_override_view_event_handle then
        events.grenade_override_view:set(nil, false, supertoss_grenade_override_view_event_handle)
        supertoss_grenade_override_view_event_handle = nil
    end
end

menu.utility_group_2.superToss:set_callback(function(value)
    if value then
        register_supertoss_events()
    else
        unregister_supertoss_events()
    end
end)

if menu.utility_group_2.superToss:get() then
    register_supertoss_events()
end

local e_global = {
  SCREEN = render.screen_size( )
}

local render_rect_original = render.rect
local render_shadow_original = render.shadow

function render.rect( position, size, ... )
	local a, b = position, position + size
	return render_rect_original( a, b, ... )
end

function render.shadow( position, size, ... )
	local a, b = position, size
	return render_shadow_original( a, b, ... )
end

_G.aimbot_logs = _G.aimbot_logs or {}
aimbot_logs.groups = aimbot_logs.groups or {[0] = 'generic', 'head', 'chest', 'stomach', 'left arm', 'right arm', 'left leg', 'right leg', 'neck', 'generic', 'gear'}
aimbot_logs.list = aimbot_logs.list or {}

function aimbot_logs.push( text, time, type, ... )
    if not aimbot_logs.list then aimbot_logs.list = {} end
	table.insert( aimbot_logs.list, 1, {
		alpha = smoothy.new( 0 ),
		type = type or 'none',
		time = time,
		animation = smoothy.new( -90 ),
		text = text,
		args = {...}
	} ) 
end

function aimbot_logs.shot_event( event )
	if not menu.utility_group_3.logs:get( ) then
		return
	end
    if not aimbot_logs then return end

	local prefix_style = menu.utility_group_3.logs.prefix_type:get( )
	local prefix_text_hardcoded = "shadowyaw" 

	local first_color = menu.utility_group_3.logs.first_color:get( )
	local second_color = menu.utility_group_3.logs.second_color:get( )

	local time = menu.utility_group_3.logs.time:get( )

	local formatted_prefix_content = prefix_text_hardcoded 

	if prefix_style == 'gradient' then 
		formatted_prefix_content = gradient.text( prefix_text_hardcoded, false, {first_color:alpha_modulate( 255 ), second_color:alpha_modulate( 255 )})
	end

	local prefix = string.format( '[%s\aDEFAULT] ', formatted_prefix_content )

	if event.state == nil then
		local text = string.format( '%sHit \f%s\aDEFAULT in the \f%s\aDEFAULT for \f%s\aDEFAULT damage', prefix, event.target:get_name( ), aimbot_logs.groups[event.hitgroup], event.damage )

		aimbot_logs.push( text, time, 'hit', event.target:get_steam_avatar( ) )
		return
	end

	local text = string.format( '%sMissed \f%s\aDEFAULT in the \f%s\aDEFAULT due to \f%s', prefix, event.target:get_name(), aimbot_logs.groups[event.wanted_hitgroup], event.state )
	aimbot_logs.push( text, time, 'miss', event.target:get_steam_avatar( ) )
end

local last_fade_animation_type = nil

function aimbot_logs.handle( )
    if not aimbot_logs or not aimbot_logs.list then return end

    local current_fade_animation_type = menu.utility_group_3.logs.fade_animation_type:get()

    if last_fade_animation_type ~= current_fade_animation_type then
        for _, value in ipairs(aimbot_logs.list) do
            value.alpha = smoothy.new(current_fade_animation_type == 'instant' and (value.time <= 0 and 0 or 1) or 0)
            value.animation = smoothy.new(current_fade_animation_type == 'instant' and 0 or -90)
        end
        last_fade_animation_type = current_fade_animation_type
    end

    local custom_color = menu.utility_group_3.logs.custom_color:get( )
    local background_enabled_for_logs = menu.utility_group_3.logs.background:get( )
    local glow_strength = menu.utility_group_3.logs.glow_strength:get()
    local glow_color = menu.utility_group_3.logs.glow_color:get()
    local show_avatar_icon_for_logs = menu.utility_group_3.logs.show_avatar_icon:get()
    local fade_animation_type = menu.utility_group_3.logs.fade_animation_type:get()
    local limit = menu.utility_group_3.logs.limit:get( )
    local additional = menu.utility_group_3.logs.offset:get( )
    local position = ( e_global.SCREEN / 2 ) + vector( 0, additional )

    for i = #aimbot_logs.list, 1, -1 do
        local value = aimbot_logs.list[i]
        value.time = value.time - globals.frametime
        if value.time <= 0 then
            if value.type == 'anti_bruteforce' then
                anti_bruteforce_log_active = false
            end
            table.remove( aimbot_logs.list, i )
        end
    end

    local rendered_count = 0
    local current_y_offset = 0

    for key, value in ipairs( aimbot_logs.list ) do
        local should_render_this_log = (menu.utility_group_3.logs:get() and rendered_count < limit) or (value.type == 'welcome')

        if should_render_this_log then
            local colors = {
                ['hit'] = custom_color and menu.utility_group_3.logs.hit_color:get( ) or color( '52D449FF' ),
                ['miss'] = custom_color and menu.utility_group_3.logs.miss_color:get( ) or color( 'D44949FF' ),
                ['welcome'] = color( 'A78D9FFF' ),
                ['anti_bruteforce'] = color( 'A78D9FFF' )
            }

            local current_color = colors[value.type]

            if string.find( value.text, '\f' ) then
                value.text = string.gsub( value.text, '\f', string.format( '\a%s', current_color:to_hex( ) ) )
            end

            local alpha = 0
            local vertical_fade_animation = 0

            if fade_animation_type == 'instant' then
                alpha = value.time <= 0 and 0 or 255
            else
                alpha = value.alpha( 0.08, value.time <= 0.1 and 0 or 1 )
                vertical_fade_animation = value.animation( 0.08, value.time <= 0.1 and 50 or 0 )
            end
            
            local background_height = 23

            local log_display_y = position.y + current_y_offset + vertical_fade_animation
            local text_y = background_enabled_for_logs and log_display_y + ( background_height / 2 ) - ( render.measure_text( 1, '', value.text ).y / 2 ) or log_display_y

            local avatar_size = vector( 13, 13 ) 
            local avatar_text_spacing = 5
            local background_horizontal_padding = 10

            local content_text_width = render.measure_text(1, '', value.text).x
            local effective_avatar_width = (show_avatar_icon_for_logs and value.type ~= 'welcome' and value.type ~= 'anti_bruteforce') and (avatar_size.x + avatar_text_spacing) or 0

            local content_visual_width = content_text_width + effective_avatar_width

            local background_weight = content_visual_width + (2 * background_horizontal_padding)
            
            local background_x_start = position.x - (background_weight / 2)

            if background_enabled_for_logs then
              local bg_color = menu.utility_group_3.logs.custom_background_color:get() and menu.utility_group_3.logs.background_color:get() or color(0, 0, 0, 230)
              
              render.rect( vector( background_x_start, log_display_y ), vector( background_weight, background_height ), bg_color, 6 ) 
              render.shadow( vector( background_x_start, log_display_y ), vector( background_weight, background_height ), current_color:alpha_modulate( glow_strength ), 30, nil, 6 )
              
              if show_avatar_icon_for_logs and value.type ~= 'welcome' and value.type ~= 'anti_bruteforce' then
                  local avatar_draw_x = background_x_start + background_horizontal_padding
                  local avatar_draw_y = log_display_y + (background_height / 2) - (avatar_size.y / 2)
                  render.texture( value.args[1], vector( avatar_draw_x, avatar_draw_y ), avatar_size, color( 255, 255 * alpha ), nil, 2 )
              end
            end

            local text_draw_x = background_x_start + background_horizontal_padding
            if show_avatar_icon_for_logs and value.type ~= 'welcome' and value.type ~= 'anti_bruteforce' then
                text_draw_x = text_draw_x + avatar_size.x + avatar_text_spacing
            end
            
            local glow_size = render.measure_text( 1, '', value.text ) - vector( 0, 10 )
            local glow_position = vector( text_draw_x - 1, text_y + ( background_enabled_for_logs and 7 or 7 ) ) 

            render.shadow( glow_position, vector( glow_size.x, 1 ), glow_color:alpha_modulate( glow_strength ), ( background_enabled_for_logs and 80 or nil ), nil, 6 ) 
            render.rect( glow_position, vector( glow_size.x, 1 ), glow_color:alpha_modulate( glow_strength / 2 ), 0 ) 
            
            render.text( 1, vector( text_draw_x, text_y ), color(255, 255 * alpha ), '', value.text )

            current_y_offset = current_y_offset + ( background_enabled_for_logs and ( background_height + 5 ) or 13 ) * alpha
            rendered_count = rendered_count + 1
        end
	end
end

local function in_air(player)
    local flags = player.m_fFlags
    if bit.band(flags, 1) == 0 then
        return true
    end
    return false
end

local function air_lag_logic(cmd)
    if not menu.utility_group_3.airlag:get() then return end

    local lp = player()
    if not lp then return end
    if bit.band(lp.m_fFlags, 1) == 1 then return end

    if lp.m_vecVelocity:length() >= 130 then
        cmd.force_defensive = true
        rage.exploit:allow_charge(true)
        rage.exploit:force_charge()
        if cmd.tickcount % (2 + menu.utility_group_3.airlag.airlagTicks:get()) == 0 then
            rage.exploit:force_teleport()
        end
    end
end

local function no_fall_damage_logic(cmd)
    if not menu.utility_group_2.noFallDmg:get() then return end

    local lp = player()
    if not lp then return end
    local vec = lp.m_vecVelocity
    local l_o = lp.m_vecOrigin
    local tracer = utils.trace_line(l_o, vector(l_o.x, l_o.y, l_o.z - 500), nil, nil, 1)

    if(l_o.z - tracer.end_pos.z <= 70 and l_o.z - tracer.end_pos.z >= 12 and in_air(lp) and vec.z < -450) then
        cmd.in_duck = true
    end
end

Functions.render_no_fall_damage_indicator = function()
end

local clantag_str = {
				    " ",
    "s",
    "sha",
    "shado",
    "shadowy",
    "shadowyaw",
    "shadowyaw",
    "shadowyaw",
    "shadowyaw",
    "shadowyaw",
    "shadowy",
    "shado",
    "sha",
    "s",
				    " ",
}

local anim_id = 1
local delay_time = 0
local clantag_active_state = false

local function clan_anim()
    local ret_str = clantag_str[anim_id]
    if anim_id < 15 then
        anim_id = anim_id + 1
    else
        anim_id = 1
    end
    return ret_str
end

local function clantag_en(bool)
    if not globals.is_in_game then return end
    if not globals.choked_commands then return end
    if delay_time + 30 < globals.tickcount then
        ui.find("Miscellaneous", "Main", "In-Game", "Clan Tag"):override(false)
        common.set_clan_tag(bool and clan_anim() or "")
        delay_time = globals.tickcount
    elseif delay_time > globals.tickcount then
        delay_time = globals.tickcount
    end
end

local function updateClantag()
    local clantag_enabled_in_ui = menu.utility_group_3.clantag:get()

    if clantag_enabled_in_ui then
        if not clantag_active_state then
            clantag_active_state = true
            anim_id = 1
            delay_time = 0
        end
        clantag_en(true)
    else
        if clantag_active_state then
            common.set_clan_tag("")
            clantag_active_state = false
            anim_id = 1
            delay_time = 0
        end
    end
end

ffi.cdef[[
    typedef void*(__thiscall* get_client_entity_t)(void*, int);
    typedef struct {
        char  pad_0000[20];
        int m_nOrder;
        int m_nSequence;
        float m_flPrevCycle;
        float m_flWeight;
        float m_flWeightDeltaRate;
        float m_flPlaybackRate;
        float m_flCycle;
        void *m_pOwner;
        char  pad_0038[4];
    } animstate_layer_t;
]]

local uintptr_t = ffi.typeof("uintptr_t**")
local get_entity_address = utils.get_vfunc("client.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")

local on_ground = 0
local ground_time = 0

local function hit_ground()
    local lp = entity.get_local_player()
    if not lp then return end
    if bit.band(lp.m_fFlags, 1) == 1 then
        on_ground = on_ground + 1
    else
        on_ground = 0
        ground_time = globals.curtime + 1
    end
    return on_ground > 1 and ground_time > globals.curtime
end

local function anim_update(lp)
    lp = entity.get_local_player()
    if lp == nil then return end
    if not lp:is_alive() then return end
    if lp:get_index() == nil then return end
    local lp_index = get_entity_address(lp:get_index())
    local moving = lp.m_vecVelocity:length() > 5
    local in_air_flag = bit.band(lp.m_fFlags, 1) == 0

    if not menu.utility_group_2.animBreakers:get() then return end

    if in_air_flag == false then
        if menu.utility_group_2.animBreakers.animGround:get() == 'Static' then
            lp.m_flPoseParameter[0] = 1
            ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override('Sliding')
        elseif menu.utility_group_2.animBreakers.animGround:get() == 'Sliding' then
            lp.m_flPoseParameter[10] = 0
            ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override('Walking')
        elseif menu.utility_group_2.animBreakers.animGround:get() == 'Moonwalk' then
            lp.m_flPoseParameter[7] = 1
            ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override('Walking')
        elseif menu.utility_group_2.animBreakers.animGround:get() == 'Jitter' then
            lp.m_flPoseParameter[0] = globals.tickcount % 4 > 1 and menu.utility_group_2.animBreakers.animGroundAmount:get()/100 or 1
            ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override(globals.tickcount % 8 > 3 and 'Walking' or 'Sliding')
        elseif menu.utility_group_2.animBreakers.animGround:get() == 'Other Jitter' then
            lp.m_flPoseParameter[0] = math.random(menu.utility_group_2.animBreakers.animGroundAmount:get()/10, 10)/10
            ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override(globals.tickcount % 8 > 3 and 'Walking' or 'Sliding')
        end
    else
        if menu.utility_group_2.animBreakers.animAir:get() == 'Static' then
            lp.m_flPoseParameter[6] = 1
        elseif menu.utility_group_2.animBreakers.animAir:get() == 'Moonwalk' then
            ffi.cast('animstate_layer_t**', ffi.cast('uintptr_t', lp_index) + 0x2990)[0][6].m_flWeight = 1
        elseif menu.utility_group_2.animBreakers.animAir:get() == 'Jitter' then 
            lp.m_flPoseParameter[6] = globals.tickcount % 4 > 1 and 1 or 0
        elseif menu.utility_group_2.animBreakers.animAir:get() == 'Other Jitter' then
            lp.m_flPoseParameter[3] = math.random(0, 10)/10
            lp.m_flPoseParameter[6] = math.random(0, 10)/10
        elseif menu.utility_group_2.animBreakers.animAir:get() == 'Flying' then 
            ffi.cast('animstate_layer_t**', ffi.cast('uintptr_t', lp_index) + 0x2990)[0][5].m_flWeight = 1
        end
    end

    if menu.utility_group_2.animBreakers.animOther:get('Zero Pitch On Land') then
        if hit_ground() then
            lp.m_flPoseParameter[12] = 0.7
        end
    end
    if menu.utility_group_2.animBreakers.animOther:get('Move Lean') and not menu.utility_group_2.animBreakers.animOther:get('EarthQuake') then
        if moving then
            ffi.cast('animstate_layer_t**', ffi.cast('uintptr_t', lp_index) + 0x2990)[0][12].m_flWeight = menu.utility_group_2.animBreakers.animOtherLean:get()/100
        end
    end

    if menu.utility_group_2.animBreakers.animOther:get('EarthQuake') then
        ffi.cast('animstate_layer_t**', ffi.cast('uintptr_t', lp_index) + 0x2990)[0][12].m_flWeight = math.random(0, 100)/100
    end
end

local hitmarkers = {}
Functions.render_hitmarker = function()
    if not menu.utility_group_3.hitmarker:get() then return end

    for i = #hitmarkers, 1, -1 do
        local hm = hitmarkers[i]
        local alpha = math.max(0, 255 - (globals.curtime - hm.time) * 255 / 1.0)
        
        if alpha <= 0.1 then
            table.remove(hitmarkers, i)
        else
            local screen_pos = render.world_to_screen(hm.pos)
            if screen_pos then
                local size = 10
                local color_hm = color(255, 255, 255, alpha)

                render.line(vector(screen_pos.x - size, screen_pos.y), vector(screen_pos.x + size, screen_pos.y), color_hm)
                render.line(vector(screen_pos.x, screen_pos.y - size), vector(screen_pos.x, screen_pos.y + size), color_hm)
            end
        end
    end
end

local damage_indicators = {}
Functions.render_dmg_indicator = function()
    if not menu.utility_group_3.dmgIndicator:get() then return end

    local path = menu.utility_group_3.dmgIndicator
    local font_map = {
        ["Default"] = 1,
        ["Small"] = 2,
        ["Console"] = 3,
        ["Bold"] = 4,
    }
    local font_id = font_map[path.font:get()] or 1

    for i = #damage_indicators, 1, -1 do
        local di = damage_indicators[i]
        local alpha = math.max(0, 255 - (globals.curtime - di.time) * 255 / 1.5)
        local offset_y = (globals.curtime - di.time) * 20

        if alpha <= 0.1 then
            table.remove(damage_indicators, i)
        else
            local screen_pos = render.world_to_screen(di.pos)
            if screen_pos then
                local display_x = screen_pos.x + path.x:get()
                local display_y = screen_pos.y + path.y:get() - offset_y

                render.text(font_id, vector(display_x, display_y), color(path.color:get().r, path.color:get().g, path.color:get().b, alpha), "c", "-" .. di.damage)
            end
        end
    end
end

local safe_head_original_settings = {}
local safe_head_was_active = false
local safe_head_last_weapon = nil
local safe_head_last_state = false

local function save_safe_head_original_settings()
    safe_head_original_settings = {
        yaw_offset = refs.yaw_offset:get(),
        inverter = refs.inverter:get(),
        options = refs.options:get(),
        hidden_yaw = refs.hidden_yaw:get(),
        yaw_modifier = refs.yaw_modifier:get(),
    }
end

local function restore_safe_head_original_settings()
    refs.yaw_offset:override()
    refs.inverter:override()
    refs.options:override()
    refs.hidden_yaw:override()
    refs.yaw_modifier:override()
    safe_head_was_active = false
end

local function handle_safe_head(cmd)
    if not menu["anti aim"].safe_head_on_knife:get() then
        if safe_head_was_active then
            restore_safe_head_original_settings()
        end
        return
    end

    local lp = player()
    if not lp or not lp:is_alive() then
        if safe_head_was_active then
            restore_safe_head_original_settings()
        end
        return
    end

    local weapon = lp:get_player_weapon()
    local is_knife_or_zeus = weapon and (weapon:get_classname() == "CKnife" or weapon:get_classname() == "CWeaponTaser")
    
    if weapon ~= safe_head_last_weapon or (safe_head_was_active and not (is_knife_or_zeus and bit.band(lp.m_fFlags, 1) == 0 and (lp.m_flDuckAmount > 0.7 or refs.fd:get()))) then
        if safe_head_was_active then
            restore_safe_head_original_settings()
        end
        safe_head_last_weapon = weapon
    end

    local in_air = bit.band(lp.m_fFlags, 1) == 0
    local crouching = lp.m_flDuckAmount > 0.7 or refs.fd:get()
    local should_activate = is_knife_or_zeus and in_air and crouching

    if should_activate then
        if not safe_head_was_active then
            save_safe_head_original_settings()
            safe_head_was_active = true
        end
        
        refs.yaw_offset:override(-15)
        refs.inverter:override(true)
        refs.options:override("")
        refs.hidden_yaw:override(false)
        refs.yaw_modifier:override("Disabled")
    elseif safe_head_was_active then
        restore_safe_head_original_settings()
    end

    safe_head_last_state = should_activate
end

events.unload:set(function()
    if safe_head_was_active then
        restore_safe_head_original_settings()
    end
end)

local eventsFunctions = {
    createmove = {
        function(cmd)
            Functions.antiaim()
            Functions.fastLadder(cmd)
            
            if menu.utility_group_3.aspectRatio:get() then
                cvar.r_aspectratio:float(menu.utility_group_3.aspectRatio.aspectRatioValue:get() / 10)
            else
                cvar.r_aspectratio:float(0)
            end

            if menu.utility_group_3.viewmodel:get() then
                Functions.customViewModel()
            else
                Functions.disableCustomViewModel()
            end

            air_lag_logic(cmd)
            no_fall_damage_logic(cmd)
            updateClantag()

            handle_safe_head(cmd)
        end
    },
    shutdown = {
        function()
            Functions.disableCustomViewModel()
            Functions.disableFpsBoost()
            Utility.disableRefs()
            cvar.r_aspectratio:float(0)
            unregister_supertoss_events()
            common.set_clan_tag("")
            if safe_head_was_active then
                restore_safe_head_original_settings()
            end
        end
    },
    render = {
        function()
            Functions.render_watermark()
            if aimbot_logs then aimbot_logs.handle() end
            if menu.utility_group_3.hitmarker:get() then
                Functions.render_hitmarker()
            end
            if menu.utility_group_3.dmgIndicator:get() then
                Functions.render_dmg_indicator()
            end
        end
    },
    post_update_clientside_animation = {
        function()
            if menu.utility_group_2.animBreakers:get() then
                anim_update()
            end
        end
    },
    aim_ack = {
        function(e)
            if aimbot_logs then aimbot_logs.shot_event(e) end

            if menu.utility_group_3.console_logs:get() and menu.utility_group_3.console_logs.hit_logs:get() then
                local target = entity.get(e.target)
                if not target then return end

                local player_name = target:get_name()
                local damage = e.damage
                local wanted_damage = e.wanted_damage
                local hitgroup = aimbot_logs.groups[e.hitgroup]
                local wanted_hitgroup = aimbot_logs.groups[e.wanted_hitgroup]
                local hitchance = e.hitchance
                local state = e.state
                local backtrack = e.backtrack
                local health = target["m_iHealth"]

                local display_state = state
                if state == "spread" then display_state = "\a" .. SHADOWYAW_COLOR_HEX .. "spread"
                elseif state == "prediction error" then display_state = "\a" .. SHADOWYAW_COLOR_HEX .. "pred. error"
                elseif state == "correction" then display_state = "\a" .. SHADOWYAW_COLOR_HEX .. "resolver"
                elseif state == "misprediction" then display_state = "\a" .. SHADOWYAW_COLOR_HEX .. "misprediction"
                elseif state == "lagcomp failure" then display_state = "\a" .. SHADOWYAW_COLOR_HEX .. "lagcomp failure"
                end

                local console_log_message_raw
                local console_log_message_colored

                if state == nil then 
                    console_log_message_raw = ("hit %s in the %s for %d("..string.format("%.f", wanted_damage)..") damage (hp: "..health..") (aimed: "..wanted_hitgroup..") (bt: %s)"):format(player_name, hitgroup, damage, tostring(backtrack))
                    
                    console_log_message_colored = ("\a%s[shadowyaw]\aD5D5D5FF hit %s in the %s for %d(%s) damage (hp: %s) (aimed: %s) (bt: %s)"):format(
                        SHADOWYAW_COLOR_HEX,
                        player_name, hitgroup, damage, string.format("%.f", wanted_damage), health, wanted_hitgroup, tostring(backtrack)
                    )
                else 
                    console_log_message_raw = ('missed shot in %s in the %s due to %s (bt: %s) (hc: %.0f) (damage: %.0f)'):format(player_name, wanted_hitgroup, state, tostring(backback), hitchance, wanted_damage)
                    
                    console_log_message_colored = ("\a%s[shadowyaw]\aFFFFFFFF missed shot in %s in the %s due to %s \aFFFFFFFF(bt: %s) (hc: %.0f) (damage: %.0f)"):format(
                        SHADOWYAW_COLOR_HEX,
                        player_name, wanted_hitgroup, display_state,
                        tostring(backtrack), hitchance, wanted_damage
                    )
                end

                print_dev(console_log_message_raw)
                print_raw(console_log_message_colored)
            end
            if e.state == nil and menu.utility_group_3.hitmarker:get() then
                local target_entity = entity.get(e.target)
                if target_entity then
                    local hit_pos = target_entity:get_hitbox_position(e.hitgroup) or target_entity.m_vecOrigin
                    table.insert(hitmarkers, {pos = hit_pos, time = globals.curtime})
                end
            end
            if e.state == nil and menu.utility_group_3.dmgIndicator:get() then
                local target_entity = entity.get(e.target)
                if target_entity then
                    local hit_pos = target_entity:get_hitbox_position(e.hitgroup) or target_entity.m_vecOrigin
                    table.insert(damage_indicators, {pos = hit_pos, time = globals.curtime, damage = e.damage})
                end
            end
        end
    },
    item_purchase = {
        function(e)
            if menu.utility_group_3.console_logs:get() and menu.utility_group_3.console_logs.buy_logs:get() then
                local playerz = entity.get(e.userid, true)
                local weaponz = e.weapon
                if weaponz == 'weapon_unknown' then return end
                if playerz == nil then return end
                if not playerz:is_enemy() then return end

                print_raw(('%s bought %s'):format(playerz:get_name(), weaponz))
                print_dev(('%s bought %s'):format(playerz:get_name(), weaponz))
            end
        end
    },
    bullet_impact = {
        function(e)
            local lp = player()
            if not lp or not lp:is_alive() then return end

            local shooter = entity.get(e.userid, true)
            if not shooter or not shooter:is_enemy() then return end

            local impact_pos = vector(e.x, e.y, e.z)
            local dist_to_lp = (lp.m_vecOrigin - impact_pos):length()
            if dist_to_lp > 100 then return end

            local team_prefix_for_logic = (lp.m_iTeamNum == 2) and "t" or "ct"
            local condition = Utility.getCondition()
            local antiAimState = menu["anti aim states"].cache[team_prefix_for_logic][states[condition][1]]

            if not antiAimState or not antiAimState.antiBruteforce:get() then return end

            local original_left_add = antiAimState.leftYawOffset:get()
            local original_right_add = antiAimState.rightYawOffset:get()
            local new_left_add = original_left_add
            local new_right_add = original_right_add

            local anti_bruteforce_type = antiAimState.antiBruteforce.antiBruteforceType:get()
            local anti_bruteforce_mode = antiAimState.antiBruteforce.antiBruteforceMode:get()

            if anti_bruteforce_type == "l/r adds" then
                if anti_bruteforce_mode == "pre-made [shdw]" then
                    new_left_add = original_left_add + math.random(-18, 18)
                    new_right_add = original_right_add + math.random(-18, 18)
                elseif anti_bruteforce_mode == "custom" then
                    local phase_count = antiAimState.antiBruteforce.abCustomPhaseCount:get()
                    local randomize_order = antiAimState.antiBruteforce.abCustomRandomizeOrder:get()

                    if randomize_order then
                        anti_bruteforce_custom_phase_index = math.random(1, phase_count)
                    else
                        anti_bruteforce_custom_phase_index = (anti_bruteforce_custom_phase_index % phase_count) + 1
                    end

                    if antiAimState.antiBruteforce["abCustomPhaseValueL" .. anti_bruteforce_custom_phase_index] then
                        new_left_add = antiAimState.antiBruteforce["abCustomPhaseValueL" .. anti_bruteforce_custom_phase_index]:get()
                    end
                    if antiAimState.antiBruteforce["abCustomPhaseValueR" .. anti_bruteforce_custom_phase_index] then
                        new_right_add = antiAimState.antiBruteforce["abCustomPhaseValueR" .. anti_bruteforce_custom_phase_index]:get()
                    end
                end
            end
            
            anti_bruteforce_current_left_add = new_left_add
            anti_bruteforce_current_right_add = new_right_add

            anti_bruteforce_active_override = true

            if antiAimState.antiBruteforce.antiBruteforceIndication:get() and aimbot_logs then
                if not anti_bruteforce_log_active or last_displayed_ab_left ~= new_left_add or last_displayed_ab_right ~= new_right_add then
                    local log_message = Utility.color_text({"Anti Bruteforce ", SHADOWYAW_COLOR_HEX}) .. 
                                        Utility.color_text({string.format("[L=%.0f] [R=%.0f]", new_left_add, new_right_add), "FFFFFFFF"})
                    aimbot_logs.push(log_message, 1, 'anti_bruteforce')
                    last_displayed_ab_left = new_left_add
                    last_displayed_ab_right = new_right_add
                    anti_bruteforce_log_active = true
                end
            end

            anti_bruteforce_last_shot_tick = globals.tickcount
        end
    },
    round_start = {
        function()
            if menu.utility_group_1.clearConsole:get() then
                utils.console_exec("clear")
            end

            local lp = player()
            if not lp then return end
            local team_prefix_for_logic = (lp.m_iTeamNum == 2) and "t" or "ct"
            local antiAimState = menu["anti aim states"].cache[team_prefix_for_logic][states[Utility.getCondition()][1]]

            if antiAimState and antiAimState.antiBruteforce and antiAimState.antiBruteforce:get() and antiAimState.antiBruteforce.antiBruteforceReset:get() then
                anti_bruteforce_active_override = false
                anti_bruteforce_current_left_add = antiAimState.leftYawOffset:get() 
                anti_bruteforce_current_right_add = antiAimState.rightYawOffset:get() 
                anti_bruteforce_custom_phase_index = 1
                anti_bruteforce_last_shot_tick = 0
                anti_bruteforce_log_active = false
                last_displayed_ab_left = 0
                last_displayed_ab_right = 0
                if aimbot_logs then
                    print_raw(Utility.color_text({"Anti Bruteforce reset for new round!", SHADOWYAW_COLOR_HEX}))
                end
            end
        end
    },
}

pui.setup(menu)

local defaultConfigName = "Default"

local function saveOrCreateConfig()
    local newConfigName = menu.config.configNameInput:get()
    
    if newConfigName == nil or newConfigName == '' then
        print('Please enter a config name')
        return
    end
    
    local status, configsDataJsonString = pcall(files.read, "csgo/shadowyaw/configsData.json")
    if not status then
        print('Error reading config file: ' .. configsDataJsonString)
        return
    end
    
    local configsDataJsonTable = json.parse(configsDataJsonString)
    
    if newConfigName == defaultConfigName then
        print("Cannot overwrite the default config")
        return
    end
    
    local currentConfig = pui.save()
    local encryptedCurrentConfig = base64.encode(json.stringify(currentConfig))
    
    local exists = false
    local index = nil
    for i, name in ipairs(configsDataJsonTable.cfgName) do
        if name == newConfigName then
            exists = true
            index = i
            break
        end
    end
    
    if not exists then
        table.insert(configsDataJsonTable.cfgName, newConfigName)
        index = #configsDataJsonTable.cfgName
    end
    
    configsDataJsonTable[newConfigName] = encryptedCurrentConfig
    
    files.write('csgo/shadowyaw/configsData.json', json.stringify(configsDataJsonTable))
    
    menu.config.configList:update(configsDataJsonTable.cfgName)
    menu.config.configList:set(1)
    print_raw(Utility.color_text({"Config '", SHADOWYAW_COLOR_HEX}) .. Utility.color_text({newConfigName .. "' saved successfully!", "FFFFFFFF"}))
end

local function loadSelectedConfig()
    local selectedConfigIndex = menu.config.configList:get()
    
    if selectedConfigIndex == nil then
       print('no config selected')
       return
    end
    
    local status, configsDataJsonString = pcall(files.read,"csgo/shadowyaw/configsData.json")
    
    if not status then
       print(configsDataJsonString)
       return
    end
    
    local configsDataJsonTable = json.parse(configsDataJsonString)
    
    local selectedConfigName = configsDataJsonTable.cfgName[selectedConfigIndex]
    
    local encryptedSelectedConfig = configsDataJsonTable[selectedConfigName]
    local decryptedSelectedConfig = json.parse(base64.decode(encryptedSelectedConfig))
    
    pui.load(decryptedSelectedConfig)
    print_raw(Utility.color_text({"Config '", SHADOWYAW_COLOR_HEX}) .. Utility.color_text({selectedConfigName .. "' loaded successfully!", "FFFFFFFF"}))
end

local function deleteSelectedConfig()
    local selectedConfigIndex = menu.config.configList:get()
    
    if selectedConfigIndex == nil then
       print('no config selected')
       return
    end
    
    local status, configsDataJsonString = pcall(files.read,"csgo/shadowyaw/configsData.json")
    
    if not status then
      print(configsDataJsonString)
      return
    end
    
    local configsDataJsonTable = json.parse(configsDataJsonString)
    
    local selectedConfigName = configsDataJsonTable.cfgName[selectedConfigIndex]
    
    if selectedConfigName == defaultConfigName then
        print("cannot delete the default config")
        return
    end
    
    configsDataJsonTable[selectedConfigName] = nil

    table.remove(configsDataJsonTable.cfgName, selectedConfigIndex)
    
    files.write('csgo/shadowyaw/configsData.json', json.stringify(configsDataJsonTable))
    
    menu.config.configList:update(configsDataJsonTable.cfgName)
    menu.config.configList:set(1)
    print_raw(Utility.color_text({"Config '", SHADOWYAW_COLOR_HEX}) .. Utility.color_text({selectedConfigName .. "' deleted successfully!", "FFFFFFFF"}))
end

menu.config.saveConfigButton:set_callback(saveOrCreateConfig)
menu.config.loadConfigButton:set_callback(loadSelectedConfig)
menu.config.deleteConfigButton:set_callback(deleteSelectedConfig)

menu.config.exportConfigButton:set_callback(function()
    local config = pui.save()

    local configJsonString = json.stringify(config)
    local encryptedConfig = base64.encode(configJsonString)
    
    clipboard.set(encryptedConfig)
    print_raw(Utility.color_text({"Config exported to clipboard!", SHADOWYAW_COLOR_HEX}))
end)

menu.config.importConfigButton:set_callback(function()
    local encrypted = clipboard.get()
    
    local status, decrypted = pcall(base64.decode, encrypted)
    if not status then
        print('invalid data in clipboard')
        return
    end
    
    status, decrypted = pcall(json.parse, decrypted)
    if not status then
        print('invalid data in clipboard')
        return
    end
    
    pui.load(decrypted)
    print_raw(Utility.color_text({"Config imported from clipboard!", SHADOWYAW_COLOR_HEX}))
end)

for eventName, eventFunctions_list in pairs(eventsFunctions) do
    if eventName == "createmove" then
        events[eventName]:set(function(cmd)
            for _, func in ipairs(eventFunctions_list) do
                func(cmd)
            end
        end)
    elseif eventName == "round_start" then
        events[eventName]:set(function()
            for _, func in ipairs(eventFunctions_list) do
                func()
            end
        end)
    elseif eventName == "bullet_impact" then
        events[eventName]:set(function(e)
            for _, func in ipairs(eventFunctions_list) do
                func(e)
            end
        end)
    else
        events[eventName]:set(function(...)
            for _, func in ipairs(eventFunctions_list) do
                func(...)
            end
        end)
    end
end

local username = getUsername() or "User"
local welcome_message_text = Utility.color_text({"Welcome Back, ", SHADOWYAW_COLOR_HEX}) .. Utility.color_text({username .. "!", color(255, 255, 255, 255)})
if aimbot_logs then
    aimbot_logs.push(welcome_message_text, 5, 'welcome')
end