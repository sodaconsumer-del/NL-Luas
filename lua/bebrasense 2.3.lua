-- Downloaded from https://github.com/s0daa/CSGO-HVH-LUAS

-- Lua coded by matt, stefan is not responsible for this shitcode 😂

local user = {name = common.get_username(), version = "2.3", build = {current = "alpha", color_rgb = color(255,100,100), color_hex = "\aff6464ff"}}

-- So, you guys at NL staff aren't allowing us to have a blacklist?
-- Luasense is allowed to, but we aren’t? Looks like someone has a favorite child, huh? :)
-- Let me explain...
-- People would only get blacklisted under fair circumstances and conditions anyway.
-- For example, those who got the Lua for free via a media deal but never released any media.
-- Yet, you're forcing us to let these people continue using it. 
-- This is a ridiculous loophole that you refuse to let us mitigate.
-- Truly, a "very professional" decision on your part.

-- Fuck you.
-- Regards, estro.

if require('neverlose/integrity')() == true then
    error(string.format("You are not %s. Do not try to disguise yourself!", user.name), 0)
end

local version = string.format("\v%s \aDEFAULT[\v%s\aDEFAULT]", user.build, user.version)
local watermark = "BebraSense 2025"

local pui = require("neverlose/pui")
local base64 = require("neverlose/base64")
local clipboard = require("neverlose/clipboard")
local mtools = require("neverlose/mtools")
local gradient = require("neverlose/gradient")
local lagrecord = require("neverlose/lagrecord")
lagrecord = lagrecord^lagrecord.SIGNED

lagrecord.set_update_callback(function(player)
    if player == entity.get_local_player() then
        return true
    end
end)

local refs = {
    enable = ui.find("Aimbot", "Anti Aim", "Angles", "Enabled"),
    pitch = ui.find("Aimbot", "Anti Aim", "Angles", "Pitch"),
    yaw = ui.find("Aimbot", "Anti Aim", "Angles", "Yaw"),
    yawmodifier = ui.find("Aimbot", "Anti Aim", "Angles", "Yaw Modifier"),
    yawoffset = ui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Offset"),
    inverter = ui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Inverter"),
    bodyyaw = ui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw"),
    bodyyaw_options = ui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Options"),
    leftlimit = ui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Left Limit"),
    rightlimit = ui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Right Limit"),
    bodyyaw_freestanding = ui.find("Aimbot", "Anti Aim", "Angles", "Body Yaw", "Freestanding"),
    hidden = ui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Hidden"),
    dtopt = ui.find("Aimbot", "Ragebot", "Main", "Double Tap", "Lag Options"),
    hsopt = ui.find("Aimbot", "Ragebot", "Main", "Hide Shots", "Options"),
    doubletap = ui.find("Aimbot", "Ragebot", "Main", "Double Tap"),
    hideshots = ui.find("Aimbot", "Ragebot", "Main", "Hide Shots"),
    freestanding = ui.find("Aimbot", "Anti Aim", "Angles", "Freestanding"),
    bodyaim = ui.find("Aimbot", "Ragebot", "Safety", "Body Aim"),
    fakeduck = ui.find("Aimbot", "Anti Aim", "Misc", "Fake Duck"),
    safepoints = ui.find("Aimbot", "Ragebot", "Safety", "Safe Points"),
    mindmg = ui.find("Aimbot", "Ragebot", "Selection", "Min. Damage"),

    latency = ui.find("Miscellaneous", "Main", "Other", "Fake Latency"),
    pistolshc = ui.find("Aimbot", "Ragebot", "Selection", "Pistols", "Hit Chance"),
    smgshc = ui.find("Aimbot", "Ragebot", "Selection", "SMGs", "Hit Chance"),
    ssg08hc = ui.find("Aimbot", "Ragebot", "Selection", "SSG-08", "Hit Chance"),
    revolverhc = ui.find("Aimbot", "Ragebot", "Selection", "R8 Revolver", "Hit Chance"),
    zeushc = ui.find("Aimbot", "Ragebot", "Selection", "Taser", "Hit Chance"),

    airstrafe = ui.find("Miscellaneous", "Main", "Movement", "Air Strafe")
}

local conditions = {
    "Global",
	"Standing",
	"Running",
	"Slowwalk",
	"Crouching",
	"Crouchwalk",
	"In Air",
	"Airduck",
}

local colors = {
    yellow = "\ae6e664ff",
    red = "\aff6464ff",
    green = "\a64ff64ff",
    mildgreen =  "\a96dc96ff",
    consoletext = "\ad9d9d9ff"
}

local num_text = { --fucking json.stringify garbage negroid ["bebrasense recode"]:485: json does not support mixed key types!!!! fuck you!!!
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven"
}

--animation breaker thingy
ffi.cdef[[
typedef struct {
    char pad_0x0000[0x18];
    uint32_t sequence;
    float prev_cycle;
    float weight;
    float weight_delta_rate;
    float playback_rate;
    float cycle;
    void *entity;
    char pad_0x0038[0x4];
} AnimationLayer;
]]

local function animft(speed)
    return speed * (globals.frametime * 100)
end
local function ease_out(current, target, speed)
    local delta = (target - current) * speed * (globals.frametime * 5)
    if math.abs(target - current) <= 1 then  -- Snap to target if within 1 pixel
        return target - current  -- Return the exact remaining distance
    end
    return delta
end

local loading = {
    done = false,
    value = 0,
    timer = 0,
    clip = 0
}

local shittycat = render.load_image(network.get("https://i.imgur.com/XEgy3sn.png"), vector(256,256))
local shittyfont = render.load_font("Arial", 64, "ab")
events.render(function()
    if loading.done == false then
    if loading.value < 255 and loading.timer == 0 then
        loading.value = loading.value + animft(3)
    end
    if loading.value >= 255 and loading.timer < 150 then
        loading.value = 255
        loading.timer = loading.timer + animft(1)
        loading.clip = loading.clip + animft(4)
    end
    if loading.timer >= 150 then
        loading.value = loading.value - animft(3)
        if loading.value <= 0 then loading.done = true end
    end

    render.rect(
        vector(0,0),
        render.screen_size(),
        color(0,0,0,loading.value/3)
    )
    render.blur(
        vector(0,0),
        render.screen_size(),
        loading.value/128,
        loading.value/255
    )
    render.texture(
        shittycat,
        render.screen_size()/2 - vector(128,128),
        color(255,255,255,loading.value)
    )

    render.push_clip_rect(
        render.screen_size()/2 + vector(-loading.clip, 0),
        render.screen_size()/2 + vector(loading.clip, 1000)
    )

    render.text(
        shittyfont,
        render.screen_size()/2 + vector(0,120),
        color(255,255,255,loading.value),
        "c",
        "BEBRASENSE"
    )
    end
end)

local groups = {
    home = {
        info = pui.create("\f<house>", "info", 1),
        watermark = pui.create("\f<house>", "", 1),
        configs = pui.create("\f<house>", "configs", 2)
    },
    antiaim = {
        main = pui.create("\f<shield>", "main", 1),
        extra = pui.create("\f<shield>", "extra", 1),
        watermark = pui.create("\f<shield>", "", 1),

        delay = {}, -- conditional groups will be generated within these
        builder = {},
        defensive = {}
    },
    other = {
        misc = pui.create("\f<earth-americas>", "miscellaneous", 1),
        visuals = pui.create("\f<earth-americas>", "visuals", 2),
        watermark = pui.create("\f<earth-americas>", "", 1)
    }
}

for i = 1, #conditions do -- automatically generate conditional groups
    local cond = conditions[i]
    groups.antiaim.builder[cond] = pui.create("\f<shield>", "builder > "..cond, 2)
    groups.antiaim.delay[cond] = pui.create("\f<shield>", "delay > "..cond, 2)
    groups.antiaim.defensive[cond] = pui.create("\f<shield>", "defensive > "..cond, 2)
end

-- configs stuffs thingies zzz
mtools.FileSystem.CreateDir("bebrasense")
configslist = mtools.FileSystem:ReadFolder("bebrasense", true)

local items = {
    info = {
        groups.home.watermark:label(watermark),

        groups.home.info:texture(render.load_image(network.get(  "https://i.imgur.com/jAaeX2K.png"  ))),
        groups.home.info:label("\v\f<scroll>\r  Current Build: ".."\v"..user.build.current .. "\r [" .. "\vv"..user.version .. "\r]"),
        groups.home.info:label("\v\f<user>\r  User: \v"..common.get_username()),
        groups.home.info:label("\v\f<discord>\r  Join Our Discord Server:"),
        groups.home.info:button(" Join ", function()
            panorama.SteamOverlayAPI.OpenExternalBrowserURL("https://discord.gg/ZUGqWqSvKX")
        end),
        presets = groups.home.info:combo("\v\f<download>\r  Preset", {"None", "Defensive", "Unmatched", "Wishenz"}),
        defensivelabel = groups.home.info:label("\v\f<arrow-right-from-arc>\r  Defensive Preset:"),
        defensivebtn = groups.home.info:button(" Load ", function() -- sorry for the rly long lines here...
            pui.load(json.parse(base64.decode([[eyJhbnRpYWltIjp7ImJ1aWxkZXIiOnsiQWlyZHVjayI6eyJib2R5eWF3IjoiQW50aS1CcnV0ZWZvcmNlIiwiaml0dGVyIjowLjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOi0xNS4wLCJhZGRyaWdodCI6MTUuMCwib2Zmc2V0Ijo1LjAsInJhbmRvbWl6ZSI6MC4wfX0sIkNyb3VjaGluZyI6eyJib2R5eWF3IjoiSml0dGVyIiwiaml0dGVyIjozNS4wLCJtb2RpZmllciI6IlJhbmRvbSBDZW50ZXIiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOnRydWUsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6LTE1LjAsImFkZHJpZ2h0IjoxNS4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjoxMC4wfX0sIkNyb3VjaHdhbGsiOnsiYm9keXlhdyI6IkFudGktQnJ1dGVmb3JjZSIsImppdHRlciI6MjUuMCwibW9kaWZpZXIiOiJDZW50ZXIiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjp0cnVlLCJsZWZ0bGltaXQiOjYwLjAsInJhbmRvbWl6ZSI6ZmFsc2UsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6LTEwLjAsImFkZHJpZ2h0IjoxMC4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjowLjB9fSwiR2xvYmFsIjp7ImJvZHl5YXciOiJKaXR0ZXIiLCJqaXR0ZXIiOjM1LjAsIm1vZGlmaWVyIjoiMy1XYXkiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOnRydWUsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6MC4wLCJhZGRyaWdodCI6MC4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjowLjB9fSwiSW4gQWlyIjp7ImJvZHl5YXciOiJBbnRpLUJydXRlZm9yY2UiLCJqaXR0ZXIiOjI1LjAsIm1vZGlmaWVyIjoiQ2VudGVyIiwieWF3IjoiQmFja3dhcmQiLCJ+Ym9keXlhdyI6eyJpbnZlcnRlciI6ZmFsc2UsImppdHRlciI6dHJ1ZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOi0xMC4wLCJhZGRyaWdodCI6MTAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX0sIlJ1bm5pbmciOnsiYm9keXlhdyI6IkFudGktQnJ1dGVmb3JjZSIsImppdHRlciI6MjUuMCwibW9kaWZpZXIiOiJDZW50ZXIiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjp0cnVlLCJsZWZ0bGltaXQiOjYwLjAsInJhbmRvbWl6ZSI6ZmFsc2UsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6MC4wLCJhZGRyaWdodCI6MC4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjowLjB9fSwiU2xvd3dhbGsiOnsiYm9keXlhdyI6IkppdHRlciIsImppdHRlciI6MzUuMCwibW9kaWZpZXIiOiIzLVdheSIsInlhdyI6IkJhY2t3YXJkIiwifmJvZHl5YXciOnsiaW52ZXJ0ZXIiOmZhbHNlLCJqaXR0ZXIiOmZhbHNlLCJsZWZ0bGltaXQiOjYwLjAsInJhbmRvbWl6ZSI6ZmFsc2UsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6MTAuMCwiYWRkcmlnaHQiOi0xMC4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjowLjB9fSwiU3RhbmRpbmciOnsiYm9keXlhdyI6IkRpc2FibGVkIiwiaml0dGVyIjowLjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOjAuMCwiYWRkcmlnaHQiOjAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX19LCJkZWZlbnNpdmUiOnsiQWlyZHVjayI6eyJlbmFibGVkIjp0cnVlLCJmb3JjZSI6dHJ1ZSwicGl0Y2giOjIuMCwieWF3IjozLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTYuMH0sIn5waXRjaCI6eyJhcmVhIjo5MC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOi04OS4wLCJzZXF1ZW5jZSI6IlNraXR0ZXIiLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9LCJ+eWF3Ijp7ImFyZWEiOjkwLjAsImNvdW50ZXJhY3QiOnRydWUsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6LTEyMC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjEyMC4wfX0sIkNyb3VjaGluZyI6eyJlbmFibGVkIjp0cnVlLCJmb3JjZSI6dHJ1ZSwicGl0Y2giOjAuMCwieWF3IjoyLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTYuMH0sIn5waXRjaCI6eyJhcmVhIjoxNzguMCwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzcGVlZCI6MjAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9LCJ+eWF3Ijp7ImFyZWEiOjkwLjAsImNvdW50ZXJhY3QiOmZhbHNlLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOi05MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjkwLjB9fSwiQ3JvdWNod2FsayI6eyJlbmFibGVkIjp0cnVlLCJmb3JjZSI6dHJ1ZSwicGl0Y2giOjAuMCwieWF3IjowLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTIuMH0sIn5waXRjaCI6eyJhcmVhIjoxNDEuMCwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjQ1LjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfSwifnlhdyI6eyJhcmVhIjozNjAuMCwiY291bnRlcmFjdCI6dHJ1ZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiQmFjayBhbmQgRm9ydGgiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzZXZlbiI6MC4wLCJzaXgiOjAuMCwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfX0sIkdsb2JhbCI6eyJlbmFibGVkIjp0cnVlLCJmb3JjZSI6dHJ1ZSwicGl0Y2giOjAuMCwieWF3IjowLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTUuMH0sIn5waXRjaCI6eyJhcmVhIjoxNzguMCwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiQmFjayBhbmQgRm9ydGgiLCJvZmZzZXQiOjQ1LjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfSwifnlhdyI6eyJhcmVhIjozNjAuMCwiY291bnRlcmFjdCI6dHJ1ZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzZXZlbiI6MC4wLCJzaXgiOjAuMCwic3BlZWQiOjE4LjAsInRocmVlIjowLjAsInR3byI6MC4wfX0sIkluIEFpciI6eyJlbmFibGVkIjp0cnVlLCJmb3JjZSI6dHJ1ZSwicGl0Y2giOjIuMCwieWF3IjowLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTUuMH0sIn5waXRjaCI6eyJhcmVhIjo5MC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOi00NS4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6ODkuMH0sIn55YXciOnsiYXJlYSI6MzYwLjAsImNvdW50ZXJhY3QiOnRydWUsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoyMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH19LCJSdW5uaW5nIjp7ImVuYWJsZWQiOnRydWUsImZvcmNlIjp0cnVlLCJwaXRjaCI6MC4wLCJ5YXciOjMuMCwifmVuYWJsZWQiOnsidGltaW5nIjoxNi4wfSwifnBpdGNoIjp7ImFyZWEiOjE3OC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOi04OS4wLCJzZXF1ZW5jZSI6IlNraXR0ZXIiLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjo4OS4wfSwifnlhdyI6eyJhcmVhIjo5MC4wLCJjb3VudGVyYWN0Ijp0cnVlLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJCYWNrIGFuZCBGb3J0aCIsIm9mZnNldCI6MC4wLCJvbmUiOi0xMjAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNldmVuIjowLjAsInNpeCI6MC4wLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjoxMjAuMH19LCJTbG93d2FsayI6eyJlbmFibGVkIjp0cnVlLCJmb3JjZSI6dHJ1ZSwicGl0Y2giOjIuMCwieWF3IjowLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTMuMH0sIn5waXRjaCI6eyJhcmVhIjo5MC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOi04OS4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6ODkuMH0sIn55YXciOnsiYXJlYSI6MzYwLjAsImNvdW50ZXJhY3QiOnRydWUsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH19LCJTdGFuZGluZyI6eyJlbmFibGVkIjpmYWxzZSwiZm9yY2UiOmZhbHNlLCJwaXRjaCI6MS4wLCJ5YXciOjEuMCwifmVuYWJsZWQiOnsidGltaW5nIjoxNi4wfSwifnBpdGNoIjp7ImFyZWEiOjkwLjAsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfSwifnlhdyI6eyJhcmVhIjo5MC4wLCJjb3VudGVyYWN0IjpmYWxzZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzZXZlbiI6MC4wLCJzaXgiOjAuMCwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfX19LCJkZWxheSI6eyJBaXJkdWNrIjp7ImVuYWJsZWQiOiJEaXNhYmxlZCIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInRpY2tzIjowLjB9LCJDcm91Y2hpbmciOnsiZW5hYmxlZCI6IkRpc2FibGVkIiwibWF4dGlja3MiOjYuMCwibWludGlja3MiOjAuMCwidGlja3MiOjAuMH0sIkNyb3VjaHdhbGsiOnsiZW5hYmxlZCI6IlN0YXRpYyIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInRpY2tzIjoxLjB9LCJHbG9iYWwiOnsiZW5hYmxlZCI6IlJhbmRvbSIsIm1heHRpY2tzIjoyLjAsIm1pbnRpY2tzIjowLjAsInRpY2tzIjoyLjB9LCJJbiBBaXIiOnsiZW5hYmxlZCI6IlN0YXRpYyIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInRpY2tzIjozLjB9LCJSdW5uaW5nIjp7ImVuYWJsZWQiOiJTdGF0aWMiLCJtYXh0aWNrcyI6Ni4wLCJtaW50aWNrcyI6MC4wLCJ0aWNrcyI6My4wfSwiU2xvd3dhbGsiOnsiZW5hYmxlZCI6IlJhbmRvbSIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInRpY2tzIjowLjB9LCJTdGFuZGluZyI6eyJlbmFibGVkIjoiRGlzYWJsZWQiLCJtYXh0aWNrcyI6Ni4wLCJtaW50aWNrcyI6MC4wLCJ0aWNrcyI6MC4wfX0sImV4dHJhIjp7ImJyZWFrZXIiOnRydWUsImV4cGxvaXQiOmZhbHNlLCJmcmVlc3RhbmRpbmciOmZhbHNlLCJmdWNrZGVmZW5zaXZlIjpmYWxzZSwibWFudWFsIjoiRGVmYXVsdCIsIm9wdGlvbnMiOlsiQXQgVGFyZ2V0IiwiQXZvaWQgQmFja3N0YWIiLCJ+Il0sInNhZmVoZWFkIjpbIk9uIEtuaWZlIiwiT24gWmV1cyIsIn4iXSwid2FybXVwYWEiOmZhbHNlLCJ+YnJlYWtlciI6eyJhaXIiOiJTdGF0aWMgTGVncyIsImdyb3VuZCI6IkRlZmF1bHQifSwifmV4cGxvaXQiOnsiZGVncmVlIjo5MC4wLCJqaXR0ZXIiOmZhbHNlLCJtb2RlIjoiSW5zdGFudCIsInBpdGNoIjowLjAsInJhbmRvbWl6ZSI6ZmFsc2UsInRpbWluZyI6Ny4wfSwifmZyZWVzdGFuZGluZyI6eyJlZGdlYmFpdCI6dHJ1ZSwicGl0Y2giOjAuMCwieWF3IjoxODAuMH19LCJtYWluIjp7ImNvbmRpdGlvbiI6IlNsb3d3YWxrIiwiZW5hYmxlcyI6eyJBaXJkdWNrIjp0cnVlLCJDcm91Y2hpbmciOnRydWUsIkNyb3VjaHdhbGsiOnRydWUsIkluIEFpciI6dHJ1ZSwiUnVubmluZyI6dHJ1ZSwiU2xvd3dhbGsiOnRydWUsIlN0YW5kaW5nIjpmYWxzZX19fSwiY29uZmlncyI6eyJsaXN0IjoyLjAsIm5hbWUiOiJnYXJiYWFnIn0sImluZm8iOnsiYWNjZW50Y29sb3IiOiIjNUQ4NUM4RkYiLCJwcmVzZXRzIjoiTm9uZSJ9LCJtaXNjIjp7ImFpcmhjIjp0cnVlLCJhdXRvbXV0ZSI6IkRpc2FibGVkIiwiYXV0b3RwIjpmYWxzZSwiY2xhbnRhZyI6ZmFsc2UsImRyb3BuYWRlcyI6eyJncmVuYWRlIjp0cnVlLCJob3RrZXkiOjguMCwibW9sb3RvdiI6dHJ1ZSwic21va2UiOmZhbHNlLCJzcGVlZCI6NS4wfSwiZmFrZWxhdGVuY3kiOjIwMC4wLCJmYXN0bGFkZGVyIjp0cnVlLCJmb3JjZWJhaW0iOnRydWUsImlkZWFsdGljayI6ZmFsc2UsImp1bXBzY291dCI6dHJ1ZSwicmV2b2x2ZXIiOnRydWUsInRyYXNodGFsayI6ZmFsc2UsIn5haXJoYyI6eyJwaXN0b2xzIjoxNS4wLCJyZXZvbHZlciI6MzUuMCwic21ncyI6NS4wLCJzc2cwOCI6NTAuMCwid2VhcG9ucyI6WyJQaXN0b2xzIiwiUmV2b2x2ZXIiLCJTU0ctMDgiLCJTTUdzIiwiWmV1cyIsIn4iXSwiemV1cyI6NjcuMH0sIn5jbGFudGFnIjp7Im1vZGUiOiJCZWJyYVNlbnNlIiwidGFnIjoiIn0sIn5mb3JjZWJhaW0iOnsiaHAiOjY1LjB9LCJ+aWRlYWx0aWNrIjp7InRpbWUiOjEwMC4wLCJ3ZWFwb25zIjpbIn4iXX0sIn5yZXZvbHZlciI6eyJndWlkZXMiOnRydWV9fSwidmlzdWFscyI6eyJhc3BlY3RyYXRpbyI6dHJ1ZSwiY3Jvc3NpbmRpY2F0b3JzIjp0cnVlLCJjdXN0b21zY29wZSI6dHJ1ZSwiZG1naW5kaWNhdG9yIjp0cnVlLCJncmVuYWRlcmFkaXVzIjp0cnVlLCJsb2dzIjp0cnVlLCJtYW51YWxhcnJvd3MiOnRydWUsInZlbG9jaXR5Ijp0cnVlLCJ2aWV3bW9kZWwiOnRydWUsIn5hc3BlY3RyYXRpbyI6eyJyYXRpbyI6MTMzLjB9LCJ+Y3Jvc3NpbmRpY2F0b3JzIjp7ImNsciI6WyJTaW1wbGUiLCIjRkZGRkZGRkYiLCJ+Il0sImNvbG9yIjoiQWNjZW50IENvbG9yIiwiZGVzeW5jIjp0cnVlLCJmb250IjoxLjAsImhlaWdodCI6MzAuMCwic3R5bGUiOiJiZWJyYXNlbnNlIn0sIn5jdXN0b21zY29wZSI6eyJhbmltYXRlIjp0cnVlLCJjb2xvciI6IiM1RDg1QzhGRiIsImV4Y2x1ZGUiOlsifiJdLCJpbnZlcnQiOmZhbHNlLCJsZW5ndGgiOjEwMC4wLCJvZmZzZXQiOjEwLjAsInNwZWVkIjoxNS4wLCJ0aGlja25lc3MiOjIuMH0sIn5kbWdpbmRpY2F0b3IiOnsiYW5pbWF0ZWQiOnRydWV9LCJ+bWFudWFsYXJyb3dzIjp7ImFjdGl2ZW1vZGUiOiJBY2NlbnQgQ29sb3IiLCJjb2xvciI6IiNGRkZGRkZGRiIsImludmlzIjp0cnVlLCJvZmZzZXQiOjUwLjAsInNpemUiOjE2LjB9LCJ+dmlld21vZGVsIjp7ImZvdiI6NjUuMCwieCI6MjUuMCwieSI6MjAuMCwieiI6LTIwLjB9fX0=]])))
        end),
        unmatchedlabel = groups.home.info:label("\v\f<arrow-right-from-arc>\r  Unmatched Preset:"),
        unmatchedbtn = groups.home.info:button(" Load ", function()
            pui.load(json.parse(base64.decode([[eyJhbnRpYWltIjp7ImJ1aWxkZXIiOnsiQWlyZHVjayI6eyJib2R5eWF3IjoiQW50aS1CcnV0ZWZvcmNlIiwiaml0dGVyIjowLjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOi0xNS4wLCJhZGRyaWdodCI6MTUuMCwib2Zmc2V0Ijo1LjAsInJhbmRvbWl6ZSI6MC4wfX0sIkNyb3VjaGluZyI6eyJib2R5eWF3IjoiSml0dGVyIiwiaml0dGVyIjowLjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOi0xNS4wLCJhZGRyaWdodCI6MjUuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6NS4wfX0sIkNyb3VjaHdhbGsiOnsiYm9keXlhdyI6IkRpc2FibGVkIiwiaml0dGVyIjowLjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOjAuMCwiYWRkcmlnaHQiOjAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX0sIkdsb2JhbCI6eyJib2R5eWF3IjoiQW50aS1CcnV0ZWZvcmNlIiwiaml0dGVyIjoyNS4wLCJtb2RpZmllciI6IkNlbnRlciIsInlhdyI6IkJhY2t3YXJkIiwifmJvZHl5YXciOnsiaW52ZXJ0ZXIiOmZhbHNlLCJqaXR0ZXIiOnRydWUsImxlZnRsaW1pdCI6NjAuMCwicmFuZG9taXplIjpmYWxzZSwicmlnaHRsaW1pdCI6NjAuMH0sIn5tb2RpZmllciI6eyJzYW1lc2lkZSI6ZmFsc2UsInNlcXVlbmNlIjoiU3RyYWlnaHQifSwifnlhdyI6eyJhZGRsZWZ0IjowLjAsImFkZHJpZ2h0IjowLjAsIm9mZnNldCI6MC4wLCJyYW5kb21pemUiOjAuMH19LCJJbiBBaXIiOnsiYm9keXlhdyI6IkFudGktQnJ1dGVmb3JjZSIsImppdHRlciI6MzAuMCwibW9kaWZpZXIiOiJDZW50ZXIiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjp0cnVlLCJsZWZ0bGltaXQiOjYwLjAsInJhbmRvbWl6ZSI6ZmFsc2UsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6LTUuMCwiYWRkcmlnaHQiOjUuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX0sIlJ1bm5pbmciOnsiYm9keXlhdyI6IkppdHRlciIsImppdHRlciI6MjUuMCwibW9kaWZpZXIiOiJSYW5kb20gQ2VudGVyIiwieWF3IjoiQmFja3dhcmQiLCJ+Ym9keXlhdyI6eyJpbnZlcnRlciI6ZmFsc2UsImppdHRlciI6ZmFsc2UsImxlZnRsaW1pdCI6NjAuMCwicmFuZG9taXplIjp0cnVlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOjAuMCwiYWRkcmlnaHQiOjAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX0sIlNsb3d3YWxrIjp7ImJvZHl5YXciOiJBbnRpLUJydXRlZm9yY2UiLCJqaXR0ZXIiOjM1LjAsIm1vZGlmaWVyIjoiQ2VudGVyIiwieWF3IjoiQmFja3dhcmQiLCJ+Ym9keXlhdyI6eyJpbnZlcnRlciI6ZmFsc2UsImppdHRlciI6dHJ1ZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOjAuMCwiYWRkcmlnaHQiOjAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MTAuMH19LCJTdGFuZGluZyI6eyJib2R5eWF3IjoiRGlzYWJsZWQiLCJqaXR0ZXIiOjAuMCwibW9kaWZpZXIiOiJEaXNhYmxlZCIsInlhdyI6IkJhY2t3YXJkIiwifmJvZHl5YXciOnsiaW52ZXJ0ZXIiOmZhbHNlLCJqaXR0ZXIiOmZhbHNlLCJsZWZ0bGltaXQiOjYwLjAsInJhbmRvbWl6ZSI6ZmFsc2UsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6MC4wLCJhZGRyaWdodCI6MC4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjowLjB9fX0sImRlZmVuc2l2ZSI6eyJBaXJkdWNrIjp7ImVuYWJsZWQiOmZhbHNlLCJmb3JjZSI6ZmFsc2UsInBpdGNoIjoxLjAsInlhdyI6MS4wLCJ+ZW5hYmxlZCI6eyJ0aW1pbmciOjE2LjB9LCJ+cGl0Y2giOnsiYXJlYSI6OTAuMCwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9LCJ+eWF3Ijp7ImFyZWEiOjkwLjAsImNvdW50ZXJhY3QiOmZhbHNlLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNldmVuIjowLjAsInNpeCI6MC4wLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9fSwiQ3JvdWNoaW5nIjp7ImVuYWJsZWQiOmZhbHNlLCJmb3JjZSI6ZmFsc2UsInBpdGNoIjoxLjAsInlhdyI6MS4wLCJ+ZW5hYmxlZCI6eyJ0aW1pbmciOjE2LjB9LCJ+cGl0Y2giOnsiYXJlYSI6OTAuMCwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9LCJ+eWF3Ijp7ImFyZWEiOjkwLjAsImNvdW50ZXJhY3QiOmZhbHNlLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNldmVuIjowLjAsInNpeCI6MC4wLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9fSwiQ3JvdWNod2FsayI6eyJlbmFibGVkIjpmYWxzZSwiZm9yY2UiOmZhbHNlLCJwaXRjaCI6MS4wLCJ5YXciOjEuMCwifmVuYWJsZWQiOnsidGltaW5nIjoxNi4wfSwifnBpdGNoIjp7ImFyZWEiOjkwLjAsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfSwifnlhdyI6eyJhcmVhIjo5MC4wLCJjb3VudGVyYWN0IjpmYWxzZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzZXZlbiI6MC4wLCJzaXgiOjAuMCwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfX0sIkdsb2JhbCI6eyJlbmFibGVkIjpmYWxzZSwiZm9yY2UiOmZhbHNlLCJwaXRjaCI6MS4wLCJ5YXciOjEuMCwifmVuYWJsZWQiOnsidGltaW5nIjoxNi4wfSwifnBpdGNoIjp7ImFyZWEiOjkwLjAsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfSwifnlhdyI6eyJhcmVhIjo5MC4wLCJjb3VudGVyYWN0IjpmYWxzZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzZXZlbiI6MC4wLCJzaXgiOjAuMCwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfX0sIkluIEFpciI6eyJlbmFibGVkIjpmYWxzZSwiZm9yY2UiOmZhbHNlLCJwaXRjaCI6MS4wLCJ5YXciOjEuMCwifmVuYWJsZWQiOnsidGltaW5nIjoxNi4wfSwifnBpdGNoIjp7ImFyZWEiOjkwLjAsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfSwifnlhdyI6eyJhcmVhIjo5MC4wLCJjb3VudGVyYWN0IjpmYWxzZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzZXZlbiI6MC4wLCJzaXgiOjAuMCwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfX0sIlJ1bm5pbmciOnsiZW5hYmxlZCI6ZmFsc2UsImZvcmNlIjpmYWxzZSwicGl0Y2giOjEuMCwieWF3IjoxLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTYuMH0sIn5waXRjaCI6eyJhcmVhIjo5MC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH0sIn55YXciOnsiYXJlYSI6OTAuMCwiY291bnRlcmFjdCI6ZmFsc2UsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH19LCJTbG93d2FsayI6eyJlbmFibGVkIjpmYWxzZSwiZm9yY2UiOmZhbHNlLCJwaXRjaCI6MS4wLCJ5YXciOjEuMCwifmVuYWJsZWQiOnsidGltaW5nIjoxNi4wfSwifnBpdGNoIjp7ImFyZWEiOjkwLjAsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfSwifnlhdyI6eyJhcmVhIjo5MC4wLCJjb3VudGVyYWN0IjpmYWxzZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzZXZlbiI6MC4wLCJzaXgiOjAuMCwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfX0sIlN0YW5kaW5nIjp7ImVuYWJsZWQiOmZhbHNlLCJmb3JjZSI6ZmFsc2UsInBpdGNoIjoxLjAsInlhdyI6MS4wLCJ+ZW5hYmxlZCI6eyJ0aW1pbmciOjE2LjB9LCJ+cGl0Y2giOnsiYXJlYSI6OTAuMCwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9LCJ+eWF3Ijp7ImFyZWEiOjkwLjAsImNvdW50ZXJhY3QiOmZhbHNlLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNldmVuIjowLjAsInNpeCI6MC4wLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9fX0sImRlbGF5Ijp7IkFpcmR1Y2siOnsiZW5hYmxlZCI6IkRpc2FibGVkIiwibWF4dGlja3MiOjYuMCwibWludGlja3MiOjAuMCwidGlja3MiOjAuMH0sIkNyb3VjaGluZyI6eyJlbmFibGVkIjoiUmFuZG9tIiwibWF4dGlja3MiOjMuMCwibWludGlja3MiOjEuMCwidGlja3MiOjAuMH0sIkNyb3VjaHdhbGsiOnsiZW5hYmxlZCI6IkRpc2FibGVkIiwibWF4dGlja3MiOjYuMCwibWludGlja3MiOjAuMCwidGlja3MiOjAuMH0sIkdsb2JhbCI6eyJlbmFibGVkIjoiRGlzYWJsZWQiLCJtYXh0aWNrcyI6Ni4wLCJtaW50aWNrcyI6MC4wLCJ0aWNrcyI6MC4wfSwiSW4gQWlyIjp7ImVuYWJsZWQiOiJEaXNhYmxlZCIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInRpY2tzIjo1LjB9LCJSdW5uaW5nIjp7ImVuYWJsZWQiOiJSYW5kb20iLCJtYXh0aWNrcyI6My4wLCJtaW50aWNrcyI6MC4wLCJ0aWNrcyI6MC4wfSwiU2xvd3dhbGsiOnsiZW5hYmxlZCI6IkRpc2FibGVkIiwibWF4dGlja3MiOjYuMCwibWludGlja3MiOjAuMCwidGlja3MiOjAuMH0sIlN0YW5kaW5nIjp7ImVuYWJsZWQiOiJEaXNhYmxlZCIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInRpY2tzIjowLjB9fSwiZXh0cmEiOnsiYnJlYWtlciI6dHJ1ZSwiZXhwbG9pdCI6ZmFsc2UsImZyZWVzdGFuZGluZyI6ZmFsc2UsImZ1Y2tkZWZlbnNpdmUiOnRydWUsIm1hbnVhbCI6IkRlZmF1bHQiLCJvcHRpb25zIjpbIkF0IFRhcmdldCIsIkF2b2lkIEJhY2tzdGFiIiwifiJdLCJzYWZlaGVhZCI6WyJPbiBLbmlmZSIsIk9uIFpldXMiLCJ+Il0sIndhcm11cGFhIjpmYWxzZSwifmJyZWFrZXIiOnsiYWlyIjoiU3RhdGljIExlZ3MiLCJncm91bmQiOiJEZWZhdWx0In0sIn5leHBsb2l0Ijp7ImRlZ3JlZSI6OTAuMCwiaml0dGVyIjpmYWxzZSwibW9kZSI6Ikluc3RhbnQiLCJwaXRjaCI6ODkuMCwicmFuZG9taXplIjpmYWxzZSwidGltaW5nIjo3LjB9LCJ+ZnJlZXN0YW5kaW5nIjp7ImVkZ2ViYWl0IjpmYWxzZSwicGl0Y2giOjAuMCwieWF3IjowLjB9fSwibWFpbiI6eyJjb25kaXRpb24iOiJBaXJkdWNrIiwiZW5hYmxlcyI6eyJBaXJkdWNrIjp0cnVlLCJDcm91Y2hpbmciOnRydWUsIkNyb3VjaHdhbGsiOmZhbHNlLCJJbiBBaXIiOnRydWUsIlJ1bm5pbmciOnRydWUsIlNsb3d3YWxrIjp0cnVlLCJTdGFuZGluZyI6ZmFsc2V9fX0sImNvbmZpZ3MiOnsibGlzdCI6NC4wLCJuYW1lIjoidW1tYWNjaGVkIn0sImluZm8iOnsiYWNjZW50Y29sb3IiOiIjRkZCRjAwRkYiLCJwcmVzZXRzIjoiTm9uZSJ9LCJtaXNjIjp7ImFpcmhjIjp0cnVlLCJhdXRvbXV0ZSI6IkRpc2FibGVkIiwiYXV0b3RwIjpmYWxzZSwiY2xhbnRhZyI6ZmFsc2UsImRyb3BuYWRlcyI6eyJncmVuYWRlIjp0cnVlLCJob3RrZXkiOjguMCwibW9sb3RvdiI6dHJ1ZSwic21va2UiOmZhbHNlLCJzcGVlZCI6NS4wfSwiZmFrZWxhdGVuY3kiOjIwMC4wLCJmYXN0bGFkZGVyIjp0cnVlLCJmb3JjZWJhaW0iOnRydWUsImlkZWFsdGljayI6ZmFsc2UsImp1bXBzY291dCI6dHJ1ZSwicmV2b2x2ZXIiOnRydWUsInRyYXNodGFsayI6ZmFsc2UsIn5haXJoYyI6eyJwaXN0b2xzIjoxNS4wLCJyZXZvbHZlciI6MzUuMCwic21ncyI6NS4wLCJzc2cwOCI6NTAuMCwid2VhcG9ucyI6WyJQaXN0b2xzIiwiUmV2b2x2ZXIiLCJTU0ctMDgiLCJTTUdzIiwiWmV1cyIsIn4iXSwiemV1cyI6NjcuMH0sIn5jbGFudGFnIjp7Im1vZGUiOiJCZWJyYVNlbnNlIiwidGFnIjoiIn0sIn5mb3JjZWJhaW0iOnsiaHAiOjY1LjB9LCJ+aWRlYWx0aWNrIjp7InRpbWUiOjEwMC4wLCJ3ZWFwb25zIjpbIn4iXX0sIn5yZXZvbHZlciI6eyJndWlkZXMiOnRydWV9fSwidmlzdWFscyI6eyJhc3BlY3RyYXRpbyI6dHJ1ZSwiY3Jvc3NpbmRpY2F0b3JzIjp0cnVlLCJjdXN0b21zY29wZSI6dHJ1ZSwiZG1naW5kaWNhdG9yIjp0cnVlLCJncmVuYWRlcmFkaXVzIjp0cnVlLCJsb2dzIjp0cnVlLCJtYW51YWxhcnJvd3MiOnRydWUsInZlbG9jaXR5Ijp0cnVlLCJ2aWV3bW9kZWwiOnRydWUsIn5hc3BlY3RyYXRpbyI6eyJyYXRpbyI6MTMzLjB9LCJ+Y3Jvc3NpbmRpY2F0b3JzIjp7ImNsciI6WyJTaW1wbGUiLCIjRkZGRkZGRkYiLCJ+Il0sImNvbG9yIjoiQWNjZW50IENvbG9yIiwiZGVzeW5jIjpmYWxzZSwiZm9udCI6Mi4wLCJoZWlnaHQiOjMwLjAsInN0eWxlIjoiQkVCUkFTRU5TRSJ9LCJ+Y3VzdG9tc2NvcGUiOnsiYW5pbWF0ZSI6dHJ1ZSwiY29sb3IiOiIjRkZCRjAwODAiLCJleGNsdWRlIjpbIn4iXSwiaW52ZXJ0IjpmYWxzZSwibGVuZ3RoIjoxMDAuMCwib2Zmc2V0IjoxMC4wLCJzcGVlZCI6MTUuMCwidGhpY2tuZXNzIjoyLjB9LCJ+ZG1naW5kaWNhdG9yIjp7ImFuaW1hdGVkIjpmYWxzZX0sIn5tYW51YWxhcnJvd3MiOnsiYWN0aXZlbW9kZSI6IkFjY2VudCBDb2xvciIsImNvbG9yIjoiI0ZGRkZGRkZGIiwiaW52aXMiOnRydWUsIm9mZnNldCI6NTAuMCwic2l6ZSI6MTYuMH0sIn52aWV3bW9kZWwiOnsiZm92Ijo2NS4wLCJ4IjoyNS4wLCJ5IjoyMC4wLCJ6IjotMjAuMH19fQ==]])))
        end),
        wishenzlabel = groups.home.info:label(" \v\f<arrow-right-from-arc>\r  Wishenz Preset: "),
        wishenzbtn = groups.home.info:button(" Load ", function()
            pui.load(json.parse(base64.decode([[eyJhbnRpYWltIjp7ImJ1aWxkZXIiOnsiQWlyZHVjayI6eyJib2R5eWF3IjoiQW50aS1CcnV0ZWZvcmNlIiwiaml0dGVyIjoyNC4wLCJtb2RpZmllciI6IjMtV2F5IiwieWF3IjoiQmFja3dhcmQiLCJ+Ym9keXlhdyI6eyJpbnZlcnRlciI6ZmFsc2UsImppdHRlciI6dHJ1ZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTa2l0dGVyIn0sIn55YXciOnsiYWRkbGVmdCI6LTE1LjAsImFkZHJpZ2h0IjoxNS4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjoxMC4wfX0sIkNyb3VjaGluZyI6eyJib2R5eWF3IjoiSml0dGVyIiwiaml0dGVyIjoyNS4wLCJtb2RpZmllciI6IlJhbmRvbSBDZW50ZXIiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOjAuMCwiYWRkcmlnaHQiOjAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX0sIkNyb3VjaHdhbGsiOnsiYm9keXlhdyI6IkRpc2FibGVkIiwiaml0dGVyIjowLjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOjAuMCwiYWRkcmlnaHQiOjAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX0sIkdsb2JhbCI6eyJib2R5eWF3IjoiSml0dGVyIiwiaml0dGVyIjozNS4wLCJtb2RpZmllciI6IjMtV2F5IiwieWF3IjoiQmFja3dhcmQiLCJ+Ym9keXlhdyI6eyJpbnZlcnRlciI6ZmFsc2UsImppdHRlciI6ZmFsc2UsImxlZnRsaW1pdCI6NjAuMCwicmFuZG9taXplIjp0cnVlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJCYWNrIGFuZCBGb3J0aCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOjAuMCwiYWRkcmlnaHQiOjAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX0sIkluIEFpciI6eyJib2R5eWF3IjoiSml0dGVyIiwiaml0dGVyIjowLjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOnRydWUsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6LTE1LjAsImFkZHJpZ2h0IjoxNS4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjowLjB9fSwiUnVubmluZyI6eyJib2R5eWF3IjoiQW50aS1CcnV0ZWZvcmNlIiwiaml0dGVyIjoyMC4wLCJtb2RpZmllciI6IkNlbnRlciIsInlhdyI6IkJhY2t3YXJkIiwifmJvZHl5YXciOnsiaW52ZXJ0ZXIiOmZhbHNlLCJqaXR0ZXIiOnRydWUsImxlZnRsaW1pdCI6NjAuMCwicmFuZG9taXplIjpmYWxzZSwicmlnaHRsaW1pdCI6NjAuMH0sIn5tb2RpZmllciI6eyJzYW1lc2lkZSI6ZmFsc2UsInNlcXVlbmNlIjoiU3RyYWlnaHQifSwifnlhdyI6eyJhZGRsZWZ0IjowLjAsImFkZHJpZ2h0IjowLjAsIm9mZnNldCI6MC4wLCJyYW5kb21pemUiOjEwLjB9fSwiU2xvd3dhbGsiOnsiYm9keXlhdyI6IkFudGktQnJ1dGVmb3JjZSIsImppdHRlciI6MjUuMCwibW9kaWZpZXIiOiJDZW50ZXIiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjp0cnVlLCJsZWZ0bGltaXQiOjYwLjAsInJhbmRvbWl6ZSI6ZmFsc2UsInJpZ2h0bGltaXQiOjYwLjB9LCJ+bW9kaWZpZXIiOnsic2FtZXNpZGUiOmZhbHNlLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0In0sIn55YXciOnsiYWRkbGVmdCI6MC4wLCJhZGRyaWdodCI6MC4wLCJvZmZzZXQiOjAuMCwicmFuZG9taXplIjowLjB9fSwiU3RhbmRpbmciOnsiYm9keXlhdyI6IkRpc2FibGVkIiwiaml0dGVyIjowLjAsIm1vZGlmaWVyIjoiRGlzYWJsZWQiLCJ5YXciOiJCYWNrd2FyZCIsIn5ib2R5eWF3Ijp7ImludmVydGVyIjpmYWxzZSwiaml0dGVyIjpmYWxzZSwibGVmdGxpbWl0Ijo2MC4wLCJyYW5kb21pemUiOmZhbHNlLCJyaWdodGxpbWl0Ijo2MC4wfSwifm1vZGlmaWVyIjp7InNhbWVzaWRlIjpmYWxzZSwic2VxdWVuY2UiOiJTdHJhaWdodCJ9LCJ+eWF3Ijp7ImFkZGxlZnQiOjAuMCwiYWRkcmlnaHQiOjAuMCwib2Zmc2V0IjowLjAsInJhbmRvbWl6ZSI6MC4wfX19LCJkZWZlbnNpdmUiOnsiQWlyZHVjayI6eyJlbmFibGVkIjp0cnVlLCJmb3JjZSI6dHJ1ZSwicGl0Y2giOjEuMCwieWF3IjowLjAsIn5lbmFibGVkIjp7InRpbWluZyI6Mi4wfSwifnBpdGNoIjp7ImFyZWEiOjkwLjAsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6LTg5LjAsInNlcXVlbmNlIjoiU2tpdHRlciIsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH0sIn55YXciOnsiYXJlYSI6MzYwLjAsImNvdW50ZXJhY3QiOnRydWUsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IkJhY2sgYW5kIEZvcnRoIiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoyMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH19LCJDcm91Y2hpbmciOnsiZW5hYmxlZCI6dHJ1ZSwiZm9yY2UiOnRydWUsInBpdGNoIjoxLjAsInlhdyI6Mi4wLCJ+ZW5hYmxlZCI6eyJ0aW1pbmciOjE2LjB9LCJ+cGl0Y2giOnsiYXJlYSI6OTAuMCwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjotNDUuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH0sIn55YXciOnsiYXJlYSI6OTAuMCwiY291bnRlcmFjdCI6dHJ1ZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjotOTAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNldmVuIjowLjAsInNpeCI6MC4wLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjo5MC4wfX0sIkNyb3VjaHdhbGsiOnsiZW5hYmxlZCI6ZmFsc2UsImZvcmNlIjpmYWxzZSwicGl0Y2giOjEuMCwieWF3IjoxLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTYuMH0sIn5waXRjaCI6eyJhcmVhIjo5MC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH0sIn55YXciOnsiYXJlYSI6OTAuMCwiY291bnRlcmFjdCI6ZmFsc2UsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH19LCJHbG9iYWwiOnsiZW5hYmxlZCI6ZmFsc2UsImZvcmNlIjpmYWxzZSwicGl0Y2giOjEuMCwieWF3IjoxLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTYuMH0sIn5waXRjaCI6eyJhcmVhIjo5MC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH0sIn55YXciOnsiYXJlYSI6OTAuMCwiY291bnRlcmFjdCI6ZmFsc2UsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH19LCJJbiBBaXIiOnsiZW5hYmxlZCI6dHJ1ZSwiZm9yY2UiOnRydWUsInBpdGNoIjoyLjAsInlhdyI6My4wLCJ+ZW5hYmxlZCI6eyJ0aW1pbmciOjE2LjB9LCJ+cGl0Y2giOnsiYXJlYSI6OTAuMCwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjotODkuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH0sIn55YXciOnsiYXJlYSI6OTAuMCwiY291bnRlcmFjdCI6ZmFsc2UsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6LTEyMC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjEyMC4wfX0sIlJ1bm5pbmciOnsiZW5hYmxlZCI6ZmFsc2UsImZvcmNlIjpmYWxzZSwicGl0Y2giOjEuMCwieWF3IjoxLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTYuMH0sIn5waXRjaCI6eyJhcmVhIjo5MC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjAuMCwic2VxdWVuY2UiOiJTdHJhaWdodCIsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH0sIn55YXciOnsiYXJlYSI6OTAuMCwiY291bnRlcmFjdCI6ZmFsc2UsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOjAuMH19LCJTbG93d2FsayI6eyJlbmFibGVkIjp0cnVlLCJmb3JjZSI6dHJ1ZSwicGl0Y2giOjEuMCwieWF3IjozLjAsIn5lbmFibGVkIjp7InRpbWluZyI6MTYuMH0sIn5waXRjaCI6eyJhcmVhIjo5MC4wLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjg5LjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzcGVlZCI6MTAuMCwidGhyZWUiOjAuMCwidHdvIjowLjB9LCJ+eWF3Ijp7ImFyZWEiOjkwLjAsImNvdW50ZXJhY3QiOmZhbHNlLCJmaXZlIjowLjAsImZvdXIiOjAuMCwibW92ZW1lbnQiOiJTdHJhaWdodCIsIm9mZnNldCI6MC4wLCJvbmUiOjEyMC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic2V2ZW4iOjAuMCwic2l4IjowLjAsInNwZWVkIjoxMC4wLCJ0aHJlZSI6MC4wLCJ0d28iOi0xMjAuMH19LCJTdGFuZGluZyI6eyJlbmFibGVkIjpmYWxzZSwiZm9yY2UiOmZhbHNlLCJwaXRjaCI6MS4wLCJ5YXciOjEuMCwifmVuYWJsZWQiOnsidGltaW5nIjoxNi4wfSwifnBpdGNoIjp7ImFyZWEiOjkwLjAsImZpdmUiOjAuMCwiZm91ciI6MC4wLCJtb3ZlbWVudCI6IlN0cmFpZ2h0Iiwib2Zmc2V0IjowLjAsIm9uZSI6MC4wLCJzZXF1ZW5jZSI6IlN0cmFpZ2h0Iiwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfSwifnlhdyI6eyJhcmVhIjo5MC4wLCJjb3VudGVyYWN0IjpmYWxzZSwiZml2ZSI6MC4wLCJmb3VyIjowLjAsIm1vdmVtZW50IjoiU3RyYWlnaHQiLCJvZmZzZXQiOjAuMCwib25lIjowLjAsInNlcXVlbmNlIjoiU3RyYWlnaHQiLCJzZXZlbiI6MC4wLCJzaXgiOjAuMCwic3BlZWQiOjEwLjAsInRocmVlIjowLjAsInR3byI6MC4wfX19LCJkZWxheSI6eyJBaXJkdWNrIjp7ImVuYWJsZWQiOiJEaXNhYmxlZCIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInBlcmNlbnQiOjUwLjAsInRpY2tzIjowLjB9LCJDcm91Y2hpbmciOnsiZW5hYmxlZCI6IlJhbmRvbSIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInBlcmNlbnQiOjUwLjAsInRpY2tzIjowLjB9LCJDcm91Y2h3YWxrIjp7ImVuYWJsZWQiOiJEaXNhYmxlZCIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInBlcmNlbnQiOjUwLjAsInRpY2tzIjowLjB9LCJHbG9iYWwiOnsiZW5hYmxlZCI6IlJhbmRvbSIsIm1heHRpY2tzIjo2LjAsIm1pbnRpY2tzIjowLjAsInBlcmNlbnQiOjUwLjAsInRpY2tzIjozLjB9LCJJbiBBaXIiOnsiZW5hYmxlZCI6IkRpc2FibGVkIiwibWF4dGlja3MiOjYuMCwibWludGlja3MiOjAuMCwicGVyY2VudCI6NTAuMCwidGlja3MiOjAuMH0sIlJ1bm5pbmciOnsiZW5hYmxlZCI6IkRpc2FibGVkIiwibWF4dGlja3MiOjYuMCwibWludGlja3MiOjAuMCwicGVyY2VudCI6NTAuMCwidGlja3MiOjAuMH0sIlNsb3d3YWxrIjp7ImVuYWJsZWQiOiJTdGF0aWMiLCJtYXh0aWNrcyI6Ni4wLCJtaW50aWNrcyI6MC4wLCJwZXJjZW50Ijo1MC4wLCJ0aWNrcyI6Mi4wfSwiU3RhbmRpbmciOnsiZW5hYmxlZCI6IkRpc2FibGVkIiwibWF4dGlja3MiOjYuMCwibWludGlja3MiOjAuMCwicGVyY2VudCI6NTAuMCwidGlja3MiOjAuMH19LCJleHRyYSI6eyJicmVha2VyIjp0cnVlLCJleHBsb2l0IjpmYWxzZSwiZnJlZXN0YW5kaW5nIjpmYWxzZSwiZnVja2RlZmVuc2l2ZSI6ZmFsc2UsIm1hbnVhbCI6IkRlZmF1bHQiLCJvcHRpb25zIjpbIkF0IFRhcmdldCIsIkF2b2lkIEJhY2tzdGFiIiwifiJdLCJzYWZlaGVhZCI6WyJPbiBLbmlmZSIsIn4iXSwid2FybXVwYWEiOmZhbHNlLCJ+YnJlYWtlciI6eyJhaXIiOiJTdGF0aWMgTGVncyIsImdyb3VuZCI6IkRlZmF1bHQifSwifmV4cGxvaXQiOnsiZGVncmVlIjo5MC4wLCJqaXR0ZXIiOmZhbHNlLCJtb2RlIjoiSW5zdGFudCIsInBpdGNoIjo4OS4wLCJyYW5kb21pemUiOmZhbHNlLCJ0aW1pbmciOjcuMH0sIn5mcmVlc3RhbmRpbmciOnsiZWRnZWJhaXQiOmZhbHNlLCJwaXRjaCI6ODkuMCwieWF3IjowLjB9fSwibWFpbiI6eyJjb25kaXRpb24iOiJBaXJkdWNrIiwiZW5hYmxlcyI6eyJBaXJkdWNrIjp0cnVlLCJDcm91Y2hpbmciOnRydWUsIkNyb3VjaHdhbGsiOmZhbHNlLCJJbiBBaXIiOnRydWUsIlJ1bm5pbmciOnRydWUsIlNsb3d3YWxrIjp0cnVlLCJTdGFuZGluZyI6ZmFsc2V9fX0sImNvbmZpZ3MiOnsibGlzdCI6NS4wLCJuYW1lIjoid2lzaGVueiJ9LCJpbmZvIjp7ImFjY2VudGNvbG9yIjoiI0ZGRkZGRkZGIiwicHJlc2V0cyI6Ik5vbmUifSwibWlzYyI6eyJhaXJoYyI6dHJ1ZSwiYXV0b211dGUiOiJEaXNhYmxlZCIsImF1dG90cCI6ZmFsc2UsImNsYW50YWciOmZhbHNlLCJkcm9wbmFkZXMiOnsiZ3JlbmFkZSI6dHJ1ZSwiaG90a2V5Ijo4LjAsIm1vbG90b3YiOnRydWUsInNtb2tlIjpmYWxzZSwic3BlZWQiOjQuMH0sImZha2VsYXRlbmN5IjotMS4wLCJmYXN0bGFkZGVyIjp0cnVlLCJmb3JjZWJhaW0iOnRydWUsImlkZWFsdGljayI6ZmFsc2UsImp1bXBzY291dCI6dHJ1ZSwicmV2b2x2ZXIiOnRydWUsInRyYXNodGFsayI6dHJ1ZSwifmFpcmhjIjp7InBpc3RvbHMiOjUwLjAsInJldm9sdmVyIjo1MC4wLCJzbWdzIjo1MC4wLCJzc2cwOCI6NTAuMCwid2VhcG9ucyI6WyJQaXN0b2xzIiwiUmV2b2x2ZXIiLCJTU0ctMDgiLCJaZXVzIiwifiJdLCJ6ZXVzIjo1MC4wfSwifmNsYW50YWciOnsibW9kZSI6IkJlYnJhU2Vuc2UiLCJ0YWciOiIifSwifmZvcmNlYmFpbSI6eyJocCI6NjAuMH0sIn5pZGVhbHRpY2siOnsidGltZSI6MTAwLjAsIndlYXBvbnMiOlsifiJdfSwifnJldm9sdmVyIjp7Imd1aWRlcyI6dHJ1ZX19LCJ2aXN1YWxzIjp7ImFzcGVjdHJhdGlvIjp0cnVlLCJjcm9zc2luZGljYXRvcnMiOnRydWUsImN1c3RvbXNjb3BlIjp0cnVlLCJkbWdpbmRpY2F0b3IiOnRydWUsImdyZW5hZGVyYWRpdXMiOnRydWUsImxvZ3MiOnRydWUsIm1hbnVhbGFycm93cyI6dHJ1ZSwidmVsb2NpdHkiOnRydWUsInZpZXdtb2RlbCI6dHJ1ZSwifmFzcGVjdHJhdGlvIjp7InJhdGlvIjoxMzMuMH0sIn5jcm9zc2luZGljYXRvcnMiOnsiY2xyIjpbIlNpbXBsZSIsIiNEMzk3OTdGRiIsIn4iXSwiY29sb3IiOiJDdXN0b20iLCJkZXN5bmMiOnRydWUsImZvbnQiOjQuMCwiaGVpZ2h0IjoxOC4wLCJzdHlsZSI6ImJlYnJhc2Vuc2UifSwifmN1c3RvbXNjb3BlIjp7ImFuaW1hdGUiOnRydWUsImNvbG9yIjoiI0ZGRkZGRkZGIiwiZXhjbHVkZSI6WyJ+Il0sImludmVydCI6ZmFsc2UsImxlbmd0aCI6MTAwLjAsIm9mZnNldCI6MTAuMCwic3BlZWQiOjE1LjAsInRoaWNrbmVzcyI6MS4wfSwifmRtZ2luZGljYXRvciI6eyJhbmltYXRlZCI6dHJ1ZX0sIn5tYW51YWxhcnJvd3MiOnsiYWN0aXZlbW9kZSI6IkFjY2VudCBDb2xvciIsImNvbG9yIjoiI0ZGRkZGRkZGIiwiaW52aXMiOnRydWUsIm9mZnNldCI6NTAuMCwic2l6ZSI6MTYuMH0sIn52aWV3bW9kZWwiOnsiZm92Ijo2OC4wLCJ4IjoyNS4wLCJ5IjoyMC4wLCJ6IjotMjAuMH19fQ==]])))
        end),
        accentcolor = groups.home.info:color_picker("\v\f<palette>\r  Accent Color", ui.get_style("Link Active")),
        watermark = groups.home.info:combo("\v\f<star>\r  Watermark Style", {"Default", "Kitty", "Legacy"}),

        groups.home.info:label("\nMade with \v\f<heart>\r by wishenz & estro")

    },
    configs = {
        name = groups.home.configs:input("\v\f<pen-to-square>\r  Name"),

        save = groups.home.configs:button(" \v\f<floppy-disk>\r  Save ", nil, true),
        load = groups.home.configs:button(" \v\f<download>\r  Load ", nil, true),
        loadaa = groups.home.configs:button( " \v\f<shield>\r " , nil, true),
        delete = groups.home.configs:button(" \v\f<trash>\r  "..colors.red.."Delete ", nil, true),
        import = groups.home.configs:button(" \v\f<file-import>\r  Import ", function()
            pui.load(json.parse(base64.decode(clipboard.get())))
            responseclr.importing = 255
        end, true),
        export = groups.home.configs:button(" \v\f<file-export>\r  Export ", function()
            clipboard.set(base64.encode(json.stringify(pui.save())))
            responseclr.exporting = 255
        end, true),
        reset = groups.home.configs:button(" \v\f<arrows-rotate>\r  "..colors.red.."Reset ", nil, true),
        list = groups.home.configs:list("", configslist),

        resetconfirm = {
            label = groups.home.configs:label("Are you sure you want to reset your menu?\n\a"..ui.get_style("Disabled Text"):to_hex().."Only resets menu. Not the selected config."),
            yesbtn = groups.home.configs:button(colors.green.."   \f<check>   ", nil, true),
            nobtn = groups.home.configs:button(colors.red.."    \f<xmark>    ", nil, true)
        },
        deleteconfirm = {
            label = groups.home.configs:label("Are you sure you want to delete the config?"),
            yesbtn = groups.home.configs:button(colors.green.."   \f<check>   ", nil, true),
            nobtn = groups.home.configs:button(colors.red.."    \f<xmark>    ", nil, true)
        }
    },
    antiaim = {
        main = {
            condition = groups.antiaim.main:combo("\v\f<list>\r  Condition", conditions),
            enables = {},
        },
        watermark = groups.antiaim.watermark:label(watermark),
        extra = {
            options = groups.antiaim.extra:selectable("\v\f<gears>\r  Options", {"At Target", "Avoid Backstab"}),
            manual = groups.antiaim.extra:combo("\v\f<arrows-up-down-left-right>\r  Manual Anti-Aim", {"Default", "Forward", "Left", "Right"}),
            safehead = groups.antiaim.extra:selectable("\v\f<helmet-safety>\r  Safe Head", {"On Knife", "On Zeus"}),
            warmupaa = groups.antiaim.extra:switch("\v\f<arrows-rotate>\r  Warmup AA"),
            fuckdefensive = groups.antiaim.extra:switch("\v\f<lock-keyhole>\r  Force Disable Defensive", false),
            freestanding = groups.antiaim.extra:switch("\v\f<person-walking-dashed-line-arrow-right>"..colors.yellow.."  Freestanding", false, function(cog)
                return {
                    edgebait = cog:switch("Defensive Edge Bait", false),
                    pitch = cog:slider("Pitch", -89, 89, 0, 1, "°"),
                    yaw = cog:slider("Yaw", -180, 180, 0, 1, "°"),
                }
            end),
            breaker = groups.antiaim.extra:switch("\v\f<bone-break>\r  "..colors.yellow.."Animation Breaker", false, function(cog)
                return {
                    ground = cog:combo("On Ground", {"Default", "Static Slide", "Moonwalk"}),
                    air = cog:combo("In Air", {"Default", "Static Legs", "Walking"})
                }
            end),
            exploit = groups.antiaim.extra:switch("\v\f<skull>\r"..colors.yellow.."  Flick Exploit", false, function(cog)
                return {
                    mode = cog:combo("Mode", {"Instant", "Havoc"}),
                    pitch = cog:slider("Pitch", -89, 89, 89, 1, function(val)
                        if val == -89 then
                            return "Up"
                        elseif val == 89 then
                            return "Down"
                        else
                            return val .. "°"
                        end
                    end),
                    degree = cog:slider("Yaw", -180, 180, 90, 1, "°"),
                    timing = cog:slider("Timing", 2, 14, 7, 1, "t"),
                    randomize = cog:switch("Randomize Timing", false),
                    jitter = cog:switch("Jitter", false),
                }
            end)
        },
        delay = {},
        builder = {},
        defensive = {}
    },
    misc = {
        clantag = groups.other.misc:switch("\v\f<tag>\r  Clantag", false, function(cog)
            return {
                mode = cog:combo("Style", {"BebraSense", "Custom"}),
                tag = cog:input("Clantag")
            }
        end),
        autotp = groups.other.misc:switch("\v\f<wind-warning>\r  Air Lag"),
        fastladder = groups.other.misc:switch("\v\f<water-ladder>\r  Fast Ladder"),
        automute = groups.other.misc:combo("\v\f<microphone>\r  Auto Mute", {"Disabled", "Mute All", "Unmute All"}),
        dropnades = groups.other.misc:label("\v\f<recycle>\r  Auto Drop Nades", function(cog)
            return {
                hotkey = cog:hotkey("Hotkey"),
                grenade = cog:switch("Drop Grenade", true),
                molotov = cog:switch("Drop Molotov", true),
                smoke = cog:switch("Drop Smoke", false),
                speed = cog:slider(colors.yellow.."Cycle Delay", 2, 16, 4, 1, "t")
            }
        end),
        airhc = groups.other.misc:switch("\v\f<feather-pointed>\r  In Air Hitchance", false, function(cog)
            return {
                weapons = cog:selectable("\v\f<gear>\r  Active Weapons", {"Pistols", "Revolver", "SSG-08", "SMGs", "Zeus"}),
                pistols = cog:slider("\v\f<gun>\r  Pistols", 0, 100, 50, 1),
                revolver = cog:slider("\v\f<gun>\r  Revolver", 0, 100, 50, 1),
                ssg08 = cog:slider("\v\f<gun>\r  SSG-08", 0, 100, 50, 1),
                smgs = cog:slider("\v\f<gun>\r  SMGs", 0, 100, 50, 1),
                zeus = cog:slider("\v\f<gun>\r  Zeus", 0, 100, 50, 1)
            }
        end),
        autohs = groups.other.misc:switch("\v\f<eye-slash>\r  Auto Hide Shots", false),
        forcebaim = groups.other.misc:switch("\v\f<face-head-bandage>\r  Body Aim If Lethal", false, function(cog)
            return {
                hp = cog:slider("Force Below", 10, 92, 50, 1, "HP"),
            }
        end),
        jumpscout = groups.other.misc:switch("\v\f<person-ski-jumping>\r  Jumpscout Fix"),
        fakelatency = groups.other.misc:slider("\v\f<wifi>\r  Fake Latency", -1, 200, -1, 1, function(var)
            if var == -1 then
                return "default"
            else
                return var .. "ms"
            end
        end),
        trashtalk = groups.other.misc:switch("\v\f<bullhorn>\r  Trashtalk"),
        idealtick = groups.other.misc:switch("\v\f<wind>\r  Faster Ideal Tick", false, function(cog)
            return {
                weapons = cog:selectable("Quick-Switch", "SSG-08", "AWP", "Desert Eagle", "R8 Revolver"),
                time = cog:slider("Weapon Equip", 1, 500, 100, 1, "ms")
            }
        end),
        revolver = groups.other.misc:switch("\v\f<bolt>\r  Predictive Revolver", false, function(cog)
            return {
                guides = cog:switch("Peek Guides")
            }
        
        end),
    },
    visuals = {
        aspectratio = groups.other.visuals:switch("\v\f<tv>\r  Aspect Ratio", false, function(cog)
            return {
                ratio = cog:slider("Aspect Ratio", 1, 400, 133, 0.01),
                caseoh = cog:button("Caseoh"),
                fivefour = cog:button("5:4"),
                fourthree = cog:button("4:3"),
                sixteenten = cog:button("16:10"),
                sixteennine = cog:button("16:9")
            }
        end),
        viewmodel = groups.other.visuals:switch("\v\f<hand>\r  Viewmodel", false, function(cog)
            return {
                fov = cog:slider("Viewmodel FOV", 0, 120, 68),
                x = cog:slider("X offset", -200, 200, 25, 0.1),
                y = cog:slider("Y offset", -200, 200, 20, 0.1),
                z = cog:slider("Z offset", -200, 200, -20, 0.1)
            }
        end),
        logs = groups.other.visuals:switch("\v\f<scroll>\r  Aimbot Logs", false),
        crossindicators = groups.other.visuals:switch("\v\f<crosshairs-simple>\r  Crosshair Indicators", false, function(cog)
            return {
                height = cog:slider("Height", 0, 200, 30, 1),
                simple = cog:switch("Simple", false),
                color = cog:combo("Color", {"Accent Color", "Custom"}),
                clr = cog:color_picker("", {
                    ["Simple"] = { color(255) },
                    ["Gradient"] = { color(255), color(0) },
                }),
            }
        end),
        dmgindicator = groups.other.visuals:switch("\v\f<droplet>\r  Damage Indicator", false, function(cog)
            return {
                animated = cog:switch("Animated"),
                offset = cog:slider("Offset", 0, 50, 10)
            }
        end),
        customscope = groups.other.visuals:switch("\v\f<telescope>\r  Custom Scope", false, function(cog)
            return {
                color = cog:color_picker("Color", color(255)),
                invert = cog:switch("Invert", false),
                length = cog:slider("Length", 0, 500, 100),
                thickness = cog:slider("Thickness", 1, 15, 1),
                offset = cog:slider("Offset", 0, 100, 10),
                exclude = cog:selectable("Exclude Lines", {"Top", "Bottom", "Left", "Right"}),
                animate = cog:switch("Animated", true),
                speed = cog:slider("Animation Speed", 10, 50, 15, 1)
            }
        end),
        grenaderadius = groups.other.visuals:switch("\v\f<bomb>\r  Grenade Radius", false),
        manualarrows = groups.other.visuals:switch("\v\f<arrows-left-right>\r  Manual Arrows", false, function(cog)
            return {
                activemode = cog:combo("Active", {"Accent Color", "Custom"}),
                color = cog:color_picker("Color", color(255)),
                invis = cog:switch("Transparent Inactive", false),
                offset = cog:slider("Offset", 20, 200, 50, 1, "px"),
                size = cog:slider("Size", 8, 64, 16, 1, "px")
            }
        end),
        velocity = groups.other.visuals:switch("\v\f<triangle-exclamation>\r  Slowdown Indicator", false, function(cog)
            return {
                offset = cog:slider("dsadasd", 1, render.screen_size().y, 400),
            }
        end)
    },
    groups.other.watermark:label(watermark)
}

pui.colors.red = color(255,100,100)
pui.colors.yellow = color(230,230,100)
pui.colors.green = color(100,255,100)
pui.colors.mildgreen = color(150,220,150)
pui.colors.accent = items.info.accentcolor:get()

items.info.accentcolor:set_callback(function()
    pui.colors.accent = items.info.accentcolor:get()
end)

--config response text

local cfgfont = render.load_font("arial", 32, "a")
responseclr = {
    loading = 0,
    loadaa = 0,
    exporting = 0,
    importing = 0,
    resetting = 0,
    saving = 0,
    deleting = 0
}

events.render(function()
    local screen2 = render.screen_size()/2
    local acc = items.info.accentcolor:get()

    -- for loop didnt work for some reason :/ shit code incoming
    responseclr.loading = responseclr.loading - 1 * (globals.frametime * 200)
    responseclr.exporting = responseclr.exporting - 1 * (globals.frametime * 200)
    responseclr.importing = responseclr.importing - 1 * (globals.frametime * 200)
    responseclr.resetting = responseclr.resetting - 1 * (globals.frametime * 200)
    responseclr.saving = responseclr.saving - 1 * (globals.frametime * 200)
    responseclr.deleting = responseclr.deleting - 1 * (globals.frametime * 200)
    responseclr.loadaa = responseclr.loadaa  - 1 * (globals.frametime * 200)

    if responseclr.loading > 0 then --just gonna do this in hopes of optimizing it a bit but idk
        render.text(cfgfont,vector(screen2.x + 1, screen2.y/3 + 1),color(0, responseclr.loading),"c","Config Loaded") --first line is shadow
        render.text(cfgfont,vector(screen2.x, screen2.y/3),color(acc.r,acc.g,acc.b, responseclr.loading),"c","Config Loaded") --second is main color text
    end
    if responseclr.loadaa > 0 then
            render.text(cfgfont,vector(screen2.x + 1, screen2.y/3 + 1),color(0, responseclr.loadaa),"c","Anti-Aim Loaded")
            render.text(cfgfont,vector(screen2.x, screen2.y/3),color(acc.r,acc.g,acc.b, responseclr.loadaa),"c","Anti-Aim Loaded")
    end
    if responseclr.exporting > 0 then
            render.text(cfgfont,vector(screen2.x + 1, screen2.y/3 + 1),color(0, responseclr.exporting),"c","Settings Exported to Clipboard")
            render.text(cfgfont,vector(screen2.x, screen2.y/3),color(acc.r,acc.g,acc.b, responseclr.exporting),"c","Settings Exported to Clipboard")
    end
    if responseclr.importing > 0 then
        render.text(cfgfont,vector(screen2.x + 1, screen2.y/3 + 1),color(0, responseclr.importing),"c","Settings Imported from Clipboard")
        render.text(cfgfont,vector(screen2.x, screen2.y/3),color(acc.r,acc.g,acc.b, responseclr.importing),"c","Settings Imported from Clipboard")
    end
    if responseclr.resetting > 0 then
        render.text(cfgfont,vector(screen2.x + 1, screen2.y/3 + 1),color(0, responseclr.resetting),"c","Menu Settings Reset")
        render.text(cfgfont,vector(screen2.x, screen2.y/3),color(acc.r,acc.g,acc.b, responseclr.resetting),"c","Menu Settings Reset")
    end
    if responseclr.saving > 0 then
        render.text(cfgfont,vector(screen2.x + 1, screen2.y/3 + 1),color(0, responseclr.saving),"c","Config Saved")
        render.text(cfgfont,vector(screen2.x, screen2.y/3),color(acc.r,acc.g,acc.b, responseclr.saving),"c","Config Saved")
    end
    if responseclr.deleting > 0 then
        render.text(cfgfont,vector(screen2.x + 1, screen2.y/3 + 1),color(0, responseclr.deleting),"c","Config Deleted")
        render.text(cfgfont,vector(screen2.x, screen2.y/3),color(acc.r,acc.g,acc.b, responseclr.deleting),"c","Config Deleted")
    end
end)

-- config system stuffs

items.configs.resetconfirm.label:visibility(false)
items.configs.resetconfirm.yesbtn:visibility(false)
items.configs.resetconfirm.nobtn:visibility(false)

items.configs.deleteconfirm.label:visibility(false)
items.configs.deleteconfirm.yesbtn:visibility(false)
items.configs.deleteconfirm.nobtn:visibility(false)

items.info.unmatchedbtn:set_callback(function()
    if #configslist ~= 0 then
        items.configs.list:set(1)
        items.configs.name:set(configslist[items.configs.list:get()])
    else
        items.configs.name:set("")
    end
end)
items.info.defensivebtn:set_callback(function()
    if #configslist ~= 0 then
        items.configs.list:set(1)
        items.configs.name:set(configslist[items.configs.list:get()])
    else
        items.configs.name:set("")
    end
end)
items.info.wishenzbtn:set_callback(function()
    if #configslist ~= 0 then
        items.configs.list:set(1)
        items.configs.name:set(configslist[items.configs.list:get()])
    else
        items.configs.name:set("")
    end
end)

items.configs.reset:set_callback(function()
    items.configs.resetconfirm.label:visibility(true)
    items.configs.resetconfirm.yesbtn:visibility(true)
    items.configs.resetconfirm.nobtn:visibility(true)

    items.configs.deleteconfirm.label:visibility(false)
    items.configs.deleteconfirm.yesbtn:visibility(false)
    items.configs.deleteconfirm.nobtn:visibility(false)
end)
items.configs.resetconfirm.yesbtn:set_callback(function()
    --   '{"antiaim": {"builder": {},"defensive": {},"delay": {},"extra": {},"main": {}},"misc": {}, "visuals": {}}'   in case ill need to do it this way
    pui.load("")

    responseclr.resetting = 255

    items.configs.resetconfirm.label:visibility(false)
    items.configs.resetconfirm.yesbtn:visibility(false)
    items.configs.resetconfirm.nobtn:visibility(false)
end)
items.configs.resetconfirm.nobtn:set_callback(function()
    items.configs.resetconfirm.label:visibility(false)
    items.configs.resetconfirm.yesbtn:visibility(false)
    items.configs.resetconfirm.nobtn:visibility(false)
end)

items.configs.delete:set_callback(function()
    items.configs.resetconfirm.label:visibility(false)
    items.configs.resetconfirm.yesbtn:visibility(false)
    items.configs.resetconfirm.nobtn:visibility(false)

    items.configs.deleteconfirm.label:visibility(true)
    items.configs.deleteconfirm.yesbtn:visibility(true)
    items.configs.deleteconfirm.nobtn:visibility(true)
end)

items.configs.deleteconfirm.yesbtn:set_callback(function()
    mtools.FileSystem:DeleteFile("bebrasense\\", items.configs.name:get())
    configslist = mtools.FileSystem:ReadFolder("bebrasense", true)
    if #configslist ~= 0 then
        items.configs.list:update(configslist)
        items.configs.list:set(1)
        items.configs.name:set(configslist[items.configs.list:get()])
    else
        items.configs.list:update({})
        items.configs.name:set("")
    end
    items.configs.deleteconfirm.label:visibility(false)
    items.configs.deleteconfirm.yesbtn:visibility(false)
    items.configs.deleteconfirm.nobtn:visibility(false)
    responseclr.deleting = 255
end)

items.configs.deleteconfirm.nobtn:set_callback(function()
    items.configs.deleteconfirm.label:visibility(false)
    items.configs.deleteconfirm.yesbtn:visibility(false)
    items.configs.deleteconfirm.nobtn:visibility(false)
end)

items.configs.save:set_callback(function()
    files.write("bebrasense/"..items.configs.name:get(), base64.encode(json.stringify(pui.save())))
    configslist = mtools.FileSystem:ReadFolder("bebrasense", true)
    items.configs.list:update(configslist)
    for i, v in pairs(configslist) do
        if v == items.configs.name:get() then
            setlist = i
        end
    end
    items.configs.list:set(setlist)
    responseclr.saving = 255
end)
items.configs.load:set_callback(function()
    local oldname = items.configs.name:get()
    responseclr.loading = 255
    pui.load(json.parse(base64.decode(files.read("bebrasense/"..items.configs.name:get()))))
    items.configs.name:set(oldname)
end)
items.configs.loadaa:set_callback(function()
    responseclr.loadaa = 255
    pui.load(json.parse(base64.decode(files.read("bebrasense/"..items.configs.name:get()))), "antiaim")
end)


items.configs.list:set_callback(function()
    if #configslist ~= 0 then
        items.configs.name:set(configslist[items.configs.list:get()])
    end
    items.configs.resetconfirm.label:visibility(false)
    items.configs.resetconfirm.yesbtn:visibility(false)
    items.configs.resetconfirm.nobtn:visibility(false)

    items.configs.deleteconfirm.label:visibility(false)
    items.configs.deleteconfirm.yesbtn:visibility(false)
    items.configs.deleteconfirm.nobtn:visibility(false)
end)

items.configs.name:set_callback(function()
    if items.configs.name:get() == "D9q2LnT8ATe9zXCu" then
        secretdisablewatermark = true
    end
    items.configs.resetconfirm.label:visibility(false)
    items.configs.resetconfirm.yesbtn:visibility(false)
    items.configs.resetconfirm.nobtn:visibility(false)

    items.configs.deleteconfirm.label:visibility(false)
    items.configs.deleteconfirm.yesbtn:visibility(false)
    items.configs.deleteconfirm.nobtn:visibility(false)
end)

for i = 2, #conditions do -- generate enable switches for conditions and make them dependant on their respective condition
    local cond = conditions[i]
    items.antiaim.main.enables[cond] = groups.antiaim.main:switch("\v\f<shield>\r  Enabled", false)
    items.antiaim.main.enables[cond]:depend({ items.antiaim.main.condition, cond })
end

for i = 1, #conditions do -- generate builder, defensive and delay items and make them dependant
    local cond = conditions[i]

    items.antiaim.builder[cond] = {}
    items.antiaim.defensive[cond] = {}
    items.antiaim.delay[cond] = {}

    -- builder
    items.antiaim.builder[cond].yaw = groups.antiaim.builder[cond]:combo("Yaw", {"Backward", "Static"}, function(cog)
        return{
            offset = cog:slider("Offset", -180, 180, 0, 1, "°"),
            addleft = cog:slider("Add Left", -90, 90, 0, 1, "°"),
            addright = cog:slider("Add Right", -90, 90, 0, 1, "°"),
            randomize = cog:slider("Randomize", 0, 90, 0, 1, "°")
        }
    end)
    items.antiaim.builder[cond].modifier = groups.antiaim.builder[cond]:combo("Yaw Modifier", {"Disabled", "Center", "Random Center", "Offset", "Random", "3-Way", "5-Way"}, function(cog)
        return {
            sequence = cog:combo("Jitter Sequence", {"Straight", "Back and Forth", "Skitter"}),
            sameside = cog:switch("Allow Same-Siding", false)
        }
    end)
    items.antiaim.builder[cond].jitter = groups.antiaim.builder[cond]:slider("Jitter", -180, 180, 0, 1, "°")
    items.antiaim.builder[cond].bodyyaw = groups.antiaim.builder[cond]:combo("Body Yaw", {"Disabled", "Static", "Jitter", "Anti-Bruteforce"}, function(cog)
        return {
            leftlimit = cog:slider("Left Limit", 0, 60, 60, 1),
            rightlimit = cog:slider("Right Limit", 0, 60, 60, 1),
            inverter = cog:switch("Inverter", false),
            jitter = cog:switch("Jitter", false),
            randomize = cog:switch("Randomized Jitter", false)
        }
    end)

    groups.antiaim.builder[cond]:depend({ items.antiaim.main.condition, cond })
    items.antiaim.builder[cond].yaw.addleft:depend({ items.antiaim.builder[cond].bodyyaw, "Static", "Jitter", "Anti-Bruteforce" })
    items.antiaim.builder[cond].yaw.addright:depend({ items.antiaim.builder[cond].bodyyaw, "Static", "Jitter", "Anti-Bruteforce" })
    items.antiaim.builder[cond].jitter:depend({ items.antiaim.builder[cond].modifier, "Center", "Offset", "Random", "3-Way", "5-Way", "Random Center"})
    items.antiaim.builder[cond].modifier.sequence:depend({ items.antiaim.builder[cond].modifier, "3-Way", "5-Way"})
    items.antiaim.builder[cond].modifier.sameside:depend({ items.antiaim.builder[cond].modifier, "3-Way", "5-Way"}, {items.antiaim.builder[cond].modifier.sequence, "Skitter"})
    items.antiaim.builder[cond].bodyyaw.leftlimit:depend({ items.antiaim.builder[cond].bodyyaw, "Static", "Jitter", "Anti-Bruteforce" })
    items.antiaim.builder[cond].bodyyaw.rightlimit:depend({ items.antiaim.builder[cond].bodyyaw, "Static", "Jitter", "Anti-Bruteforce" })
    items.antiaim.builder[cond].bodyyaw.inverter:depend({ items.antiaim.builder[cond].bodyyaw, "Static" })
    items.antiaim.builder[cond].bodyyaw.jitter:depend({ items.antiaim.builder[cond].bodyyaw, "Anti-Bruteforce" })
    items.antiaim.builder[cond].bodyyaw.randomize:depend({ items.antiaim.builder[cond].bodyyaw, "Jitter" })

    -- defensive
    items.antiaim.defensive[cond].enabled = groups.antiaim.defensive[cond]:switch("Defensive", false, function(cog)
        return {
            timing = cog:slider("Timing", 1, 16, 16, 1, "t"),
            delay = cog:combo("Delay", {"Disabled", "Static", "Random", "Random %", "Fluctuate"}),
            ticks = cog:slider("Ticks", 0, 24, 0, 1, "t"),
            minticks = cog:slider("Minimum Ticks", 0, 24, 0, 1, "t"),
            maxticks = cog:slider("Maximum Ticks", 0, 24, 6, 1, "t"),
            percent = cog:slider("Switch Chance", 0, 100, 50, 1, "%")
        }
    end)
    items.antiaim.defensive[cond].pitch = groups.antiaim.defensive[cond]:slider("Pitch", 0, 5, 1, 1, function(val)
        if val == 0 then
            return "Area"
        else
            return val.."x"
        end
    end, function(cog)
        return {
            offset = cog:slider("Pitch Offset", -89, 89, 0, 1, "°"),
            area = cog:slider("Area", 0, 178, 90, 1, "°"),
            movement = cog:combo("Pitch Movement", {"Straight", "Back and Forth", "Random", "Bebra"}),
            speed = cog:slider("Spin Speed", 1, 30, 10),
            sequence = cog:combo("Pitch Sequence", {"Straight", "Back and Forth", "Skitter"}),
            one = cog:slider("1", -89, 89, 0),
            two = cog:slider("2", -89, 89, 0),
            three = cog:slider("3", -89, 89, 0),
            four = cog:slider("4", -89, 89, 0),
            five = cog:slider("5", -89, 89, 0),
        }
    end)
    items.antiaim.defensive[cond].yaw = groups.antiaim.defensive[cond]:slider("Yaw", 0, 7, 1, 1, function(val)
        if val == 0 then
            return "Area"
        else
            return val.."x"
        end
    end, function(cog)
        return {
            offset = cog:slider("Yaw Offset", -180, 180, 0, 1, "°"),
            area = cog:slider("Area", 0, 360, 90, 1, "°"),
            movement = cog:combo("Yaw Movement", {"Straight", "Back and Forth", "Random", "Bebra"}),
            speed = cog:slider("Spin Speed", 1, 30, 10),
            sequence = cog:combo("Yaw Sequence", {"Straight", "Back and Forth", "Skitter"}),
            counteract = cog:switch("Counteract Angles", false),
            one = cog:slider("1", -180, 180, 0),
            two = cog:slider("2", -180, 180, 0),
            three = cog:slider("3", -180, 180, 0),
            four = cog:slider("4", -180, 180, 0),
            five = cog:slider("5", -180, 180, 0),
            six = cog:slider("6", -180, 180, 0),
            seven = cog:slider("7", -180, 180, 0),
        }
    end)
    items.antiaim.defensive[cond].force = groups.antiaim.defensive[cond]:switch("Force LC")

    groups.antiaim.defensive[cond]:depend({ items.antiaim.main.condition, cond })
    items.antiaim.defensive[cond].enabled.timing:depend({ items.antiaim.defensive[cond].enabled, true })

    items.antiaim.defensive[cond].enabled.delay:depend({ items.antiaim.defensive[cond].enabled, true })
    items.antiaim.defensive[cond].enabled.ticks:depend({ items.antiaim.defensive[cond].enabled.delay, "Static" },{ items.antiaim.defensive[cond].enabled, true })
    items.antiaim.defensive[cond].enabled.minticks:depend({ items.antiaim.defensive[cond].enabled.delay, "Random", "Fluctuate" },{ items.antiaim.defensive[cond].enabled, true })
    items.antiaim.defensive[cond].enabled.maxticks:depend({ items.antiaim.defensive[cond].enabled.delay, "Random", "Fluctuate" },{ items.antiaim.defensive[cond].enabled, true })
    items.antiaim.defensive[cond].enabled.percent:depend({ items.antiaim.defensive[cond].enabled.delay, "Random %" },{ items.antiaim.defensive[cond].enabled, true })

    items.antiaim.defensive[cond].enabled.minticks:set_callback(function()
        if items.antiaim.defensive[cond].enabled.maxticks:get() < items.antiaim.defensive[cond].enabled.minticks:get() then
            items.antiaim.defensive[cond].enabled.maxticks:set(items.antiaim.defensive[cond].enabled.minticks:get())
        end
    end)
    items.antiaim.defensive[cond].enabled.maxticks:set_callback(function()
        if items.antiaim.defensive[cond].enabled.minticks:get() > items.antiaim.defensive[cond].enabled.maxticks:get() then
            items.antiaim.defensive[cond].enabled.minticks:set(items.antiaim.defensive[cond].enabled.maxticks:get())
        end
    end)

    items.antiaim.defensive[cond].pitch:depend({ items.antiaim.defensive[cond].enabled, true })
    items.antiaim.defensive[cond].yaw:depend({ items.antiaim.defensive[cond].enabled, true })
    items.antiaim.defensive[cond].force:depend({ items.antiaim.defensive[cond].enabled, true })

    items.antiaim.defensive[cond].pitch.one:depend({ items.antiaim.defensive[cond].pitch, 1,5 })
    items.antiaim.defensive[cond].pitch.two:depend({ items.antiaim.defensive[cond].pitch, 2,5 })
    items.antiaim.defensive[cond].pitch.three:depend({ items.antiaim.defensive[cond].pitch, 3,5 })
    items.antiaim.defensive[cond].pitch.four:depend({ items.antiaim.defensive[cond].pitch, 4,5 })
    items.antiaim.defensive[cond].pitch.five:depend({ items.antiaim.defensive[cond].pitch, 5 })
    items.antiaim.defensive[cond].pitch.sequence:depend({ items.antiaim.defensive[cond].pitch, 1,5 })
    items.antiaim.defensive[cond].pitch.offset:depend({ items.antiaim.defensive[cond].pitch, 0 })
    items.antiaim.defensive[cond].pitch.area:depend({ items.antiaim.defensive[cond].pitch, 0 })
    items.antiaim.defensive[cond].pitch.movement:depend({ items.antiaim.defensive[cond].pitch, 0 })
    items.antiaim.defensive[cond].pitch.speed:depend({ items.antiaim.defensive[cond].pitch, 0 }, { items.antiaim.defensive[cond].pitch.movement, "Straight", "Back and Forth", "Bebra" })

    items.antiaim.defensive[cond].yaw.one:depend({ items.antiaim.defensive[cond].yaw, 1,7 })
    items.antiaim.defensive[cond].yaw.two:depend({ items.antiaim.defensive[cond].yaw, 2,7 })
    items.antiaim.defensive[cond].yaw.three:depend({ items.antiaim.defensive[cond].yaw, 3,7 })
    items.antiaim.defensive[cond].yaw.four:depend({ items.antiaim.defensive[cond].yaw, 4,7 })
    items.antiaim.defensive[cond].yaw.five:depend({ items.antiaim.defensive[cond].yaw, 5,7 })
    items.antiaim.defensive[cond].yaw.six:depend({ items.antiaim.defensive[cond].yaw, 6,7 })
    items.antiaim.defensive[cond].yaw.seven:depend({ items.antiaim.defensive[cond].yaw, 7 })
    items.antiaim.defensive[cond].yaw.sequence:depend({ items.antiaim.defensive[cond].yaw, 1,7 })
    items.antiaim.defensive[cond].yaw.offset:depend({ items.antiaim.defensive[cond].yaw, 0 })
    items.antiaim.defensive[cond].yaw.area:depend({ items.antiaim.defensive[cond].yaw, 0 })
    items.antiaim.defensive[cond].yaw.movement:depend({ items.antiaim.defensive[cond].yaw, 0 })
    items.antiaim.defensive[cond].yaw.speed:depend({ items.antiaim.defensive[cond].yaw, 0 }, { items.antiaim.defensive[cond].yaw.movement, "Straight", "Back and Forth", "Bebra" })

    -- delay
    items.antiaim.delay[cond].enabled = groups.antiaim.delay[cond]:combo("Delay", {"Disabled", "Static", "Random", "Random %", "Fluctuate"})
    items.antiaim.delay[cond].ticks = groups.antiaim.delay[cond]:slider("Ticks", 0, 24, 0, 1, "t")
    items.antiaim.delay[cond].minticks = groups.antiaim.delay[cond]:slider("Minimum Ticks", 0, 24, 0, 1, "t")
    items.antiaim.delay[cond].maxticks = groups.antiaim.delay[cond]:slider("Maximum Ticks", 0, 24, 6, 1, "t")
    items.antiaim.delay[cond].percent = groups.antiaim.delay[cond]:slider("Switch Chance", 1, 100, 50, 1, "%")

    groups.antiaim.delay[cond]:depend({ items.antiaim.main.condition, cond })
    items.antiaim.delay[cond].ticks:depend({ items.antiaim.delay[cond].enabled, "Static" })
    items.antiaim.delay[cond].minticks:depend({ items.antiaim.delay[cond].enabled, "Random", "Fluctuate" })
    items.antiaim.delay[cond].maxticks:depend({ items.antiaim.delay[cond].enabled, "Random", "Fluctuate" })
    items.antiaim.delay[cond].percent:depend({ items.antiaim.delay[cond].enabled, "Random %" })

    -- set callback for min and max ticks to make sure they dont overlap :/

    items.antiaim.delay[cond].minticks:set_callback(function()
        if items.antiaim.delay[cond].maxticks:get() < items.antiaim.delay[cond].minticks:get() then
            items.antiaim.delay[cond].maxticks:set(items.antiaim.delay[cond].minticks:get())
        end
    end)
    items.antiaim.delay[cond].maxticks:set_callback(function()
        if items.antiaim.delay[cond].minticks:get() > items.antiaim.delay[cond].maxticks:get() then
            items.antiaim.delay[cond].minticks:set(items.antiaim.delay[cond].maxticks:get())
        end
    end)
end

for i = 2, #conditions do -- make everything other than global condition dependant on the enable switch
    local cond = conditions[i]

    items.antiaim.builder[cond].yaw:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.builder[cond].modifier:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.builder[cond].jitter:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.builder[cond].bodyyaw:depend({ items.antiaim.main.enables[cond], true })

    items.antiaim.defensive[cond].enabled:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.defensive[cond].pitch:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.defensive[cond].yaw:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.defensive[cond].force:depend({ items.antiaim.main.enables[cond], true })

    items.antiaim.delay[cond].enabled:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.delay[cond].ticks:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.delay[cond].minticks:depend({ items.antiaim.main.enables[cond], true })
    items.antiaim.delay[cond].maxticks:depend({ items.antiaim.main.enables[cond], true })
end

-- other dependencies

items.visuals.velocity.offset:visibility(false)

items.visuals.crossindicators.clr:depend({ items.visuals.crossindicators.color, "Custom" })

items.antiaim.extra.exploit.timing:depend({ items.antiaim.extra.exploit.mode, "Instant" })

items.antiaim.extra.freestanding.yaw:depend({ items.antiaim.extra.freestanding.edgebait, true })
items.antiaim.extra.freestanding.pitch:depend({ items.antiaim.extra.freestanding.edgebait, true })

items.info.unmatchedlabel:depend({ items.info.presets, "Unmatched" })
items.info.unmatchedbtn:depend({ items.info.presets, "Unmatched" })

items.info.defensivelabel:depend({ items.info.presets, "Defensive" })
items.info.defensivebtn:depend({ items.info.presets, "Defensive" })

items.info.wishenzlabel:depend({ items.info.presets, "Wishenz" })
items.info.wishenzbtn:depend({ items.info.presets, "Wishenz" })

items.visuals.manualarrows.color:depend({ items.visuals.manualarrows.activemode, "Custom" })

items.visuals.customscope.speed:depend({ items.visuals.customscope.animate, true })

-- clantag
items.misc.clantag.tag:depend({ items.misc.clantag.mode, "Custom" })

-- in air hitchance
items.misc.airhc.pistols:depend({ items.misc.airhc.weapons, "Pistols" })
items.misc.airhc.revolver:depend({ items.misc.airhc.weapons, "Revolver" })
items.misc.airhc.ssg08:depend({ items.misc.airhc.weapons, "SSG-08" })
items.misc.airhc.smgs:depend({ items.misc.airhc.weapons, "SMGs" })
items.misc.airhc.zeus:depend({ items.misc.airhc.weapons, "Zeus" })

pui.setup(items)

-- actual functionality now

-- misc functions
local function calculate_distance(vec1, vec2)
    return math.sqrt(
        (vec2.x - vec1.x)^2 +
        (vec2.y - vec1.y)^2 +
        (vec2.z - vec1.z)^2
    )
end
local autohs = false
local autohscount = 0
events.createmove:set(function()
    autohs = false
    if items.misc.autotp:get() == true then
    local lp = entity.get_local_player()
    if not lp then return end
    if not lp:get_player_weapon() then return end
    if lp:get_anim_state().on_ground == true then
        ui.find("Aimbot", "Ragebot", "Main", "Double Tap"):override()
        ui.find("Aimbot", "Ragebot", "Main", "Hide Shots"):override()
        ui.find("Aimbot", "Ragebot", "Main", "Hide Shots", "Options"):override()
        return
    end
    ui.find("Aimbot", "Ragebot", "Main", "Double Tap"):override(false)
    ui.find("Aimbot", "Ragebot", "Main", "Hide Shots"):override(true) -- Idk why but it seems to work better with hide shots.
    ui.find("Aimbot", "Ragebot", "Main", "Hide Shots", "Options"):override("Break LC")
    if entity.get_threat() then
        if calculate_distance(entity.get_local_player():get_origin(), entity.get_threat():get_origin()) < 140 then
            ui.find("Aimbot", "Ragebot", "Main", "Hide Shots"):override(false) -- disable hide shots if close to an enemy with a zeus... zeus wont fire otherwise... idk why... best cheat i guess
        end
    end
    rage.exploit:force_teleport()
    else
        if items.antiaim.extra.exploit:get() == false then
            refs.doubletap:override()
            refs.hideshots:override()
            refs.hsopt:override()
        else
            return
        end
        if items.misc.autohs:get() == true and entity.get_local_player():get_player_weapon():get_weapon_index() ~= 1 then
            if entity.get_local_player() and entity.get_local_player():get_anim_state().velocity_length_xy < 4 then
                if autohscount > 8 then
                    if refs.doubletap:get() == true then
                        autohs = true
                        refs.doubletap:override(false)
                        refs.hideshots:override(true)
                        refs.hsopt:override("Break LC") -- feels a lot smoother so :/
                    end
                else
                    autohscount = autohscount + 1
                end
            else
                refs.doubletap:override()
                refs.hideshots:override()
                refs.hsopt:override()
                autohscount = 0
            end
        else
            refs.doubletap:override()
            refs.hideshots:override()
            refs.hsopt:override()
            autohscount = 0
        end
    end
end)

local function fastladder(cmd)
    lp = entity.get_local_player()
    if not lp then return end

    if lp.m_MoveType == 9 then -- movetype 9 is on ladder

        if cmd.view_angles.x < 15 then -- only trigger if player isnt looking down

            if cmd.sidemove == 0 and cmd.forwardmove > 0 then --going forwards
                cmd.view_angles.x = 89
                cmd.view_angles.y = cmd.view_angles.y - 90
                cmd.in_forward = false
                cmd.in_back = true
                cmd.in_moveleft = true
            end
            if cmd.forwardmove == 0 and cmd.sidemove ~= 0 then --going sideways
                cmd.view_angles.x = 89
                if cmd.sidemove < 0 then -- moving left
                    cmd.in_back = cmd.in_moveleft
                elseif cmd.sidemove > 0 then -- moving right
                    cmd.in_back = cmd.in_moveright
                end
            end
            if cmd.forwardmove > 0 and cmd.sidemove ~= 0 then --going diag
                cmd.view_angles.x = 89
                if cmd.sidemove < 0 then -- moving left
                    cmd.view_angles.y = cmd.view_angles.y - 45
                    cmd.in_forward = false
                    cmd.in_back = true
                elseif cmd.sidemove > 0 then -- moving right
                    cmd.view_angles.y = cmd.view_angles.y + 45
                    cmd.in_forward = false
                    cmd.in_back = true
                end
            end
        end
    end
end

local function airhc()
    if not entity.get_local_player() then return end
    if entity.get_local_player():get_player_weapon() then
        local wp = entity.get_local_player():get_player_weapon():get_weapon_index()

        if items.misc.airhc.weapons:get("Pistols") then
            if (wp == 4 or wp == 2 or wp == 36 or wp == 30 or wp == 1 or wp == 61 or wp == 63 or wp == 32) and (entity.get_local_player():get_anim_state().on_ground == false) then
                refs.pistolshc:override(items.misc.airhc.pistols:get())
            else
                refs.pistolshc:override(refs.pistolshc:get())
            end
        else
            refs.pistolshc:override(refs.pistolshc:get())
        end
        if items.misc.airhc.weapons:get("Revolver") then
            if (wp == 64) and (entity.get_local_player():get_anim_state().on_ground == false) then
                refs.revolverhc:override(items.misc.airhc.revolver:get())
            else
                refs.revolverhc:override(refs.revolverhc:get())
            end
        else
            refs.revolverhc:override(refs.revolverhc:get())
        end
        if items.misc.airhc.weapons:get("SSG-08") then
            if (wp == 40) and (entity.get_local_player():get_anim_state().on_ground == false) then
                refs.ssg08hc:override(items.misc.airhc.ssg08:get())
            else
                refs.ssg08hc:override(refs.ssg08hc:get())
            end
        else
            refs.ssg08hc:override(refs.ssg08hc:get())
        end
        if items.misc.airhc.weapons:get("SMGs") then
            if (wp == 17 or wp == 23 or wp == 33 or wp == 24 or wp == 19 or wp == 26 or wp == 34) and (entity.get_local_player():get_anim_state().on_ground == false) then
                refs.smgshc:override(items.misc.airhc.smgs:get())
            else
                refs.smgshc:override(refs.smgshc:get())
            end
        else
            refs.smgshc:override(refs.smgshc:get())
        end
        if items.misc.airhc.weapons:get("Zeus") then
            if (wp == 31) and (entity.get_local_player():get_anim_state().on_ground == false) then
                refs.zeushc:override(items.misc.airhc.zeus:get())
            else
                refs.zeushc:override(refs.zeushc:get())
            end
        else
            refs.zeushc:override(refs.zeushc:get())
        end
    end
end

local function animbreaker()
    if not entity.get_local_player() then return end

    if items.antiaim.extra.breaker:get() == "Static Slide" then
        entity.get_local_player().m_flPoseParameter[0] = 1
        ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override("Sliding")
    elseif items.antiaim.extra.breaker:get() == "Jitter Slide" then
        local jitter = math.random(1,2)
        entity.get_local_player().m_flPoseParameter[0] = jitter / 2
        ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override("Sliding")
    elseif items.antiaim.extra.breaker:get() == "Disabled" then

    end
end

local function mute()
    entity.get_players(false, true, function(plr)
        steamid = plr:get_player_info().steamid64
        if items.misc.automute:get() == "Mute All" then
            if not panorama.FriendsListAPI.IsSelectedPlayerMuted(steamid) then
                panorama.FriendsListAPI.ToggleMute(steamid)
            end
        elseif items.misc.automute:get() == "Unmute All" then
            if panorama.FriendsListAPI.IsSelectedPlayerMuted(steamid) then
                panorama.FriendsListAPI.ToggleMute(steamid)
            end
        end
    end)
end

local function jumpscout()
    if entity.get_local_player() and entity.get_local_player():is_alive() then
        if entity.get_local_player():get_anim_state().velocity_length_xy < 15 then
            refs.airstrafe:override(false)
        else
            refs.airstrafe:override(refs.airstrafe:get())
        end
    else
        refs.airstrafe:override(refs.airstrafe:get())
    end
end

local function grenaderadius()
    local mollies = entity.get_entities("CInferno")
    local smokes = entity.get_entities("CSmokeGrenadeProjectile")

    if mollies then
        for i = 1, #mollies do
            local mollypos = mollies[i].m_vecOrigin
            render.circle_3d(mollypos, color(255,100,100), 150, 58, 1)
        end
    end
    if smokes then
        for i = 1, #smokes do
            if smokes[i].m_bDidSmokeEffect then
                local smokepos = smokes[i].m_vecOrigin
                render.circle_3d(smokepos, color(100,100,255), 150, 58, 1)
            end
        end
    end
end

local crossclr = {
    DT = color(255),
    HS = color(255),
    FS = color(255),
    BA = color(255),
}

ffi.cdef[[
    typedef int BOOL;
    typedef const char* LPCSTR;

    BOOL DeleteUrlCacheEntryA(LPCSTR lpszUrlName);
]]
local urlmon = ffi.load('urlmon')
local wininet = ffi.load('Wininet')

urlmon.URLDownloadToFileA(nil, 'https://github.com/MattRBX/bebrastuff/raw/refs/heads/main/Inter.ttf', 'C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Global Offensive\\Inter.ttf', 0, 0)
wininet.DeleteUrlCacheEntryA("https://github.com/MattRBX/bebrastuff/raw/refs/heads/main/Inter.ttf")

local inter = render.load_font('C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Global Offensive\\Inter.ttf', 11, "a")
local txtshadow = render.load_image(network.get("https://i.imgur.com/OOeRHq7.png"))

local bingchilling = 0

local crossmylegs = { "DT","HS","FS","BA" }

local crossoffset = 0
local indoffset = { 0,0,0,0, }

local realclip = 0

local function crossindicators()
    if loading.done == false then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if lp:is_alive() == false then return end
    if not condition then return end
    if common.is_button_down(0x09) then return end

    local n, c = items.visuals.crossindicators.clr:get()

    local textclr = {color(255), color(0)}
    if items.visuals.crossindicators.color:get() == "Accent Color" then
        textclr = {items.info.accentcolor:get(), items.info.accentcolor:get()*1.5}
    else
        if n == "Gradient" then
            textclr = c
        else
            textclr = {c*1.5, c}
        end
    end

    if lp.m_bIsScoped == true then
        local checkvalue = 40
        if items.visuals.customscope:get() == true then
            checkvalue = checkvalue + items.visuals.customscope.thickness:get()
        end

        if bingchilling < checkvalue then
            bingchilling = bingchilling + ease_out(bingchilling, checkvalue, 5)
        elseif bingchilling > checkvalue then
            bingchilling = checkvalue
        end
    else
        if bingchilling < 0 then
            bingchilling = 0
        elseif bingchilling > 0 then
            bingchilling = bingchilling + ease_out(bingchilling, 0, 5)
        end
    end

    local text = gradient.text_animate(
        "bebrasense",
        -1,
        {textclr[1], textclr[1], textclr[2]}
    )

    --drop shadow
    render.texture(
        txtshadow,
        render.screen_size()/2 + vector(-31 + bingchilling, items.visuals.crossindicators.height:get() - 10),
        nil,
        color(0, 128)
    )
    --gradient text
    render.text(
        inter,
        render.screen_size()/2 + vector(0 + bingchilling, items.visuals.crossindicators.height:get()),
        color(255),
        "c",
        text:get_animated_text()
    )
    text:animate()

    local elemoffset = 25
    local clip = render.measure_text(2,nil,condition)

    if realclip < clip.x then
        realclip = realclip + animft(0.5)
    end
    if realclip > clip.x then
        realclip = clip.x
    end

    if items.visuals.crossindicators.simple:get() == false then
        
        render.rect(
            render.screen_size()/2 + vector(-16 + bingchilling, items.visuals.crossindicators.height:get() + 6),
            render.screen_size()/2 + vector(16 + bingchilling, items.visuals.crossindicators.height:get() + 9),
            color(0, 128)
        )
        --bar
        render.gradient(
            render.screen_size()/2 + vector(-15 + bingchilling, items.visuals.crossindicators.height:get() + 7),
            render.screen_size()/2 + vector(-15 + bingchilling + rage.antiaim:get_max_desync()/2, items.visuals.crossindicators.height:get() + 8),
            textclr[1], textclr[2],
            textclr[1], textclr[2]
        )

        render.push_clip_rect(
            render.screen_size()/2 + vector((-realclip/2)*1.1 - 3 + bingchilling, items.visuals.crossindicators.height:get() + 15 - 10),
            render.screen_size()/2 + vector((realclip/2)*1.1 + 3 + bingchilling, items.visuals.crossindicators.height:get() + 15 + 10),
            true
        )
        render.text(
            2,
            render.screen_size()/2 + vector(0 + bingchilling, items.visuals.crossindicators.height:get() + 15),
            color(255,128),
            "c",
            string.upper(condition)
        )
        render.pop_clip_rect()
    else
        elemoffset = 10
    end

    local elements = {}
    elements[1] = refs.doubletap:get() == true or false
    elements[2] = refs.hideshots:get() == true or false
    elements[3] = items.antiaim.extra.freestanding:get() == true or false
    elements[4] = ui.find("Aimbot", "Ragebot", "Safety", "Body Aim"):get() == "Force" or false

    local num = 0
    local trueoffset = 0
    local trueindoffset = { 0,0,0,0 }
    if elements[3] == true then
        crossclr.FS = crossclr.FS + animft(0.1) -- why this low of a value? tf?
    end
    if elements[4] == true then
        crossclr.BA = crossclr.BA + animft(0.1)
    end
    if elements[1] == true then
        crossclr.DT = crossclr.DT + animft(0.1)
        if rage.exploit:get() < 1 then
            crossclr.DT.g = 128
            crossclr.DT.b = 128
        end
    end
    if elements[2] == true then
        crossclr.HS = crossclr.HS + animft(0.1)
        if rage.exploit:get() < 1 then
            crossclr.HS.g = 128
            crossclr.HS.b = 128
        end
        if elements[1] == true then
            crossclr.HS.r = 150
            crossclr.HS.g = 150
            crossclr.HS.b = 150
        end
    end
    if autohs == true and elements[1] == true then
        elements[2] = true
        crossclr.HS = crossclr.HS + animft(0.1)
        crossclr.DT.r = 170
        crossclr.DT.g = 170
        crossclr.DT.b = 100
        crossclr.HS.r = 255
        crossclr.HS.g = 255
        crossclr.HS.b = 255
    end

    for i = 1, #elements do
        if elements[i] == true then
            trueindoffset[i] = (num * 12)
            num = num + 1
            render.text(
                2,
                render.screen_size()/2 + vector(-crossoffset + indoffset[i] + bingchilling, items.visuals.crossindicators.height:get() + elemoffset),
                crossclr[crossmylegs[i]],
                "c",
                crossmylegs[i]
            )
        end
    end
    num = num - 1
    if num == -1 then num = 0 end
    trueoffset = num * 6
    if crossoffset < trueoffset then
        crossoffset = crossoffset + animft(1)
        if crossoffset > trueoffset then crossoffset = trueoffset end
    elseif crossoffset > trueoffset then
        crossoffset = crossoffset - animft(1)
        if crossoffset < trueoffset then crossoffset = trueoffset end
    end
    for i = 1, #elements do
        if elements[i] == false then
            indoffset[i] = num*12
            crossclr[crossmylegs[i]] = color(255,0)
        else
            if indoffset[i] < trueindoffset[i] then
                indoffset[i] = indoffset[i] + animft(2)
                if indoffset[i] > trueindoffset[i] then indoffset[i] = trueindoffset[i] end
            elseif indoffset[i] > trueindoffset[i] then
                indoffset[i] = indoffset[i] - animft(2)
                if indoffset[i] < trueindoffset[i] then indoffset[i] = trueindoffset[i] end
            end
        end
    end
end

dmgdisplay = 1
dmgclr = color(255)
local function dmgindicator()
    local ofst = items.visuals.dmgindicator.offset
    if loading.done == false then return end
    local screen2 = render.screen_size()/2
    local mindmg = ui.find("Aimbot", "Ragebot", "Selection", "Min. Damage"):get()
    if items.visuals.dmgindicator.animated:get() == true then
        if dmgdisplay == "A" then dmgdisplay = 0 end
        dmgdisplay = dmgdisplay + ease_out(dmgdisplay, mindmg, 2)
        if dmgdisplay ~= mindmg then
            dmgclr = color(255, 195)
        else
            dmgclr = color(255)
        end
        dmgdisplaybs = dmgdisplay
        if dmgdisplay == 0 then
            dmgdisplaybs = "A"
        else
            dmgdisplaybs = math.floor(dmgdisplaybs)
        end
        if not entity.get_local_player() then return end
        if entity.get_local_player():is_alive() == nil or entity.get_local_player():is_alive() == false then return end
        if common.is_button_down(0x09) then return end
        render.text(1, screen2 + vector(ofst:get(),-ofst:get() - 10), dmgclr, nil, dmgdisplaybs)
    else
        dmgdisplay = mindmg
        if dmgdisplay == 0 then dmgdisplay = "A" end
        if not entity.get_local_player() then return end
        if not entity.get_local_player():is_alive() then return end
        if common.is_button_down(0x09) then return end
        if dmgdisplay ~= "A" then dmgdisplay = math.floor(dmgdisplay) end
        render.text(1, screen2 + vector(ofst:get(),-ofst:get() - 10), color(255), nil, dmgdisplay)
    end
end

local leftarrow = render.load_image(network.get("https://i.imgur.com/LllqghH.png"))
local rightarrow = render.load_image(network.get("https://i.imgur.com/W0Wrjj8.png"))
local function manualarrows()
    if loading.done == false then return end
    if not entity.get_local_player() then return end
    if common.is_button_down(0x09) then return end
    local leftcolor = color(0,100)
    local rightcolor = color(0,100)
    local scopedshitfuckniggersoffset = 0
    if entity.get_local_player().m_bIsScoped then
        scopedshitfuckniggersoffset = -items.visuals.manualarrows.size:get() + 5
    end
    if items.visuals.manualarrows.invis:get() == true then
        leftcolor = color(0,0)
        rightcolor = color(0,0)
    end
    local screen2 = render.screen_size()/2

    if items.antiaim.extra.manual:get() == "Left" then
        if items.visuals.manualarrows.activemode:get() == "Accent Color" then
            leftcolor = items.info.accentcolor:get()
        else
            leftcolor = items.visuals.manualarrows.color:get()
        end
    elseif items.antiaim.extra.manual:get() == "Right" then
        if items.visuals.manualarrows.activemode:get() == "Accent Color" then
            rightcolor = items.info.accentcolor:get()
        else
            rightcolor = items.visuals.manualarrows.color:get()
        end
    elseif items.antiaim.extra.manual:get() == "Forward" then
        if items.visuals.manualarrows.activemode:get() == "Accent Color" then
            leftcolor = items.info.accentcolor:get()
            rightcolor = items.info.accentcolor:get()
        else
            leftcolor = items.visuals.manualarrows.color:get()
            rightcolor = items.visuals.manualarrows.color:get()
        end
    end

    --left
    render.texture(
        leftarrow,
        screen2 + vector(-items.visuals.manualarrows.offset:get() - items.visuals.manualarrows.size:get()/2, -items.visuals.manualarrows.size:get()/2 + scopedshitfuckniggersoffset),
        vector(items.visuals.manualarrows.size:get()),
        leftcolor
    )
    --right
    render.texture(
        rightarrow,
        screen2 + vector(items.visuals.manualarrows.offset:get() - items.visuals.manualarrows.size:get()/2, -items.visuals.manualarrows.size:get()/2 + scopedshitfuckniggersoffset),
        vector(items.visuals.manualarrows.size:get()),
        rightcolor
    )
end

local function is_odd(number)
    return number % 2 ~= 0
end

currentscope = 0
local function customscope()
    if loading.done == false then return end
    if not entity.get_local_player() then return end
    if not entity.get_local_player():is_alive() then return end
    if common.is_button_down(0x09) then return end
    ui.find("Visuals", "World", "Main", "Override Zoom", "Scope Overlay"):override("Remove All")
    local screen2 = render.screen_size()/2
    local length = items.visuals.customscope.length:get()
    local thickness = items.visuals.customscope.thickness:get()
    local offset = items.visuals.customscope.offset:get()
    local scopeclr = items.visuals.customscope.color:get()
    local transclr = color(scopeclr.r, scopeclr.g, scopeclr.b, 0)
    local add = 0
    if is_odd(thickness) then
        add = 1
    end

    if items.visuals.customscope.animate:get() == true then
        if entity.get_local_player().m_bIsScoped then
            if currentscope < items.visuals.customscope.length:get() then currentscope = currentscope + animft(items.visuals.customscope.speed:get()) end
            if currentscope > items.visuals.customscope.length:get() then currentscope = items.visuals.customscope.length:get() end
        else
            if currentscope > 0 then currentscope = currentscope - animft(items.visuals.customscope.speed:get()) end
            if currentscope < 0 then currentscope = 0 end
        end
    else
        if entity.get_local_player().m_bIsScoped then
            currentscope = items.visuals.customscope.length:get()
        else
            currentscope = 0
        end
    end

    if items.visuals.customscope.invert:get() == true then
        transclr = items.visuals.customscope.color:get()
        scopeclr = color(scopeclr.r, scopeclr.g, scopeclr.b, 0)
    end

    if items.visuals.customscope.exclude:get("Top") == false then
        render.gradient(
            screen2 + vector(thickness/2 + add, -offset),
            screen2 + vector(-thickness/2 + add, -offset - currentscope),
            scopeclr, scopeclr,
            transclr, transclr,
            0
        )
    end
    if items.visuals.customscope.exclude:get("Bottom") == false then
        render.gradient(
            screen2 + vector(-thickness/2 + add, offset),
            screen2 + vector(thickness/2 + add, offset + currentscope),
            scopeclr, scopeclr,
            transclr, transclr,
            0
        )
    end
    if items.visuals.customscope.exclude:get("Left") == false then
        render.gradient(
            screen2 + vector(-offset, thickness/2 + add),
            screen2 + vector(-offset - currentscope, -thickness/2 + add),
            scopeclr, transclr,
            scopeclr, transclr,
            0
        )
    end
    if items.visuals.customscope.exclude:get("Right") == false then
        render.gradient(
            screen2 + vector(offset, -thickness/2 + add),
            screen2 + vector(offset + currentscope, thickness/2 + add),
            scopeclr, transclr,
            scopeclr, transclr,
            0
        )
    end
end

velotrans = 0
velomodifier = 1

events.createmove(function()
    if not items.visuals.velocity:get() == true then return end
    local lp = entity.get_local_player()
    if not lp then velomodifier = 1; return end
    if not lp:is_alive() then velomodifier = 1; return end
    velomodifier = lp.m_flVelocityModifier -- just running this under createmove in an attempt to optimize
end)

local velo_trans = 0
local velo_dragtrans = 0
local velo_dragging = false
local velo_font = render.load_font("bahnschrift", 10, "ab")

local function velocitywarn()
    if loading.done == false then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if not lp:is_alive() then return end
    local pos = items.visuals.velocity.offset:get()
    local ss2 = render.screen_size()/2
    local acc = items.info.accentcolor:get()
    local mousepos = ui.get_mouse_position()

    velo_dragtrans = ui.get_alpha() * 255

    if velomodifier < 1 or ui.get_alpha() > 0 then
        velo_trans = velo_trans + ease_out(velo_trans, 255, 3)
    else
        velo_trans = velo_trans + ease_out(velo_trans, 0, 3)
    end

    if ui.get_alpha() > 0.5 then
        if common.is_button_down(0x01) then
            if mousepos.x > ss2.x - 54 and mousepos.x < ss2.x + 54 and
               mousepos.y > pos - 24 and mousepos.y < pos + 24 then

                velo_isdragging = true

            end
        end
        if common.is_button_released(0x01) then
            velo_isdragging = false
        end
    else
        velo_isdragging = false
    end

    if velo_isdragging == true then
        items.visuals.velocity.offset:set(mousepos.y - drag_offset)
    else
        drag_offset = mousepos.y - pos
    end

    local drgclr = 128

    if velo_dragtrans > 0 then
        if velo_isdragging == true then
            render.line(
                vector(ss2.x, 0),
                vector(ss2.x, ss2.y*2),
                color(255,128)
            )
            drgclr = 255
        end
        render.rect_outline(
            vector(ss2.x - 54, -24 + pos),
            vector(ss2.x + 54, 24 + pos),
            color(255, drgclr),
            1,
            4
        )
    end

    if velo_trans > 0 then
        --actual shit
        render.blur(
            vector(ss2.x - 50, -20 + pos),
            vector(ss2.x + 50, 20 + pos),
            velo_trans/255,
            velo_trans/255,
            4
        )
        render.rect(
            vector(ss2.x - 50, -20 + pos),
            vector(ss2.x + 50, 20 + pos),
            color(0,velo_trans/2),
            4
        )
        render.push_clip_rect(
            vector(ss2.x - 40, -20 + pos),
            vector(ss2.x + 40, 20 + pos),
            true
        )
        render.rect_outline(
            vector(ss2.x - 50, -20 + pos),
            vector(ss2.x + 50, 20 + pos),
            color( acc.r,acc.g,acc.b, velo_trans ),
            1,
            4
        )
        render.pop_clip_rect()
        render.text(
            velo_font,
            vector(ss2.x, pos - 8),
            color(255, velo_trans),
            "c",
            "SLOWED"
        )
        render.rect(
            vector(ss2.x - 40, 4 + pos),
            vector(ss2.x + 40, 8 + pos),
            color(0,0,0,velo_trans*0.7),
            2
        )
        render.rect(
            vector(ss2.x - 40, 4 + pos),
            vector(ss2.x - 40 + velomodifier * 80, 8 + pos),
            color( acc.r,acc.g,acc.b, velo_trans ),
            2
        )
        if velomodifier < 1 then
            render.text(
                2,
                vector(ss2.x - 40 + velomodifier * 80, pos + 5),
                color(255,velomodifier*255,velomodifier*255, velo_trans),
                "c",
                math.floor(velomodifier*100)
            )
        end
    end
end

events.render(function()
    if ui.get_alpha() > 0.5 then
        utils.console_exec("unbind mouse1") -- Yes, jank solution. I know. stfu.
    else
        utils.console_exec("bind mouse1 +attack")
    end
end)

-- misc callbacks and triggers

-- velocity warning

events.render(function()
    if items.visuals.velocity:get() == true then
        velocitywarn()
    end
end)

-- baim if lethal

events.createmove(function()
    local hitboxes = ui.find("Aimbot", "Ragebot", "Selection", "SSG-08", "Hitboxes")
    local baim = ui.find("Aimbot", "Ragebot", "Safety", "SSG-08", "Body Aim")
    hitboxes:override(hitboxes:get())
    baim:override(baim:get())
    if items.misc.forcebaim:get() == false then return end
    local enemy = entity.get_threat()
    if not enemy or enemy:is_alive() == false or enemy:is_dormant() == true then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local weap = lp:get_player_weapon()
    if not weap then return end
    if not weap:get_weapon_index() == 40 then return end -- force only on scout

    local noheadbox = hitboxes:get()
    if noheadbox[1] == "Head" then table.remove(noheadbox, 1) end

    if enemy.m_iHealth <= items.misc.forcebaim.hp:get() then
        hitboxes:override(noheadbox)
        baim:override("Force")
    end
end)

-- predictive revolver ideal tick

drawpos = vector(0,0,0)
canshootr8 = false

local r8dmg = {}

events.createmove(function(cmd)
    view_angles = cmd.view_angles.y
    ui.find("Aimbot", "Ragebot", "Main", "Enabled"):override(ui.find("Aimbot", "Ragebot", "Main", "Enabled"):get())
    if not items.misc.revolver:get() == true then return end
    if not ui.find("Aimbot", "Ragebot", "Main", "Peek Assist"):get() == true then return end
    if entity.get_local_player():get_player_weapon():get_weapon_index() ~= 64 then return end

    if canshootr8 == false then
        ui.find("Aimbot", "Ragebot", "Main", "Enabled"):override(false)
    end

    local sim = entity.get_local_player():simulate_movement(
        entity.get_local_player():get_origin(),
        entity.get_local_player():get_anim_state().velocity
    )
    sim:think(15)
    drawpos = sim.origin

    if not entity.get_threat() then return end

    -- hitbox trace
    for i = 0, 10 do
        r8dmg[i] = utils.trace_bullet(
            entity.get_local_player(),
            drawpos + vector(0,0,64),
            entity.get_threat():get_hitbox_position(i)
        )
    end
    -- general trace for dormant enemies
    local generaltrace = utils.trace_line(
        drawpos + vector(0,0,64),
        entity.get_threat():get_origin() + vector(0,0,32),
        {entity.get_threat(), entity.get_local_player()}
    )
    canshootr8 = false
    if entity.get_threat():is_dormant() then
        if generaltrace.fraction >= 0.99 then
            canshootr8 = true
        end
    else
        for i = 0, #r8dmg do
            local mindamage = refs.mindmg:get()
            if mindamage > entity.get_threat().m_iHealth then mindamage = entity.get_threat().m_iHealth + 1 end
            if r8dmg[i] >= mindamage then
                canshootr8 = true
            end
        end
    end
end)
events.render(function()
    if not items.misc.revolver:get() == true then return end
    if not ui.find("Aimbot", "Ragebot", "Main", "Peek Assist"):get() == true then return end
    if not items.misc.revolver.guides:get() == true then return end
    if not entity.get_local_player() then return end
    if not entity.get_local_player():get_player_weapon() then return end
    if entity.get_local_player():get_player_weapon():get_weapon_index() ~= 64 then return end

    render.circle_3d_outline(
        entity.get_local_player():get_origin(),
        color(255, 128),
        40,
        view_angles + (90 - 18),0.1,3
    )
    render.circle_3d_outline(
        entity.get_local_player():get_origin(),
        color(255, 128),
        40,
        view_angles - (90 + 18),0.1,3
    )

    if rage.exploit:get() > 0 and rage.exploit:get() < 1 then return end
    render.circle_outline(
        drawpos:to_screen(),
        items.info.accentcolor:get(),
        20,
        0,1,4
    )
end)

--faster ideal tick

events.aim_fire(function()
    local lp = entity.get_local_player()
    local weap = lp:get_player_weapon():get_weapon_index()
    local peekassist = ui.find("Aimbot", "Ragebot", "Main", "Peek Assist")
    if items.misc.idealtick:get() == true and peekassist:get() == true and refs.doubletap:get() == true and (weap == 40 or weap == 9 or weap == 1 or weap == 64) then
        if weap == 40 and items.misc.idealtick.weapons:get("SSG-08") == false then return end
        if weap == 9 and items.misc.idealtick.weapons:get("AWP") == false then return end
        if weap == 1 and items.misc.idealtick.weapons:get("Desert Eagle") == false then return end
        if weap == 64 and items.misc.idealtick.weapons:get("R8 Revolver") == false then return end
        utils.console_exec("use weapon_knife")
        rage.exploit:force_teleport() --seems to make it feel less jank? idk ill keep it here even if its pointless
        utils.execute_after(1.0, function()
            if weap == 40 or weap == 9 then
                utils.console_exec("+attack2")
            end
        end)
        utils.execute_after(1.4, function()
            if weap == 40 or weap == 9 then
                utils.console_exec("-attack2")
            end
        end)
        utils.execute_after(items.misc.idealtick.time:get()/1000, function()
            if weap == 40 then
                utils.console_exec("use weapon_ssg08")
            elseif weap == 9 then
                utils.console_exec("use weapon_awp")
            elseif weap == 1 then
                utils.console_exec("use weapon_deagle")
            elseif weap == 64 then
                utils.console_exec("use weapon_deagle")
            end
        end)
    end
end)

--trashtalk

events.player_death(function(asd)
    if not items.misc.trashtalk:get() == true then return end
    local died = entity.get(asd.userid, true):get_name()
    local attacker = entity.get(asd.attacker, true):get_name()
    local trashtalk = {
        "1",
        "nice antiaim retard XDD",
        "sudo kill "..died,
        "just your neighborhood trash collector at work",
        "damn you got fucked hard... reminds me of your mom",
        "roboticus maximus",
        "oyasuminasai "..died,
        "imagine dying... lil bro forgot to buy bebrasense",
        "*DEAD*",
        "eat ass, smoke grass, kill "..died.." fast",
        "roses are red, my hearts on fire. sit on my face, that's my one desire.",
        "roses are red, violets are blue. my booty stank, how about you?",
        attacker.." > "..died,
        "funny story. yesterday i ate your mom instead of my cereal.",
        "what? you died? impossible!",
        "can't stop abusing bebrasense! ＼(٥⁀▽⁀ )／",
        "zzz... brodie getting me sleepy",
        "nothing lasts forevers... especially not you lol",
        "oops.. didn't see you there (¬‿¬ )",
        "huh? what happened to "..died,
        "your antiaim been solved like an algebra equation",
        "clapped by bebrasense kekw xdd",
        "imagine using pasted luas "..died,
        "yall only hate bebrasense cuz u don't stand a chance against it lol",
        "aww you gonna cry?",
        "𝘽𝙀𝘽𝙍𝘼𝙎𝙀𝙉𝙎𝙀 > 𝘼𝙇𝙇",
        "dying to bebrasense is 𝗻𝗲𝗳𝗮𝗿𝗶𝗼𝘂𝘀 work.",
        "lil kid getting so heated his house on fire.",
        "uff, let's get some bandages on them wounds.",
        "hold my pocket will ya?",
        "yo bitchass built like an fl studio carrot",
        "kneel for bebrasense",
        "lick my asshole "..died,
        "God Bless Bebrasense [◣_◢]",
        "RAPED BY BEBRASENSE FAG $$$"
    }
    if died == attacker or attacker ~= entity.get_local_player():get_name() then return end
    local usett = math.random(1,#trashtalk)
    local msg = trashtalk[usett]
    if prevmsg and prevmsg == msg then --avoid sending the same message twice
        usett = usett + 1
        if usett > #trashtalk then usett = usett - 2 end
        msg = trashtalk[usett]
    end
    local prevmsg = msg
    utils.execute_after(math.random(15,30)/10, function() utils.console_exec("say " .. msg) end)
end)



events.post_update_clientside_animation(function()
    if items.antiaim.extra.breaker:get() == false then ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override(ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):get()); return end

    local groundbreak = items.antiaim.extra.breaker.ground:get()
    local airbreak = items.antiaim.extra.breaker.air:get()

    local animlayer = ffi.cast("AnimationLayer**", ffi.cast("char*", ffi.cast("void***", entity.get_local_player()[0])) + 0x2990)[0]

    if entity.get_local_player():get_anim_state().on_ground == false then
        if airbreak == "Walking" then
            animlayer[6].weight = 1
        elseif airbreak == "Static Legs" then
            entity.get_local_player().m_flPoseParameter[6] = 1
        end
    else
        if groundbreak == "Static Slide" then
            entity.get_local_player().m_flPoseParameter[0] = 1
            ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override("Sliding")
        elseif groundbreak == "Moonwalk" then
            entity.get_local_player().m_flPoseParameter[7] = 0
            ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override("Walking")
        else
            ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):override(ui.find("Aimbot", "Anti Aim", "Misc", "Leg Movement"):get())
        end
    end
end)

events.render(function()
    if items.visuals.dmgindicator:get() == true then
        dmgindicator()
    end
    if items.visuals.crossindicators:get() == true then
        crossindicators()
    end
    if items.visuals.customscope:get() == true then
        customscope()
    else
        ui.find("Visuals", "World", "Main", "Override Zoom", "Scope Overlay"):override(ui.find("Visuals", "World", "Main", "Override Zoom", "Scope Overlay"):get())
    end
    if items.visuals.manualarrows:get() == true then
        manualarrows()
    end
    if items.visuals.grenaderadius:get() == true then
        grenaderadius()
    end
end)

items.visuals.viewmodel:set_callback(function(a)
    if a:get() == true then
        cvar.viewmodel_fov:float(items.visuals.viewmodel.fov:get(), true)
        cvar.viewmodel_offset_x:float(items.visuals.viewmodel.x:get()/10, true)
        cvar.viewmodel_offset_y:float(items.visuals.viewmodel.y:get()/10, true)
        cvar.viewmodel_offset_z:float(items.visuals.viewmodel.z:get()/10, true)
    else
        utils.console_exec("viewmodel_presetpos 1")
    end
end)
if items.visuals.viewmodel:get() == true then
    cvar.viewmodel_fov:float(items.visuals.viewmodel.fov:get(), true)
    cvar.viewmodel_offset_x:float(items.visuals.viewmodel.x:get()/10, true)
    cvar.viewmodel_offset_y:float(items.visuals.viewmodel.y:get()/10, true)
    cvar.viewmodel_offset_z:float(items.visuals.viewmodel.z:get()/10, true)
end
dumbcounter = 0
events.createmove(function()
    if items.visuals.viewmodel:get() == false then return end
    if dumbcounter >= 64 then
        dumbcounter = 0
        cvar.viewmodel_fov:float(items.visuals.viewmodel.fov:get(), true)
        cvar.viewmodel_offset_x:float(items.visuals.viewmodel.x:get()/10, true)
        cvar.viewmodel_offset_y:float(items.visuals.viewmodel.y:get()/10, true)
        cvar.viewmodel_offset_z:float(items.visuals.viewmodel.z:get()/10, true)
    else
        dumbcounter = dumbcounter + 1
    end
end)

items.visuals.viewmodel.fov:set_callback(function()
    if items.visuals.viewmodel:get() == true then
        cvar.viewmodel_fov:float(items.visuals.viewmodel.fov:get(), true)
    end
end)
items.visuals.viewmodel.x:set_callback(function()
    if items.visuals.viewmodel:get() == true then
        cvar.viewmodel_offset_x:float(items.visuals.viewmodel.x:get()/10, true)
    end
end)
items.visuals.viewmodel.y:set_callback(function()
    if items.visuals.viewmodel:get() == true then
        cvar.viewmodel_offset_y:float(items.visuals.viewmodel.y:get()/10, true)
    end
end)
items.visuals.viewmodel.z:set_callback(function()
    if items.visuals.viewmodel:get() == true then
        cvar.viewmodel_offset_z:float(items.visuals.viewmodel.z:get()/10, true)
    end
end)

if items.visuals.aspectratio:get() == true then cvar.r_aspectratio:float(items.visuals.aspectratio.ratio:get()/100, true) end

items.visuals.aspectratio:set_callback(function(a) -- just found out the parameter here is a reference to the menu item... im dumb
    if a:get() == true then
        cvar.r_aspectratio:float(items.visuals.aspectratio.ratio:get()/100, true)
    else
        cvar.r_aspectratio:int(0)
    end
end)

items.visuals.aspectratio.ratio:set_callback(function()
    if items.visuals.aspectratio:get() == true then
        cvar.r_aspectratio:float(items.visuals.aspectratio.ratio:get()/100, true)
    else
        cvar.r_aspectratio:int(0)
    end
end)

events.createmove(function()
    if items.misc.jumpscout:get() == true then
        jumpscout()
    else
        refs.airstrafe:override(refs.airstrafe:get())
    end
end)

items.visuals.aspectratio.caseoh:set_callback(function()
    items.visuals.aspectratio.ratio:set(20)
end)
items.visuals.aspectratio.fivefour:set_callback(function()
    items.visuals.aspectratio.ratio:set(125)
end)
items.visuals.aspectratio.fourthree:set_callback(function()
    items.visuals.aspectratio.ratio:set(133)
end)
items.visuals.aspectratio.sixteenten:set_callback(function()
    items.visuals.aspectratio.ratio:set(160)
end)
items.visuals.aspectratio.sixteennine:set_callback(function()
    items.visuals.aspectratio.ratio:set(178)
end)


events.createmove(function()
    if items.misc.airhc:get() == true then
        airhc()
    end
end)


items.misc.airhc:set_callback(function()
    if items.misc.airhc:get() == false then
        refs.pistolshc:set(refs.pistolshc:get())
        refs.smgshc:set(refs.smgshc:get())
        refs.ssg08hc:set(refs.ssg08hc:get())
        refs.revolverhc:set(refs.revolverhc:get())
        refs.zeushc:set(refs.zeushc:get())
    end
end)

items.misc.fakelatency:set_callback(function()
    if items.misc.fakelatency:get() ~= -1 then
        refs.latency:override(items.misc.fakelatency:get())
    else
        refs.latency:set(refs.latency:get())
    end
end)
refs.latency:override(items.misc.fakelatency:get())

items.misc.automute:set_callback(function()
    if items.misc.automute ~= "Disabled" then
        events.createmove:set(mute())
    else
        events.createmove:unset(mute())
    end
end)

items.antiaim.extra.freestanding:set_callback(function()
    if items.antiaim.extra.freestanding:get() == true then
        ui.find("Aimbot", "Anti Aim", "Angles", "Freestanding"):override(true)
    else
        ui.find("Aimbot", "Anti Aim", "Angles", "Freestanding"):override(false)
    end
end)

events.createmove(function(cmd)
    if items.misc.fastladder:get() == true then
        fastladder(cmd)
    end
end)

dropnades = 0
dropped = {false,false,false}
dropequip = false

events.createmove(function(cmd)
    if items.misc.dropnades.hotkey:get() == true then
        dropnades = 1
    end

    if dropnades > 0 then
        if items.misc.dropnades.hotkey:get() == true then return end
        ui.find("Aimbot", "Anti Aim", "Angles", "Enabled"):override(false)
        ui.find("Aimbot", "Anti Aim", "Fake Lag", "Enabled"):override(false)
        if entity.get_local_player():get_player_weapon() then
            dropnades = dropnades + 1
            if cmd.command_number % items.misc.dropnades.speed:get() == 0 then
                if dropequip == false then
                    if items.misc.dropnades.grenade:get() == true and dropped[1] == false then
                        utils.console_exec("use weapon_hegrenade")
                        dropped[1] = true
                    elseif items.misc.dropnades.molotov:get() == true and dropped[2] == false then
                        utils.console_exec("use weapon_molotov")
                        utils.console_exec("use weapon_incgrenade")
                        dropped[2] = true
                    elseif items.misc.dropnades.smoke:get() == true and dropped[3] == false then
                        utils.console_exec("use weapon_smokegrenade")
                        dropped[3] = true
                    end
                    dropequip = true
                else
                    local weap = entity.get_local_player():get_player_weapon():get_weapon_index()
                    if weap == 44 or weap == 45 or weap == 46 or weap == 48 then
                        utils.console_exec("drop")
                    end
                    dropequip = false
                end
                if dropnades >= items.misc.dropnades.speed:get() * 8 then dropnades = 0; dropped[1] = false; dropped[2] = false; dropped[3] = false; dropequip = false;
                    ui.find("Aimbot", "Anti Aim", "Angles", "Enabled"):set(ui.find("Aimbot", "Anti Aim", "Angles", "Enabled"):get())
                    ui.find("Aimbot", "Anti Aim", "Fake Lag", "Enabled"):set(ui.find("Aimbot", "Anti Aim", "Fake Lag", "Enabled"):get())
                end
            end
        end
    end
end)

-- now the anti-aim :))

-- first let's start with some condition handling

local jumpfix = false

events.createmove(function()
    safehead = false
    currentcondition = "Global"
    local lp = entity.get_local_player()
    if not lp then return end

    if lp:get_anim_state().velocity_length_xy > 3 then
        if lp:get_anim_state().anim_duck_amount == 1 then
            currentcondition = "Crouchwalk"
        else
            currentcondition = "Running"
        end
    else
        if lp:get_anim_state().anim_duck_amount == 1 then
            currentcondition = "Crouching"
        else
            currentcondition = "Standing"
        end
    end
    if currentcondition == "Crouchwalk" or currentcondition == "Running" or currentcondition == "Crouching" or currentcondition == "Standing" then
        if jumpfix == true then
            jumpfix = false
            if lp:get_anim_state().anim_duck_amount == 1 then
                currentcondition = "Airduck"
            else
                currentcondition = "In Air"
            end
        end
    end

    if ui.find("Aimbot", "Anti Aim", "Misc", "Slow Walk"):get() == true then
        currentcondition = "Slowwalk"
    end

    if lp:get_anim_state().on_ground == false then -- not necessarily perfect as it jumps to true every time you land while bhopping... but good enough
        if lp:get_anim_state().anim_duck_amount == 1 then
            currentcondition = "Airduck"
        else
            currentcondition = "In Air"
        end
        jumpfix = true
    end
    if not lp:get_player_weapon() then return end
    local plrweapon = lp:get_player_weapon():get_weapon_index()

    if items.antiaim.extra.safehead:get("On Knife") then
        if plrweapon == 42 or plrweapon == 59 then
            safehead = true
        elseif (plrweapon >= 500) and not (plrweapon > 525) then
            safehead = true
        end
    end
    if items.antiaim.extra.safehead:get("On Zeus") == true and plrweapon == 31 then
        safehead = true
    end
end)

-- now we can simply just trigger the anti-aim based on the "currentcondition" variable and whether or not the condition is enabled in the ui :)

-- so next I'm gonna do the function updating the anti-aim.


local currentstep = 1 --current step in anti-aim ways for automation
local backnforth = false

local yawoffset = 0
local inverter = false

flipab = false
local abjitter = false

local function update_aa(cmd)

    -- and then we can get to the anti-aim.
    refs.enable:override(true)
    if dropnades > 0 then refs.enable:override(false) end
    refs.pitch:override("Down")
    refs.yaw:override(items.antiaim.builder[condition].yaw:get())
    refs.yawmodifier:override("Disabled") -- we're not actually gonna use the yaw modifiers for this because we're doing delay too so just disable it
    refs.bodyyaw_options:override("")
    refs.bodyyaw_freestanding:override("Off")
    if items.antiaim.extra.options:get("At Target") then
        ui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Base"):override("At Target")
    else
        ui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Base"):override("Local View")
    end
    if items.antiaim.extra.options:get("Avoid Backstab") then
        ui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Avoid Backstab"):override(true)
    else
        ui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Avoid Backstab"):override(false)
    end

    --yaw

    if items.antiaim.builder[condition].modifier:get() ~= "Offset" and items.antiaim.builder[condition].modifier:get() ~= "Random" and items.antiaim.builder[condition].modifier:get() ~= "Disabled"  then
        local aa_ways = 2
        local calc = -items.antiaim.builder[condition].jitter:get()/2

        if items.antiaim.builder[condition].modifier:get() == "Center" then aa_ways = 2 end
        if items.antiaim.builder[condition].modifier:get() == "Random Center" then aa_ways = 2 end
        if items.antiaim.builder[condition].modifier:get() == "3-Way" then aa_ways = 3 end
        if items.antiaim.builder[condition].modifier:get() == "5-Way" then aa_ways = 5 end

        yawoffset = calc + (items.antiaim.builder[condition].jitter:get() / (aa_ways - 1)) * (currentstep - 1) + items.antiaim.builder[condition].yaw.offset:get() -- automates all the bs

        if items.antiaim.builder[condition].modifier:get() == "Center" then
            currentstep = currentstep + 1
            if currentstep > aa_ways then currentstep = 1 end
        elseif items.antiaim.builder[condition].modifier:get() == "Random Center" then
            currentstep = math.random(1, 2)
        elseif items.antiaim.builder[condition].modifier:get() == "3-Way" or items.antiaim.builder[condition].modifier:get() == "5-Way" then
            if items.antiaim.builder[condition].modifier.sequence:get() == "Straight" then
                currentstep = currentstep + 1
                if currentstep > aa_ways then currentstep = 1 end
            elseif items.antiaim.builder[condition].modifier.sequence:get() == "Back and Forth" then
                if backnforth == false then
                    currentstep = currentstep + 1
                    if currentstep > aa_ways then currentstep = currentstep - 2; backnforth = true end
                else
                    currentstep = currentstep - 1
                    if currentstep < 1 then currentstep = currentstep + 2; backnforth = false end
                end
            elseif items.antiaim.builder[condition].modifier.sequence:get() == "Skitter" then
                prevstep = currentstep
                currentstep = math.random(1, aa_ways)
                if currentstep == prevstep and items.antiaim.builder[condition].modifier.sameside:get() == false then
                    if currentstep + 1 > aa_ways then
                        currentstep = currentstep - math.random(1, 2)
                    else
                        currentstep = currentstep + math.random(-1, 1)
                        if currentstep < 1 then
                            currentstep = 2
                        end
                    end
                end
            end
        end
    end
    if items.antiaim.builder[condition].modifier:get() == "Random" then
        yawoffset = math.random(-items.antiaim.builder[condition].jitter:get()/2, items.antiaim.builder[condition].jitter:get()/2) + items.antiaim.builder[condition].yaw.offset:get()
    end
    if items.antiaim.builder[condition].modifier:get() == "Offset" then
        aa_ways = 2
        if currentstep == 1 then
            currentstep = currentstep + 1
            yawoffset = items.antiaim.builder[condition].yaw.offset:get()
        else
            currentstep = 1
            yawoffset = items.antiaim.builder[condition].jitter:get()/2 + items.antiaim.builder[condition].yaw.offset:get()
        end
    end
    if items.antiaim.builder[condition].modifier:get() == "Disabled" then
        yawoffset = items.antiaim.builder[condition].yaw.offset:get()
    end

    --manual aa
    if items.antiaim.extra.manual:get() ~= "Default" then
        if items.antiaim.extra.manual:get() == "Forward" then
            yawoffset = 180
        elseif items.antiaim.extra.manual:get() == "Left" then
            yawoffset = -90
        elseif items.antiaim.extra.manual:get() == "Right" then
            yawoffset = 90
        end
    end

    --desync

    if items.antiaim.builder[condition].bodyyaw:get() ~= "Disabled" then
        if items.antiaim.builder[condition].bodyyaw:get() == "Static" then
            inverter = items.antiaim.builder[condition].bodyyaw.inverter:get()
        elseif items.antiaim.builder[condition].bodyyaw:get() == "Jitter" then
            if items.antiaim.builder[condition].bodyyaw.randomize:get() == true then
                inverter = math.random(1,2) == 1
            else
                inverter = not inverter
            end
        elseif items.antiaim.builder[condition].bodyyaw:get() == "Anti-Bruteforce" then
            if items.antiaim.builder[condition].bodyyaw.jitter:get() == true then
                abjitter = not abjitter
                if flipab == false then
                    inverter = abjitter
                else
                    inverter = not abjitter
                end
            else
                inverter = flipab
            end
        end
    end
end

local mathrandroid = 2

local function project_shot_position(eye_position, view_angles, distance) -- for antibrute on desync. dunno if its overengineered lol
    local pitch_rad = math.rad(view_angles.x)
    local yaw_rad = math.rad(view_angles.y)
    local cos_pitch = math.cos(pitch_rad)

    local forward_offset = vector(
        cos_pitch * math.cos(yaw_rad),
        cos_pitch * math.sin(yaw_rad),
        -math.sin(pitch_rad)
    )
    return eye_position + (forward_offset * distance)
end

events.bullet_fire(function(par)
    local enemy = entity.get_threat(true)
    if not enemy then return end
    local lp = entity.get_local_player()
    if not lp then return end

    local pos = project_shot_position(enemy:get_eye_position(), par.angles, calculate_distance(lp:get_eye_position(), enemy:get_eye_position()))
    offset = calculate_distance(pos, lp:get_origin() + vector(0,0,32))

    if offset < 40 then
        flipab = not flipab
    end
end)

events.player_hurt(function(par)
    local plr = entity.get(par.userid, true)
    local atk = entity.get(par.attacker, true)

    local enemy = entity.get_threat(true)
    if enemy then return end
    local lp = entity.get_local_player()
    if not lp then return end

    if plr == lp and plr ~= atk then -- still flips if an enemy backtracks you... i think?
        flipab = not flipab
    end
end)

local yawbnf = false
local pitchbnf = false
local hiddenyaw = 0
local hiddenpitch = 0
local jitter = 1

local defyaw = 1
local defpitch = 1

local spunyaw = false
local spunpitch = false

local allowpct = true
local flucstep = 1
local allowfluc = true
local fluccounter = 1

local allowdefrandom = true
local defdelayval = 2

local allowdeffluc = true
local deffluccounter = 1
local defflucstep = 1

events.createmove(function(cmd)
    -- now im gonna change "currentcondition" based on whether or not certain conditions are enabled or not

    condition = currentcondition

    if condition == "Running" and items.antiaim.main.enables.Running:get() == false then condition = "Standing" end
    if condition == "Slowwalk" and items.antiaim.main.enables.Slowwalk:get() == false then condition = "Standing" end
    if condition == "Standing" and items.antiaim.main.enables.Standing:get() == false then condition = "Global" end
    
    if condition == "Crouchwalk" and items.antiaim.main.enables.Crouchwalk:get() == false then condition = "Crouching" end
    if condition == "Crouching" and items.antiaim.main.enables.Crouching:get() == false then condition = "Global" end
    
    if condition == "Airduck" and items.antiaim.main.enables.Airduck:get() == false then condition = "In Air" end
    if condition == "In Air" and items.antiaim.main.enables["In Air"]:get() == false then condition = "Global" end

    --flick exploit

    if items.antiaim.extra.exploit:get() == true and items.antiaim.extra.fuckdefensive:get() == false then
        ui.find("Aimbot", "Ragebot", "Main", "Double Tap"):override(ui.find("Aimbot", "Ragebot", "Main", "Double Tap"):get())
        ui.find("Aimbot", "Ragebot", "Main", "Hide Shots"):override(ui.find("Aimbot", "Ragebot", "Main", "Hide Shots"):get())
        local dir = -items.antiaim.extra.exploit.degree:get()
        if items.antiaim.extra.exploit.jitter:get() == true then
            jitter = jitter + 1
            if jitter == 1 or jitter == 2 then dir = -dir end
            if jitter == 4 then jitter = 0 end
        end
        if rage.exploit:get() > 0 then
            refs.hidden:override(true)
            rage.antiaim:override_hidden_pitch(items.antiaim.extra.exploit.pitch:get())
            refs.dtopt:override("Always On")
            refs.hsopt:override("Break LC")
            refs.bodyyaw:override(true)
            refs.inverter:override(items.antiaim.extra.exploit.degree:get() > 0)
            refs.inverter:override(not refs.inverter:get_override())
            refs.rightlimit:override(60)
            refs.leftlimit:override(60)
            refs.bodyyaw_options:override("Avoid Overlap")
            refs.yawoffset:override(0)
            rage.antiaim:override_hidden_yaw_offset(dir)
            local timing = items.antiaim.extra.exploit.timing:get()
            if items.antiaim.extra.exploit.randomize:get() == true then
                if timing == 14 then
                    timing = math.random(timing - 2, timing)
                else
                    timing = math.random(timing - 1, timing + 1)
                end
            end
            if items.antiaim.extra.exploit.mode:get() == "Instant" then
                cmd.force_defensive = cmd.command_number % timing == 0
            else
                cmd.force_defensive = cmd.command_number % 16 == 0
            end
        end
        return
    end

    --safe head

    if safehead == true then
        if items.antiaim.extra.warmupaa:get() == true and entity.get_game_rules().m_bWarmupPeriod == true then
        else
        refs.bodyyaw:override(false)
        refs.yawoffset:override(0)
        refs.pitch:override("Down")
        refs.hidden:override(false)
        refs.yaw:override("Backward")
        ui.find("Aimbot", "Anti Aim", "Angles", "Yaw", "Base"):override("At Target")
        return
        end
    end

    --warmup aa

    if items.antiaim.extra.warmupaa:get() == true and entity.get_game_rules().m_bWarmupPeriod == true then
        refs.yawoffset:override(math.random(-180, 180))
        refs.bodyyaw:override(false)
        refs.pitch:override("Disabled")
        refs.hidden:override(false)

        return
    end

    --update delay value.. need this for proper jitter with desync
    local delayval = 2
    if allowfluc == true then
        flucstep = flucstep + 1
        if flucstep > items.antiaim.delay[condition].maxticks:get() + 1 then
            flucstep = items.antiaim.delay[condition].minticks:get() + 1
        end
        allowfluc = false
    end
    flucval = flucstep
    if items.antiaim.delay[condition].enabled:get() == "Static" then
        delayval = items.antiaim.delay[condition].ticks:get() + 1
    elseif items.antiaim.delay[condition].enabled:get() == "Disabled" then
        delayval = 1
    end
    if items.antiaim.builder[condition].bodyyaw:get() ~= "Disabled" then --add 1 to delay if desync is enabled
        delayval = delayval + 1
        flucval = flucval + 1
    end

    --ticking the aa
    if not refs.inverter:get_override() then refs.inverter:override(inverter) end
    if items.antiaim.delay[condition].enabled:get() == "Static" or items.antiaim.delay[condition].enabled:get() == "Disabled" then
        if cmd.command_number % delayval == 0 then
            update_aa()
        end
    elseif items.antiaim.delay[condition].enabled:get() == "Random" then
        if cmd.command_number % mathrandroid == 0 then
            update_aa()
            mathrandroid = math.random(
                items.antiaim.delay[condition].minticks:get() + 1,
                items.antiaim.delay[condition].maxticks:get() + 1
            )
        end
    elseif items.antiaim.delay[condition].enabled:get() == "Random %" then
        if allowpct == true then
            local chance = math.random(0, 100)
            if chance <= items.antiaim.delay[condition].percent:get() then
                update_aa()
            end
        end
    elseif items.antiaim.delay[condition].enabled:get() == "Fluctuate" then
        fluccounter = fluccounter + 1
        if fluccounter > flucval then
            update_aa()
            allowfluc = true
            fluccounter = 1
        end
    end
    allowpct = not allowpct
    if items.antiaim.builder[condition].bodyyaw:get() == "Disabled" then allowpct = true end
    --now apply the aa

    refs.inverter:override(inverter)
    refs.rightlimit:override(items.antiaim.builder[condition].bodyyaw.rightlimit:get())
    refs.leftlimit:override(items.antiaim.builder[condition].bodyyaw.leftlimit:get())

    if items.antiaim.builder[condition].bodyyaw:get() ~= "Disabled" then
        refs.bodyyaw:override(true)
        if rage.antiaim:inverter() == true then
            refs.yawoffset:override(yawoffset + items.antiaim.builder[condition].yaw.addleft:get() + math.random(
                -items.antiaim.builder[condition].yaw.randomize:get()/2,
                items.antiaim.builder[condition].yaw.randomize:get()/2
            ))
        else
            refs.yawoffset:override(yawoffset + items.antiaim.builder[condition].yaw.addright:get() + math.random(
                -items.antiaim.builder[condition].yaw.randomize:get()/2,
                items.antiaim.builder[condition].yaw.randomize:get()/2
            ))
        end
    else
        refs.bodyyaw:override(false)
        refs.yawoffset:override(yawoffset + math.random(
            -items.antiaim.builder[condition].yaw.randomize:get()/2,
            items.antiaim.builder[condition].yaw.randomize:get()/2
        ))
    end
    --defensive

    --edge bait
    if items.antiaim.extra.freestanding:get() == true and items.antiaim.extra.freestanding.edgebait:get() == true and items.antiaim.extra.fuckdefensive:get() == false and rage.antiaim:get_target(true) then
        refs.dtopt:override("Always On")
        refs.hsopt:override("Break LC")
        refs.hidden:override(true)
        rage.antiaim:override_hidden_pitch(items.antiaim.extra.freestanding.pitch:get())
        rage.antiaim:override_hidden_yaw_offset(items.antiaim.extra.freestanding.yaw:get())
        refs.bodyyaw:override(true)
        
        return
    end

    --other
    if items.antiaim.defensive[condition].force:get() == true and items.antiaim.defensive[condition].enabled:get() == true then
        refs.dtopt:override("Always On")
        refs.hsopt:override("Break LC")
    else
        refs.dtopt:override(refs.dtopt:get())
        refs.hsopt:override(refs.hsopt:get())
    end

    if refs.doubletap:get() == true and refs.dtopt:get() ~= "Always On" then
        if refs.dtopt:get_override() and refs.dtopt:get_override() ~= "Always On" then
            refs.hidden:override(false)
            return
        end
    end
    if refs.hideshots:get() == true and refs.hsopt:get() ~= "Break LC" then
        if refs.hsopt:get_override() and refs.hsopt:get_override() ~= "Break LC" then
            refs.hidden:override(false)
            return
        end
    end
    if items.antiaim.extra.fuckdefensive:get() == true then
        refs.hidden:override(false)
        refs.dtopt:override(refs.dtopt:get())
        refs.hsopt:override(refs.hsopt:get())
        return
    end

    --main
    if items.antiaim.defensive[condition].enabled:get() == true and items.antiaim.extra.manual:get() == "Default" and items.antiaim.builder[condition].bodyyaw:get() ~= "Disabled" then
        if rage.antiaim:get_target(true) and items.antiaim.extra.freestanding:get() == true then refs.hidden:override(false); return end

        if allowdeffluc == true then
            defflucstep = defflucstep + 1
            if defflucstep > items.antiaim.defensive[condition].enabled.maxticks:get() + 1 then
                defflucstep = items.antiaim.defensive[condition].enabled.minticks:get() + 1
            end
            allowdeffluc = false
        end

        if items.antiaim.defensive[condition].enabled.delay:get() == "Disabled" then
            defdelayval = 2
        elseif items.antiaim.defensive[condition].enabled.delay:get() == "Static" then
            defdelayval = items.antiaim.defensive[condition].enabled.ticks:get() + 2
        elseif items.antiaim.defensive[condition].enabled.delay:get() == "Random" then
            if allowdefrandom == true then
                allowdefrandom = false
                defdelayval = math.random(
                    items.antiaim.defensive[condition].enabled.minticks:get() + 2,
                    items.antiaim.defensive[condition].enabled.maxticks:get() + 2
                )
            end
        elseif items.antiaim.defensive[condition].enabled.delay:get() == "Random %" then
            local randroid = math.random(0, 100)
            if randroid < items.antiaim.defensive[condition].enabled.percent:get() then
                defdelayval = 2
            else
                defdelayval = math.huge --yes ik janky ass solution but it works xd
            end
        elseif items.antiaim.defensive[condition].enabled.delay:get() == "Fluctuate" then
            defdelayval = 1
            deffluccounter = deffluccounter + 1
            if deffluccounter > defflucstep then
                allowdeffluc = true
                deffluccounter = 1
            end
        end
        if items.antiaim.defensive[condition].enabled.delay:get() ~= "Fluctuate" then allowdeffluc = true end

        refs.hidden:override(true)
        cmd.force_defensive = cmd.command_number % items.antiaim.defensive[condition].enabled.timing:get() == 0
        if cmd.command_number % defdelayval == 0 and allowdeffluc == true then
            allowdeffluc = true
            allowdefrandom = true
            --yaw
            if items.antiaim.defensive[condition].yaw:get() ~= 0 then
                if spunyaw == true then
                    defyaw = math.random(
                        1, items.antiaim.defensive[condition].yaw:get()
                    )
                end
                spunyaw = false
                hiddenyaw = items.antiaim.defensive[condition].yaw[num_text[defyaw]]:get()

                if items.antiaim.defensive[condition].yaw.sequence:get() == "Straight" then
                    defyaw = defyaw + 1
                    if defyaw > items.antiaim.defensive[condition].yaw:get() then defyaw = 1 end
                elseif items.antiaim.defensive[condition].yaw.sequence:get() == "Back and Forth" then
                    if yawbnf == false then
                        defyaw = defyaw + 1
                        if defyaw > items.antiaim.defensive[condition].yaw:get() then defyaw = defyaw - 2; yawbnf = true; if defyaw == 0 then defyaw = 1 end end
                    else
                        defyaw = defyaw - 1
                        if defyaw < 1 then defyaw = defyaw + 2; yawbnf = false; if defyaw > items.antiaim.defensive[condition].yaw:get() then defyaw = items.antiaim.defensive[condition].yaw:get() end end
                    end
                elseif items.antiaim.defensive[condition].yaw.sequence:get() == "Skitter" then
                    defyaw = math.random(1, items.antiaim.defensive[condition].yaw:get()) -- fuck avoid sameside bro im too lazy to do that for defensive :sob:
                end
            else
                if spunyaw == false then
                    defyaw = math.random(
                        -items.antiaim.defensive[condition].yaw.area:get()/2,
                        items.antiaim.defensive[condition].yaw.area:get()/2
                    )
                end
                spunyaw = true
                if items.antiaim.defensive[condition].yaw.movement:get() == "Straight" then
                    defyaw = defyaw + items.antiaim.defensive[condition].yaw.speed:get()
                    if defyaw > items.antiaim.defensive[condition].yaw.area:get()/2 then
                        defyaw = -items.antiaim.defensive[condition].yaw.area:get()/2 + (defyaw - items.antiaim.defensive[condition].yaw.area:get()/2)
                    end
                elseif items.antiaim.defensive[condition].yaw.movement:get() == "Back and Forth" then
                    if yawbnf == false then
                        defyaw = defyaw + items.antiaim.defensive[condition].yaw.speed:get()
                        if defyaw > items.antiaim.defensive[condition].yaw.area:get()/2 then
                            defyaw = items.antiaim.defensive[condition].yaw.area:get()/2
                            yawbnf = true
                        end
                    else
                        defyaw = defyaw - items.antiaim.defensive[condition].yaw.speed:get()
                        if defyaw < -items.antiaim.defensive[condition].yaw.area:get()/2 then
                            defyaw = -items.antiaim.defensive[condition].yaw.area:get()/2
                            yawbnf = false
                        end
                    end
                elseif items.antiaim.defensive[condition].yaw.movement:get() == "Random" then
                    defyaw = math.random(
                        -items.antiaim.defensive[condition].yaw.area:get()/2,
                        items.antiaim.defensive[condition].yaw.area:get()/2
                    )
                elseif items.antiaim.defensive[condition].yaw.movement:get() == "Bebra" then
                    if yawbnf == false then
                        if defyaw < items.antiaim.defensive[condition].yaw.offset:get() then
                            defyaw = items.antiaim.defensive[condition].yaw.offset:get()
                        end
                        defyaw = defyaw + items.antiaim.defensive[condition].yaw.speed:get()
                        if defyaw > items.antiaim.defensive[condition].yaw.area:get()/2 then
                            defyaw = items.antiaim.defensive[condition].yaw.offset:get()
                            yawbnf = true
                        end
                    else
                        if defyaw > items.antiaim.defensive[condition].yaw.offset:get() then
                            defyaw = items.antiaim.defensive[condition].yaw.offset:get()
                        end
                        defyaw = defyaw - items.antiaim.defensive[condition].yaw.speed:get()
                        if defyaw < -items.antiaim.defensive[condition].yaw.area:get()/2 then
                            defyaw = items.antiaim.defensive[condition].yaw.offset:get()
                            yawbnf = false
                        end
                    end
                end
                usegarbage = defyaw + items.antiaim.defensive[condition].yaw.offset:get() -- bruh i have to put it inside a seperate variable why is coding like this
                hiddenyaw = usegarbage
            end

            --pitch
            if items.antiaim.defensive[condition].pitch:get() ~= 0 then
                if spunpitch == true then
                    defpitch = math.random(
                        1, items.antiaim.defensive[condition].pitch:get()
                    )
                end
                spunpitch = false
                hiddenpitch = items.antiaim.defensive[condition].pitch[num_text[defpitch]]:get()

                if items.antiaim.defensive[condition].pitch.sequence:get() == "Straight" then
                    defpitch = defpitch + 1
                    if defpitch > items.antiaim.defensive[condition].pitch:get() then defpitch = 1 end
                elseif items.antiaim.defensive[condition].pitch.sequence:get() == "Back and Forth" then
                    if pitchbnf == false then
                        defpitch = defpitch + 1
                        if defpitch > items.antiaim.defensive[condition].pitch:get() then defpitch = defpitch - 2; pitchbnf = true; if defpitch == 0 then defpitch = 1 end end
                    else
                        defpitch = defpitch - 1
                        if defpitch < 1 then defpitch = defpitch + 2; pitchbnf = false; if defpitch > items.antiaim.defensive[condition].pitch:get() then defpitch = items.antiaim.defensive[condition].pitch:get() end end
                    end
                elseif items.antiaim.defensive[condition].pitch.sequence:get() == "Skitter" then
                    defpitch = math.random(1, items.antiaim.defensive[condition].pitch:get()) -- fuck avoid sameside bro im too lazy to do that for defensive :sob:
                end
            else
                if spunpitch == false then
                    defpitch = math.random(
                        -items.antiaim.defensive[condition].pitch.area:get()/2,
                        items.antiaim.defensive[condition].pitch.area:get()/2
                    )
                end
                spunpitch = true
                if items.antiaim.defensive[condition].pitch.movement:get() == "Straight" then
                    defpitch = defpitch + items.antiaim.defensive[condition].pitch.speed:get()
                    if defpitch > items.antiaim.defensive[condition].pitch.area:get()/2 then
                        defpitch = -items.antiaim.defensive[condition].pitch.area:get()/2 + (defpitch - items.antiaim.defensive[condition].pitch.area:get()/2)
                    end
                elseif items.antiaim.defensive[condition].pitch.movement:get() == "Back and Forth" then
                    if pitchbnf == false then
                        defpitch = defpitch + items.antiaim.defensive[condition].pitch.speed:get()
                        if defpitch > items.antiaim.defensive[condition].pitch.area:get()/2 then
                            defpitch = items.antiaim.defensive[condition].pitch.area:get()/2
                            pitchbnf = true
                        end
                    else
                        defpitch = defpitch - items.antiaim.defensive[condition].pitch.speed:get()
                        if defpitch < -items.antiaim.defensive[condition].pitch.area:get()/2 then
                            defpitch = -items.antiaim.defensive[condition].pitch.area:get()/2
                            pitchbnf = false
                        end
                    end
                elseif items.antiaim.defensive[condition].pitch.movement:get() == "Random" then
                    defpitch = math.random(
                        -items.antiaim.defensive[condition].pitch.area:get()/2,
                        items.antiaim.defensive[condition].pitch.area:get()/2
                    )
                elseif items.antiaim.defensive[condition].pitch.movement:get() == "Bebra" then
                    if pitchbnf == false then
                        if defpitch < items.antiaim.defensive[condition].pitch.offset:get() then
                            defpitch = items.antiaim.defensive[condition].pitch.offset:get()
                        end
                        defpitch = defpitch + items.antiaim.defensive[condition].pitch.speed:get()
                        if defpitch > items.antiaim.defensive[condition].pitch.area:get()/2 then
                            defpitch = items.antiaim.defensive[condition].pitch.offset:get()
                            pitchbnf = true
                        end
                    else
                        if defpitch > items.antiaim.defensive[condition].pitch.offset:get() then
                            defpitch = items.antiaim.defensive[condition].pitch.offset:get()
                        end
                        defpitch = defpitch - items.antiaim.defensive[condition].pitch.speed:get()
                        if defpitch < -items.antiaim.defensive[condition].pitch.area:get()/2 then
                            defpitch = items.antiaim.defensive[condition].pitch.offset:get()
                            pitchbnf = false
                        end
                    end
                end
                usegarbagepitch = defpitch + items.antiaim.defensive[condition].pitch.offset:get() -- bruh i have to put it inside a seperate variable why is coding like this
                hiddenpitch = usegarbagepitch
            end
        end
        if hiddenpitch > 89 then --quick fix to avoid wonk movement :/
            hiddenpitch = 89
        elseif hiddenpitch < -89 then
            hiddenpitch = -89
        end
        usedefyaw = hiddenyaw
        if items.antiaim.defensive[condition].yaw.counteract:get() == true and refs.yawoffset:get_override() then
            usedefyaw = hiddenyaw + refs.yawoffset:get_override()
        end
    else
        refs.hidden:override(false)
    end
    if hiddenpitch and hiddenyaw and usedefyaw then
        rage.antiaim:override_hidden_pitch(hiddenpitch)
        rage.antiaim:override_hidden_yaw_offset(usedefyaw)
    end
end)

-- tooltips

items.info.accentcolor:tooltip("The color universally used for most items that are being rendered.\n\nE.g. crosshair indicators, manual arrows, aimbot logs, etc.")
items.info.presets:tooltip("\vDefensive\r\nFocuses on abusing defensive on all states with slightly more aggressive jitter to make players miss head.\n\n\vUnmatched\r\nGeneral focus on safehead and causing enemies to delay rather than missing.\nThis preset is designed to be used in matches played on unmatched.gg and has no defensive anti-aim.\n\n\vWishenz\r\nA great defensive preset made by wishenz.")
items.configs.loadaa:tooltip("Loads only the Anti-Aim Settings from the Config.")

items.misc.revolver:tooltip("Automatically ticks the revolver as you're peeking an enemy to avoid delaying. This effectively lets you ideal tick consistently using a revolver.\n\nFor optimal performance peek only enemies that aren't dormant and peek with a low minimum damage for an easier shot so nl doesn't delay.\n\nThe feature is only active while using peek assist.")
items.misc.revolver.guides:tooltip("Draws peek guides and prediction indicator.\n\nTry to align the peek guides with the wall you're peeking out from for best results.\n\nThe prediction indicator shows where your predicted position in 15 ticks is. If you can hit an enemy from the predicted position the revolver will tick.")
items.misc.autotp:tooltip("Constantly discharges exploit to break lc.\n\nShould be used on bind.")
items.misc.dropnades:tooltip("Automatically drops selected grenades in quick succession")
items.misc.idealtick:tooltip("Quick-switches to knife after firing for a faster retreat while ideal ticking.\n\nNot recommended to use on Deagle nor Revolver, but the option is there if you need it.")
items.misc.dropnades.speed:tooltip("Values too low may cause issues on servers due to even minor amounts of lag.\n\nFor consistent throws it's recommended to use a value of \v4\r or more")
items.misc.autohs:tooltip("Automatically switches from Double Tap to Hide Shots when you're standing still")

items.antiaim.extra.breaker:tooltip("Applies different animations than usual while on ground / in air\n\nClientside only. Does not affect anti-aim performance.")
items.antiaim.extra.freestanding:tooltip("Same freestanding as neverlose except with defensive edge baiting.\n\nUse this instead of the default freestanding neverlose provides.")
items.antiaim.extra.exploit:tooltip("Special defensive exploit that tends to make people miss more.\n\nShould optimally be used together with slowwalking.")

-- sidebar stuffs

pui.sidebar("B E B R A S E N S E", "\v\f<shield-cat>")
events.render:set(function()
    UIColor = ui.get_style("Link Active")
    local sidebartext = gradient.text_animate("B E B R A S E N S E", -1, {UIColor*1.5, UIColor/2})
    pui.sidebar(sidebartext:get_animated_text())
    sidebartext:animate()
end)

secretdisablewatermark = false

local wmfont = render.load_font("Bahnschrift", 12, "ai")
local kitty = render.load_image(network.get("https://i.imgur.com/IeiVogM.png"))

events.render(function() -- render watermark
    if loading.done == false then return end--
    if secretdisablewatermark == false then
        local position = vector(render.screen_size().x/2, render.screen_size().y - 20)
        if items.info.watermark:get() == "Legacy" then
            local watermarktext = gradient.text_animate("BEBRASENSE", -1, {items.info.accentcolor:get()*1.5, items.info.accentcolor:get()})
            render.text(1, position, color(255), "sc", watermarktext:get_animated_text().. "\affffffff [ "..colors.red..string.upper(user.build.current).."\affffffff ]")
            watermarktext:animate()
        elseif items.info.watermark:get() == "Default" then
            local measure_text = render.measure_text(wmfont, nil, "bebrasense"..string.lower(user.build.current))
            local watermarktext = gradient.text_animate("bebrasense", -1, {items.info.accentcolor:get()*1.5, items.info.accentcolor:get()})
            watermarktext:animate()
            render.blur(
                position + -measure_text/2 + vector(
                    -8,-4
                ),
                position + measure_text/2 + vector(
                    8,4
                ),
                1,
                1,
                4
            )
            render.rect(
                position + -measure_text/2 + vector(
                    -8,-4
                ),
                position + measure_text/2 + vector(
                    8,4
                ),
                color(0, 100),
                4,
                true
            )
            render.shadow(
                position + vector(20, 1),
                position + vector(50, 1),
                color(255,100,100),
                10,
                0,0
            )
            render.text(wmfont, position, color(255), "sc", watermarktext:get_animated_text().." "..user.build.color_hex..user.build.current)
        elseif items.info.watermark:get() == "Kitty" then
            render.blur(
                position - vector(14,24),
                position + vector(14,4),
                1,
                1,
                100
            )
            render.rect(
                position - vector(14,24),
                position + vector(14,4),
                color(0, 100),
                100,
                true
            )
            render.rect_outline(
                position - vector(14,24),
                position + vector(14,4),
                items.info.accentcolor:get(),
                1,
                100,
                true
            )
            render.texture(
                kitty,
                position - vector(12,22)
            )
            render.text(2, position + vector(0,10), user.build.color_rgb, "c", string.upper(user.build.current))
        end
    end
end)

-- clantag

clantagcount = 0
index = 1
frames = {1,2,3,4,5,6,7,8,9,10}
text = "bebrasense"
clantagspeed = 0.5
is_shrinking = true

local function animatetag(text, length) -- chatgpt ass code cuz im too shit to make it myself ;-;
    if not globals.is_connected then return end
    local time = utils.net_channel().time
    local num_frames = #frames * 2
    index = math.floor(time / clantagspeed) % num_frames + 1
    if index <= #text then
        is_shrinking = true
    elseif index > #text + 1 then
        is_shrinking = false
    end

    if is_shrinking then
        length = math.max(0, #text - index + 1) -- Shrink
    else
        length = index - #text - 1 -- Expand
    end
    if length == 0 then return "" end
    --local i = frames[index + 1]

    return string.sub(text, 1, length)
end
events.net_update_start(function()
    if items.misc.clantag:get() ~= true then return end
    if (not globals.is_connected) or (not entity.get_local_player()) or (not globals.choked_commands) then return end

    if items.misc.clantag.mode:get() == "Custom" then
        if clantagcount > 64 then
            clantagcount = 0
            common.set_clan_tag(items.misc.clantag.tag:get())
        else
            clantagcount = clantagcount + 1
        end
    elseif items.misc.clantag.mode:get() == "BebraSense" then
        if clantagcount > clantagspeed * 64 then
            clantag = animatetag(text, frames)
            common.set_clan_tag(clantag)
            clantagcount = 1
        else
            clantagcount = clantagcount + 1
        end
    end
end)

items.misc.clantag:set_callback(function()
    if items.misc.clantag:get() == false then
        common.set_clan_tag("")
        is_shrinking = true
        index = 1
    end
end)

-- aimbot logs

local box = {
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	[0] = "generic"
}

local aim = {}
events.aim_ack(function(shot)
    if items.visuals.logs:get() == true then
        local accentcolor = "\a"..items.info.accentcolor:get():to_hex()

        if shot.state == nil then
            -- no miss reason so shot hit target
            local logtext = string.format("Hit %s's "..accentcolor.."%s\aDEFAULT for \a96dc96ff%d\aDEFAULT damage (want: %d) (%dhp) (aimed: %s) (hc: %d%%) (bt: %d)",
                shot.target:get_name() or "?",
                box[shot.wanted_hitgroup] or "?",
                shot.damage or "?",
                shot.wanted_damage or "?",
                shot.target.m_iHealth or "?",
                box[shot.wanted_hitgroup] or "?",
                shot.hitchance or "?",
                shot.backtrack or "?"
            )
            print_raw("[ "..accentcolor.."BEBRASENSE\aDEFAULT ] - "..logtext)
            print_dev(logtext)
        else
            -- missed shot due to neverlose
            local logtext = string.format("Missed %s's "..accentcolor.."%s\aDEFAULT due to \aff6464ff%s\aDEFAULT (want: %d) (hc: %d%%) (bt: %d)",
                shot.target:get_name() or "?",
                box[shot.wanted_hitgroup] or "?",
                shot.state or "the void", -- void should never happen but whatever lmao
                shot.wanted_damage or "?",
                shot.hitchance or "?",
                shot.backtrack or "?"
            )
            print_raw("[ "..accentcolor.."BEBRASENSE\aDEFAULT ] - "..logtext)
            print_dev(logtext)
        end
    end
end)
events.player_hurt(function(par)
    if items.visuals.logs:get() == true then
        local accentcolor = "\a"..items.info.accentcolor:get():to_hex()
        local atk = entity.get(par.attacker, true):get_name()
        local hurt = entity.get(par.userid, true):get_name()
        if atk == entity.get_local_player():get_name() and hurt ~= entity.get_local_player():get_name() then
            if par.weapon == "inferno" or par.weapon == "hegrenade" or par.weapon == "knife" then
                local logtext = "Hit "..hurt.." for "..colors.mildgreen..par.dmg_health..colors.consoletext.." damage ("..par.health.."hp)"
                print_raw("[ "..accentcolor.."BEBRASENSE\aDEFAULT ] - "..logtext)
                print_dev(logtext)
            end
        end
    end
end)

events.shutdown(function()
    cvar.r_aspectratio:int(0)
    utils.console_exec("viewmodel_presetpos 1")
    utils.console_exec("bind mouse1 +attack")
end)
